<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="description" content="自然体験・イベントを探して予約できるプラットフォーム。トレッキング、カヤック、星空観察など、あなたにぴったりのアクティビティを見つけよう。">
  <title>自然体験プラットフォーム | そとなび</title>
  <link rel="icon" type="image/png" href="https://res.cloudinary.com/ddrxsy9jw/image/upload/f_auto,q_auto,w_32/logo_tfqqd0">
  <link rel="apple-touch-icon" href="https://res.cloudinary.com/ddrxsy9jw/image/upload/f_auto,q_auto,w_180/logo_tfqqd0">
  <link rel="stylesheet" href="styles.css">
  <!-- d3.js and topojson-client for SVG map (script方式で統一) -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "そとなび",
    "description": "自然体験・イベントを探して予約できるプラットフォーム",
    "url": "https://example.com"
  }
  </script>
  <script>
    // GitHub raw URL（全ページ共通設定）
    window.GITHUB_RAW_BASE = "https://raw.githubusercontent.com/setagayatankyubase-create/trip-platform/main";
    // Google Maps API キー
    window.GOOGLE_MAPS_API_KEY = window.GOOGLE_MAPS_API_KEY || 'AIzaSyDNV6H5ImWmE2DhWdRYupUER85Rb8ZqmQM';
  </script>
  <script>
    // ロゴ画像をCloudinaryから取得（data.js読み込み後に実行）
    (function() {
      function setLogoUrl() {
        const logoImage = document.querySelector('.logo-image');
        if (logoImage && typeof window.getLogoUrl === 'function') {
          logoImage.src = window.getLogoUrl();
        }
      }
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setLogoUrl);
      } else {
        setLogoUrl();
      }
    })();
  </script>
<body>
  <header class="main-header" id="main-header">
    <div class="nav">
      <div class="nav-left">
        <a href="index.html" class="logo">
          <img src="" alt="そとなび" class="logo-image">
        </a>
        <div class="header-search" id="header-search" style="display: none;">
          <form class="header-search-form" onsubmit="handleSearch(event)">
            <button type="button" class="header-category-menu-button" id="header-category-menu-button" aria-label="カテゴリメニュー">
              <span class="hamburger-icon">
                <span></span>
                <span></span>
                <span></span>
              </span>
            </button>
            <input type="text" placeholder="場所名・体験名で探す" name="q" class="header-search-input">
            <button type="submit" class="header-search-button">検索</button>
          </form>
        </div>
      </div>
      <div class="nav-links">
        <a href="list.html">イベント一覧</a>
        <a href="organizer-list.html">提供元</a>
        <a href="column.html">コラム</a>
      </div>
    </div>
  </header>

  <!-- Hero Section -->
  <section class="hero-section">
    <div class="hero-section-background" id="hero-bg-1" style="opacity: 1;"></div>
    <div class="hero-section-background" id="hero-bg-2"></div>
    <div class="hero-content">
      <h1 class="hero-title">東京のすぐそばに、まだ知らない<br>自然がある</h1>
      <div class="search-wrapper">
        <form class="hero-search-form" id="main-search-form" onsubmit="handleSearch(event)">
          <button type="button" class="category-menu-button" id="category-menu-button" aria-label="カテゴリメニュー">
            <span class="hamburger-icon">
              <span></span>
              <span></span>
              <span></span>
            </span>
          </button>
          <input type="text" id="search-query" placeholder="場所名・体験名で探す" name="q" class="hero-search-input">
          <button type="submit" class="hero-search-button">検索</button>
        </form>
        <div class="category-menu" id="category-menu">
          <div class="category-menu-content" id="category-menu-list"></div>
        </div>
      </div>
      <p class="hero-subtext">週末を、そとなびで</p>
    </div>
  </section>

  <main>
    <!-- ポップセクション（季節・編集部おすすめ） -->
    <section class="section pop-section">
      <!-- 1段目：大きな横長バナー -->
      <div class="pop-banner-wrapper">
        <div id="pop-banner-container"></div>
      </div>
      <!-- 2段目：キャンペーンカード -->
      <div class="pop-campaigns-wrapper">
        <div class="pop-carousel-wrapper">
          <div class="pop-carousel" id="pop-carousel"></div>
        </div>
      </div>
    </section>

    <!-- 今週のイベント -->
    <section class="section event-block">
      <div class="week-event-header">
        <h2 id="week-event-title">今週のイベント</h2>
      </div>
      <div class="week-calendar-wrapper">
        <div class="week-calendar" id="week-calendar"></div>
        <button id="next-week-btn" class="week-nav-arrow" onclick="showNextWeek()">→</button>
      </div>
    </section>

    <!-- 行きたいエリアを選ぶ -->
    <section class="section event-block" id="map-search-section">
      <div class="event-block-header">
        <h2>行きたいエリアを選ぶ</h2>
      </div>
      <div class="map-search-container">
        <div class="map-search-description">
          <p>地図からエリアを選んで体験を見る</p>
        </div>
        <div class="map-search-map" id="map-search-map">
          <div class="map-area">
            <div class="map-left">
              <div class="map-stage" id="map-svg-container">
                <svg id="kantoMap" class="map-svg"></svg>
              </div>
            </div>
            <aside class="map-right">
              <div class="filters">
                <div class="condition-line" id="conditionLine">
                  <span id="conditionSentence">条件：未選択（全件表示）</span>
                  <button class="linkbtn" id="clearAreaBtn" type="button" disabled>クリア</button>
                </div>
                <div class="selected-chips" id="selectedChips" aria-live="polite"></div>

                <section class="card" id="categoryCard">
                  <div class="card__head">
                    <h3 class="card__title">カテゴリで探す</h3>
                  </div>
                  <p class="card__hint">大分類からメインテーマを選べます</p>
                  <div class="chipgrid" id="categoryChips"></div>
                </section>

                <section class="card card--cta">
                  <p class="cta__hint">条件を一覧で確認して気になる体験を探す</p>
                  <button class="cta" id="searchToListBtn" type="button">
                    この条件で一覧を見る
                  </button>
                </section>
              </div>
            </aside>
          </div>
        </div>
      </div>
    </section>

    <!-- 直近開催イベント -->
    <section class="section event-block">
      <div class="event-block-header">
        <h2>直近開催イベント</h2>
        <a href="list.html?upcoming=1" class="view-all">すべて見る →</a>
      </div>
      <div class="card-carousel-wrapper">
        <div class="card-carousel" id="upcoming-events"></div>
      </div>
    </section>

    <!-- 新着イベント -->
    <section class="section event-block">
      <div class="event-block-header">
        <h2>新着イベント</h2>
        <a href="list.html?new=1" class="view-all">すべて見る →</a>
      </div>
      <div class="card-carousel-wrapper">
        <div class="card-carousel" id="new-events"></div>
      </div>
    </section>

    <!-- 人気カテゴリ -->
    <section id="categories" class="section">
      <h2>人気カテゴリ</h2>
      <div class="categories" id="category-list"></div>
    </section>

    <!-- 人気イベント -->
    <section class="section event-block">
      <div class="event-block-header">
        <h2>人気イベント</h2>
        <a href="list.html?recommended=1" class="view-all">すべて見る →</a>
      </div>
      <div class="card-carousel-wrapper">
        <div class="card-carousel" id="recommended-events"></div>
      </div>
    </section>
  </main>

  <!-- タグ・地域検索セクション -->
  <section class="section popular-search-section">
    <div class="popular-search-container">
      <div class="popular-search-tabs">
        <button class="popular-tab active" data-tab="categories">カテゴリー</button>
        <button class="popular-tab" data-tab="areas">行き先</button>
        <button class="popular-tab" data-tab="tags">タグ</button>
      </div>
      <div class="popular-search-content">
        <div class="popular-list-container" id="popular-categories-list"></div>
        <div class="popular-list-container hidden" id="popular-areas-list"></div>
        <div class="popular-list-container hidden" id="popular-tags-list"></div>
      </div>
    </div>
  </section>

  <footer class="main-footer">
    <div class="footer-content">
      <div class="footer-column">
        <h3>サポート</h3>
        <a href="contact.html">お問い合わせ</a>
        <a href="terms.html">利用規約</a>
        <a href="privacy.html">プライバシーポリシー</a>
      </div>
      <div class="footer-column">
        <h3>運営情報</h3>
        <a href="about.html">運営について</a>
      </div>
      <div class="footer-column">
        <h3>掲載について</h3>
        <a href="publish.html">掲載について</a>
      </div>
    </div>
    <div class="footer-bottom">
      <div class="footer-copyright">
        © <span id="current-year"></span> そとなび. 製作
      </div>
    </div>
  </footer>

  <script src="data.js?v=4_2025-12-25"></script>
  <script src="app.js"></script>
  <script>
    // ポップセクションのレンダリング
    function renderPopSection() {
      const bannerContainer = document.getElementById('pop-banner-container');
      const carouselContainer = document.getElementById('pop-carousel');
      
      // バナーデータ
      const bannerData = {
        type: 'banner',
        title: '季節で楽しむ、自然のあそび。',
        subtitle: '山・森・川・海。<br>子どもも大人も、気軽に参加できる自然体験を集めました。',
        badge: '',
        cta: '体験を探す',
        image: 'pop1_j2wr9k', // バナー画像
        bgColor: '#6BB6FF', // 右側の背景色
        link: '/list.html'
      };

      // キャンペーンカードデータ
      const campaignData = [
        {
          type: 'card',
          title: '冬の自然体験',
          subtitle: '雪・野鳥・里山',
          badge: '季節',
          image: 'pop4_fucevc', // 冬の画像
          link: '/?season=winter'
        },
        {
          type: 'card',
          title: '春の自然観察',
          subtitle: '植物・生き物・里山',
          badge: '季節',
          image: 'pop2_go0z71', // 春の画像
          link: '/?season=spring'
        },
        {
          type: 'card',
          title: '親子で楽しむ自然体験',
          subtitle: '家族で一緒に自然を学ぶ',
          badge: '親子',
          image: 'pop3_y2bf8t', // 親子の画像
          link: '/?q=親子'
        },
        {
          type: 'card',
          title: '小笠原諸島',
          subtitle: '世界自然遺産の島々',
          badge: '特別',
          image: 'pop5_wkswlf', // 小笠原諸島の画像
          link: '/?area=小笠原諸島'
        }
      ];

      // 1段目：バナーのレンダリング
      if (bannerContainer && bannerData) {
        let imageUrl = '';
        if (bannerData.image) {
          if (typeof window.cloudinaryUrl === 'function') {
            imageUrl = window.cloudinaryUrl(bannerData.image, { w: 1000, h: 560 });
          } else if (bannerData.image.startsWith('http')) {
            imageUrl = bannerData.image;
          } else {
            imageUrl = `https://res.cloudinary.com/ddrxsy9jw/image/upload/f_auto,q_auto,w_1000,h_560/${bannerData.image}`;
          }
        }

        const imageStyle = imageUrl 
          ? `background-image: url('${imageUrl.replace(/'/g, "\\'")}');`
          : '';
        
        const bgColor = bannerData.bgColor || '#6BB6FF';

        bannerContainer.innerHTML = `
          <a href="${bannerData.link || '#'}" class="pop-banner">
            <div class="pop-banner-image" style="${imageStyle}">
              <div class="pop-banner-image-overlay">
                ${bannerData.badge ? `<span class="pop-banner-badge">${bannerData.badge}</span>` : ''}
                <div class="pop-banner-title">
                  ${bannerData.title || ''}
                </div>
              </div>
            </div>
            <div class="pop-banner-content" style="background: ${bgColor};">
              <div class="pop-banner-subtitle">${bannerData.subtitle || ''}</div>
              ${bannerData.cta ? `<span class="pop-banner-button">${bannerData.cta}</span>` : ''}
            </div>
          </a>
        `;
      }

      // 2段目：キャンペーンカードのレンダリング（無限スクロール対応）
      if (carouselContainer && campaignData && campaignData.length > 0) {
        // カードをレンダリングする関数
        const renderCard = (pop) => {
          let imageUrl = '';
          if (pop.image) {
            if (typeof window.cloudinaryUrl === 'function') {
              imageUrl = window.cloudinaryUrl(pop.image, { w: 640, h: 480 });
            } else if (pop.image.startsWith('http')) {
              imageUrl = pop.image;
            } else {
              imageUrl = `https://res.cloudinary.com/ddrxsy9jw/image/upload/f_auto,q_auto,w_640,h_480/${pop.image}`;
            }
          }

          const imageStyle = imageUrl 
            ? `background-image: url('${imageUrl.replace(/'/g, "\\'")}');`
            : '';

          return `
            <a href="${pop.link || '#'}" class="pop-card">
              <div class="pop-card-image" style="${imageStyle}">
                <div class="pop-card-overlay">
                  ${pop.badge ? `<span class="pop-card-badge">${pop.badge}</span>` : ''}
                  <div class="pop-card-title">${pop.title || ''}</div>
                  ${pop.subtitle ? `<div class="pop-card-subtitle">${pop.subtitle}</div>` : ''}
                  <span class="pop-card-cta">詳しく見る →</span>
                </div>
              </div>
            </a>
          `;
        };

        // カードを2セット作成（無限ループ用）
        const cardsHtml = campaignData.map(renderCard).join('');
        carouselContainer.innerHTML = cardsHtml + cardsHtml; // 元のセット + 複製セット
        
        // 無限スクロールアニメーションを開始
        setTimeout(() => {
          const wrapper = carouselContainer.parentElement;
          if (wrapper) {
            wrapper.classList.add('pop-carousel-infinite');
          }
        }, 100);
      } else if (carouselContainer && (!campaignData || campaignData.length === 0)) {
        carouselContainer.parentElement.parentElement.style.display = 'none';
      }
    }

    function handleCategoryToggle(value, label, isActive) {
      const nextCategories = isActive
        ? window.selectedCategories.filter(cat => cat !== value)
        : [...window.selectedCategories, value];
      window.selectedCategories = nextCategories;
      if (value && label) {
        window.categoryLabelMap[value] = label;
      }
      applyFiltersAndRender({ label: isActive ? "" : label });
    }

    function handleTagToggle(value, label, isActive) {
      const nextTags = isActive
        ? window.selectedTags.filter(tag => tag !== value)
        : [...window.selectedTags, value];
      window.selectedTags = nextTags;
      if (value && label) {
        window.tagLabelMap[value] = label;
      }
      applyFiltersAndRender({ label: isActive ? "" : label });
    }

    function initSearchToListButton() {
      const button = document.getElementById('searchToListBtn');
      if (!button) return;
      button.addEventListener('click', () => {
        const params = new URLSearchParams();
        const selectedPrefs = Array.isArray(window.selectedPrefectures) ? window.selectedPrefectures : [];
        if (selectedPrefs.length) {
          params.set('pref', selectedPrefs.join(','));
        }
        if (window.selectedCategories.length) {
          params.set('category', window.selectedCategories.join(','));
        }
        if (window.selectedTags.length) {
          params.set('tag', window.selectedTags.join(','));
        }
        const query = params.toString();
        const targetUrl = query ? `list.html?${query}` : 'list.html';
        window.location.href = targetUrl;
      });
    }

    function initAreaClearButton() {
      const button = document.getElementById('clearAreaBtn');
      if (!button) return;
      button.addEventListener('click', () => {
        const heroSearchInput = document.getElementById('search-query');
        const headerSearchInput = document.querySelector('#header-search .header-search-input');
        if (heroSearchInput) heroSearchInput.value = "";
        if (headerSearchInput) headerSearchInput.value = "";
        window.selectedPrefectures = [];
        window.selectedCategories = [];
        window.selectedTags = [];
        applyFiltersAndRender({ label: "" });
      });
    }

    // タグ・地域検索セクションのレンダリング
    async function renderPopularSearch() {
      // タブ切り替え
      document.querySelectorAll('.popular-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const tabName = tab.dataset.tab;
          
          // すべてのタブとコンテナを非アクティブに
          document.querySelectorAll('.popular-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.popular-list-container').forEach(c => c.classList.add('hidden'));
          
          // 選択されたタブとコンテナをアクティブに
          tab.classList.add('active');
          document.getElementById(`popular-${tabName}-list`).classList.remove('hidden');
        });
      });

      // カテゴリ一覧をレンダリング（非同期）
      await renderPopularCategories();
      renderPopularAreas();
      renderPopularTags();
    }

    // カテゴリ一覧
    async function renderPopularCategories() {
      const container = document.getElementById('popular-categories-list');
      if (!container || !window.eventMeta || !window.eventMeta.categories) {
        console.log('[renderPopularCategories] Container or categories not found');
        return;
      }

      const categories = window.eventMeta.categories; // すべてのカテゴリを表示
      console.log('[renderPopularCategories] Rendering', categories.length, 'categories');
      
      // eventData.eventsの確認
      const eventDataCount = Array.isArray(window.eventData?.events) ? window.eventData.events.length : 0;
      console.log('[renderPopularCategories] eventData.events:', eventDataCount, 'events');
      
      if (eventDataCount === 0) {
        console.warn('[renderPopularCategories] eventData.events is empty, categories will show 0 events');
        container.innerHTML = categories.map(cat => `
          <a href="list.html?category=${cat.id}" class="popular-item" data-item-id="${cat.id}">
            <span class="popular-item-name">${cat.name}</span>
            <span class="popular-item-count">0 イベント</span>
          </a>
        `).join('');
        return;
      }
      
      // まず同期版でカウント（categoryIdが既にある場合）
      let html = categories.map(cat => {
        const eventCount = countEventsByCategorySync(cat.id);
        return { cat, count: eventCount };
      }).map(({ cat, count }) => `
        <a href="list.html?category=${cat.id}" class="popular-item" data-item-id="${cat.id}">
          <span class="popular-item-name">${cat.name}</span>
          <span class="popular-item-count">${count} イベント</span>
        </a>
      `).join('');
      
      container.innerHTML = html;
      
      // 非同期でcategoryIdを補完して再カウント
      const categoryCounts = await Promise.all(
        categories.map(async cat => {
          const count = await countEventsByCategory(cat.id);
          return { cat, count };
        })
      );
      
      // 更新されたカウントで再レンダリング
      html = categoryCounts.map(({ cat, count }) => `
        <a href="list.html?category=${cat.id}" class="popular-item" data-item-id="${cat.id}">
          <span class="popular-item-name">${cat.name}</span>
          <span class="popular-item-count">${count} イベント</span>
        </a>
      `).join('');
      
      container.innerHTML = html;
      console.log('[renderPopularCategories] Updated category counts:', categoryCounts.map(({ cat, count }) => `${cat.name}: ${count}`).join(', '));
    }

    // エリア一覧（関東＋山梨）
    function renderPopularAreas() {
      const container = document.getElementById('popular-areas-list');
      if (!container || !Array.isArray(window.eventIndex)) return;

      // 関東地方＋山梨県の都道府県リスト
      const kantoPrefectures = [
        '東京都',
        '神奈川県',
        '千葉県',
        '埼玉県',
        '群馬県',
        '栃木県',
        '茨城県',
        '山梨県'
      ];

      // 都道府県ごとにイベント数を集計
      const prefectureMap = new Map();
      window.eventIndex.forEach(event => {
        const prefecture = event.prefecture || '';
        if (prefecture && kantoPrefectures.includes(prefecture)) {
          prefectureMap.set(prefecture, (prefectureMap.get(prefecture) || 0) + 1);
        }
      });

      // 関東＋山梨の都道府県を順番に表示（イベント数順）
      const areas = kantoPrefectures
        .map(pref => ({
          name: pref,
          count: prefectureMap.get(pref) || 0
        }))
        .sort((a, b) => b.count - a.count);

      container.innerHTML = areas.map(area => {
        return `
          <a href="list.html?area=${encodeURIComponent(area.name)}" class="popular-item" data-item-name="${area.name}">
            <span class="popular-item-name">${area.name}</span>
            <span class="popular-item-count">${area.count} イベント</span>
          </a>
        `;
      }).join('');
    }

    // タグ一覧
    function renderPopularTags() {
      const container = document.getElementById('popular-tags-list');
      if (!container) return;

      // eventData.eventsを優先、なければeventIndexを使用
      const source = Array.isArray(window.eventData?.events) && window.eventData.events.length > 0
        ? window.eventData.events
        : (Array.isArray(window.eventIndex) ? window.eventIndex : []);

      if (source.length === 0) return;

      // タグとして人気のキーワードを使用（タグ名と検索キーワードのマッピング）
      const tagConfigs = [
        { name: '川遊び', keywords: ['川', '川遊び', '水遊び'] },
        { name: '海・ビーチ', keywords: ['海', 'ビーチ', '海岸', 'マリンスポーツ'] },
        { name: '里山体験', keywords: ['里山', '里山体験', '田舎'] },
        { name: '自然観察', keywords: ['観察', '自然観察', '観察会'] },
        { name: '生き物', keywords: ['生き物', '生物', '動物', '昆虫'] },
        { name: '農業体験', keywords: ['農業', '農業体験', '農作業'] },
        { name: '収穫体験', keywords: ['収穫', '収穫体験', '採り'] },
        { name: '植物', keywords: ['植物', '草花', '花', '樹木'] },
        { name: '野鳥', keywords: ['野鳥', '鳥', 'バードウォッチング'] },
        { name: '星空', keywords: ['星空', '星', '天体', '星座'] },
        { name: 'キャンプ', keywords: ['キャンプ', 'テント', '焚き火'] },
        { name: '親子', keywords: ['親子', '家族', '子ども', '子供'] },
      ];

      // 各タグのイベント数をカウント（複数のキーワードで検索）
      const tags = tagConfigs.map(tagConfig => {
        const count = source.filter(e => {
          const searchTexts = [
            e.title,
            e.name,
            e.description,
            e.detail,
            e.city,
            e.prefecture,
            e.area,
            e.area_name,
            e.category,
            e.category_name,
            e.category && e.category.name ? e.category.name : null
          ].filter(Boolean).join(' ').toLowerCase();
          
          // タグのキーワードのいずれかが含まれているかチェック
          return tagConfig.keywords.some(keyword => 
            searchTexts.includes(keyword.toLowerCase())
          );
        }).length;
        
        return { name: tagConfig.name, count: count, keywords: tagConfig.keywords };
      }).filter(tag => tag.count > 0).sort((a, b) => b.count - a.count);

      container.innerHTML = tags.map(tag => {
        // タグ名とキーワードの両方で検索できるように、最初のキーワードを使用
        const searchQuery = tag.keywords[0];
        return `
          <a href="list.html?q=${encodeURIComponent(searchQuery)}" class="popular-item" data-tag-name="${tag.name}">
            <span class="popular-item-name">${tag.name}</span>
            <span class="popular-item-count">${tag.count} イベント</span>
          </a>
        `;
      }).join('');
    }

    // カテゴリ別イベント数をカウント（詳細JSONからcategoryIdを取得して計測）
    async function countEventsByCategory(categoryId) {
      // eventData.eventsを優先して使用
      const source = Array.isArray(window.eventData?.events) ? window.eventData.events : [];
      
      if (source.length === 0) {
        console.log('[countEventsByCategory] No eventData.events available for category:', categoryId);
        return 0;
      }
      
      // categoryIdが空のイベントの詳細を読み込んで補完（すべてのイベントを対象）
      const eventsWithoutCategory = source.filter(e => !e.categoryId && !e.category_id && !e.category);
      if (eventsWithoutCategory.length > 0) {
        console.log('[countEventsByCategory] Loading categoryId for', eventsWithoutCategory.length, 'events');
        try {
          // すべてのイベントの詳細を読み込んで categoryId を補完
          const detailPromises = eventsWithoutCategory.map(e => 
            loadEventDetail(e.id).catch(() => null)
          );
          const details = await Promise.all(detailPromises);
          const detailMap = {};
          details.forEach(d => {
            if (d && d.id && d.categoryId) {
              detailMap[d.id] = d.categoryId;
            }
          });
          
          // sourceにcategoryIdを補完
          source.forEach(item => {
            if (detailMap[item.id]) {
              item.categoryId = detailMap[item.id];
            }
          });
          
          console.log('[countEventsByCategory] Enriched categoryId for', Object.keys(detailMap).length, 'events');
        } catch (e) {
          console.warn('[countEventsByCategory] Failed to enrich categoryId:', e);
        }
      }
      
      const matches = source.filter(e => {
        const catId = e.categoryId || e.category_id || e.category;
        return String(catId) === String(categoryId);
      });
      
      return matches.length;
    }
    
    // 同期版（キャッシュされたデータを使用）
    function countEventsByCategorySync(categoryId) {
      const source = Array.isArray(window.eventData?.events) ? window.eventData.events : [];
      if (source.length === 0) return 0;
      
      const matches = source.filter(e => {
        const catId = e.categoryId || e.category_id || e.category;
        return String(catId) === String(categoryId);
      });
      
      return matches.length;
    }

    // キーワード別イベント数をカウント（eventData.eventsを優先）
    function countEventsByKeyword(keyword) {
      // eventData.eventsを優先、なければeventIndexを使用
      const source = Array.isArray(window.eventData?.events) && window.eventData.events.length > 0
        ? window.eventData.events
        : (Array.isArray(window.eventIndex) ? window.eventIndex : []);
      
      if (source.length === 0) return 0;
      
      const kw = keyword.toLowerCase();
      return source.filter(e => {
        const texts = [
          e.title,
          e.name, // API側で title が name になっている場合に対応
          e.description,
          e.city,
          e.prefecture,
          e.area,
          e.area_name,
          e.category,
          e.category_name,
          e.category && e.category.name ? e.category.name : null
        ].filter(Boolean); // null/undefinedを除外
        
        return texts.some(t => typeof t === 'string' && t.toLowerCase().includes(kw));
      }).length;
    }

    // カテゴリIDからlucide-staticアイコン名へのマッピング
    const categoryIconMap = {
      'river-water': 'waves',
      'sea-beach': 'shell',
      'mountain-satoyama': 'mountain',
      'forest': 'trees',
      'wildlife': 'paw-print',
      'farm-harvest': 'wheat',
      'animals': 'dog',
      'fire-outdoor': 'flame',
      'camp': 'tent',
      'natural-materials': 'leaf',
      'cycling': 'bike',
      'seasonal': 'sun-snow'
    };

    // カテゴリアイコンのURLを取得
    function getCategoryIconUrl(categoryId) {
      const iconName = categoryIconMap[categoryId];
      if (!iconName) return '';
      return `https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/${iconName}.svg`;
    }

    // カテゴリ一覧の表示（人気カテゴリ：イベント数の多い順に最大6件）
    function renderCategories() {
      const container = document.getElementById('category-list');
      if (!container) return;

      // eventMeta.categories を優先、なければ eventData.categories を使用
      const categories = (window.eventMeta && window.eventMeta.categories) 
        ? window.eventMeta.categories 
        : (window.eventData && window.eventData.categories) 
          ? window.eventData.categories 
          : null;
      
      console.log('[index.html] renderCategories - categories:', categories);
      
      if (!categories || !Array.isArray(categories) || categories.length === 0) {
        console.warn('[index.html] renderCategories - No categories found');
        return;
      }

      // イベントごとのカテゴリ出現回数を集計
      const events = (window.eventData && Array.isArray(window.eventData.events))
        ? window.eventData.events
        : [];

      const counts = {};
      if (events.length > 0) {
        events.forEach(ev => {
          const ids = new Set();
          if (ev.categoryId) ids.add(String(ev.categoryId));
          if (ev.category_id) ids.add(String(ev.category_id));
          if (ev.category) ids.add(String(ev.category));
          if (Array.isArray(ev.categories)) {
            ev.categories.forEach(c => {
              if (!c) return;
              if (typeof c === 'string') {
                ids.add(c);
              } else if (c.id) {
                ids.add(String(c.id));
              }
            });
          }
          ids.forEach(id => {
            counts[id] = (counts[id] || 0) + 1;
          });
        });
      }

      console.log('[index.html] renderCategories - counts:', counts);

      // 人気順にソートし、最大6件に絞る
      let sorted = categories.slice();
      if (Object.keys(counts).length > 0) {
        sorted.sort((a, b) => {
          const ca = counts[a.id] || 0;
          const cb = counts[b.id] || 0;
          if (cb !== ca) return cb - ca; // 多い順
          // 同数なら元の順序を維持（idで安定ソート）
          return String(a.id).localeCompare(String(b.id));
        });

        // 1件以上イベントがあるカテゴリだけに絞る
        sorted = sorted.filter(cat => (counts[cat.id] || 0) > 0);
      }

      // 最大6件まで
      const topCategories = sorted.slice(0, 6);

      container.innerHTML = topCategories.map(cat => {
        const iconUrl = getCategoryIconUrl(cat.id);
        return `
        <a href="list.html?category=${cat.id}" class="cat">
          ${iconUrl ? `<img src="${iconUrl}" alt="${cat.name || ''}" class="category-icon" />` : '<span></span>'}
          <span>${cat.name || ''}</span>
        </a>
      `;
      }).join('');
    }

    // カテゴリメニューの位置を計算（fixed position用）
    function positionCategoryMenu() {
      const btn = document.getElementById('category-menu-button');
      const menu = document.querySelector('.category-menu');
      if (!btn || !menu) return;

      const rect = btn.getBoundingClientRect();
      const gap = 8;

      menu.style.top = `${rect.bottom + gap}px`;
      menu.style.left = `${rect.left}px`;

      // 右にはみ出す場合の保険
      const menuRect = menu.getBoundingClientRect();
      const overflowRight = menuRect.right - window.innerWidth;
      if (overflowRight > 0) {
        menu.style.left = `${Math.max(8, rect.left - overflowRight - 8)}px`;
      }

      // 下にはみ出す場合は max-height を調整
      const available = window.innerHeight - (rect.bottom + gap) - 8;
      menu.style.maxHeight = `${Math.max(120, available)}px`;
    }

    // カテゴリメニューを初期化（ホバーで表示されるので、事前にレンダリングしておく）
    function initCategoryMenu() {
      const menuList = document.getElementById('category-menu-list');
      if (!menuList) return;

      // eventMeta.categories を優先、なければ eventData.categories を使用
      const categories = (window.eventMeta && window.eventMeta.categories) 
        ? window.eventMeta.categories 
        : (window.eventData && window.eventData.categories) 
          ? window.eventData.categories 
          : null;
      
      console.log('[index.html] initCategoryMenu - categories:', categories);
      
      if (!categories || !Array.isArray(categories) || categories.length === 0) {
        console.warn('[index.html] initCategoryMenu - No categories found');
        return;
      }
      
      menuList.innerHTML = categories.map(cat => {
        const iconUrl = getCategoryIconUrl(cat.id);
        return `
        <a href="list.html?category=${cat.id}" class="category-menu-item">
          ${iconUrl ? `<img src="${iconUrl}" alt="${cat.name || ''}" class="icon" />` : '<span class="icon"></span>'}
          <span class="name">${cat.name || ''}</span>
        </a>
      `;
      }).join('');

      const menu = document.querySelector('.category-menu');
      const categoryButton = document.getElementById('category-menu-button');
      let hideTimer = null;
      let isMenuOpen = false; // メニューの開閉状態を管理

      // メニューを表示する関数
      function showMenu() {
        if (hideTimer) {
          clearTimeout(hideTimer);
          hideTimer = null;
        }
        positionCategoryMenu();
        menu.style.opacity = '1';
        menu.style.visibility = 'visible';
        menu.style.pointerEvents = 'auto';
        menu.style.transform = 'translateY(0)';
        isMenuOpen = true;
      }

      // メニューを非表示にする関数
      function hideMenu() {
        if (hideTimer) {
          clearTimeout(hideTimer);
          hideTimer = null;
        }
        menu.style.opacity = '0';
        menu.style.visibility = 'hidden';
        menu.style.pointerEvents = 'none';
        menu.style.transform = 'translateY(-10px)';
        isMenuOpen = false;
      }

      // メニューをトグルする関数（クリック時）
      function toggleMenu() {
        if (isMenuOpen) {
          hideMenu();
        } else {
          showMenu();
        }
      }

      // ハンバーガーボタンのクリックイベント
      if (categoryButton) {
        categoryButton.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleMenu();
        });
      }

      // メニュー自体にカーソルが入った時（メニュー内を移動する際に非表示にならないように）
      if (menu) {
        menu.addEventListener('mouseenter', () => {
          if (isMenuOpen) {
            // メニューが開いている時のみ、マウスが入ったら表示を維持
            if (hideTimer) {
              clearTimeout(hideTimer);
              hideTimer = null;
            }
          }
        });
        menu.addEventListener('mouseleave', () => {
          // メニューからマウスが離れたら閉じる（クリックで開いた場合も）
          if (isMenuOpen) {
            hideMenu();
          }
        });
      }

      // メニュー外をクリックしたら閉じる
      document.addEventListener('click', (e) => {
        if (isMenuOpen && 
            !menu.contains(e.target) && 
            !categoryButton.contains(e.target)) {
          hideMenu();
        }
      });

      // リサイズ/スクロール時にも位置を更新
      window.addEventListener('resize', () => {
        if (menu && menu.style.visibility !== 'hidden') {
          positionCategoryMenu();
        }
      });

      window.addEventListener('scroll', () => {
        if (menu && menu.style.visibility !== 'hidden') {
          positionCategoryMenu();
        }
      }, { passive: true });
    }

    // スクロール時にヘッダーに検索欄を表示
    function initHeaderSearch() {
      const header = document.getElementById('main-header');
      const headerSearch = document.getElementById('header-search');
      const heroSearchForm = document.getElementById('main-search-form');
      const headerSearchForm = headerSearch?.querySelector('.header-search-form');
      const heroSearchInput = document.getElementById('search-query');
      const headerSearchInput = headerSearch?.querySelector('.header-search-input');

      if (!header || !headerSearch || !heroSearchForm || !headerSearchForm) return;

      // スクロールイベント
      window.addEventListener('scroll', () => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
        // スクロールしたら検索欄を表示
        if (scrollTop > 100) {
          headerSearch.style.display = 'flex';
          header.classList.add('scrolled');
        } else {
          headerSearch.style.display = 'none';
          header.classList.remove('scrolled');
        }
      }, { passive: true });

      // 検索入力の同期（ヒーローとヘッダー）
      if (heroSearchInput && headerSearchInput) {
        heroSearchInput.addEventListener('input', (e) => {
          headerSearchInput.value = e.target.value;
        });
        headerSearchInput.addEventListener('input', (e) => {
          heroSearchInput.value = e.target.value;
        });
      }

      // ヘッダーのカテゴリメニューボタンにもイベントを設定
      const headerCategoryButton = document.getElementById('header-category-menu-button');
      if (headerCategoryButton) {
        // カテゴリメニューの初期化を待つ
        setTimeout(() => {
          const menu = document.querySelector('.category-menu');
          if (menu) {
            let hideTimer = null;
            let isMenuOpen = false; // メニューの開閉状態を管理

            function showMenu() {
              if (hideTimer) {
                clearTimeout(hideTimer);
                hideTimer = null;
              }
              const btnRect = headerCategoryButton.getBoundingClientRect();
              menu.style.top = `${btnRect.bottom + 8}px`;
              menu.style.left = `${btnRect.left}px`;
              menu.style.opacity = '1';
              menu.style.visibility = 'visible';
              menu.style.pointerEvents = 'auto';
              menu.style.transform = 'translateY(0)';
              isMenuOpen = true;
            }

            function hideMenu() {
              if (hideTimer) {
                clearTimeout(hideTimer);
                hideTimer = null;
              }
              menu.style.opacity = '0';
              menu.style.visibility = 'hidden';
              menu.style.pointerEvents = 'none';
              menu.style.transform = 'translateY(-10px)';
              isMenuOpen = false;
            }

            function toggleMenu() {
              if (isMenuOpen) {
                hideMenu();
              } else {
                showMenu();
              }
            }

            // クリックイベント
            headerCategoryButton.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              toggleMenu();
            });
            
            // メニュー自体にカーソルが入った時（メニューが開いている時のみ表示を維持）
            menu.addEventListener('mouseenter', () => {
              if (isMenuOpen) {
                if (hideTimer) {
                  clearTimeout(hideTimer);
                  hideTimer = null;
                }
              }
            });
            
            // メニューからマウスが離れたら閉じる
            menu.addEventListener('mouseleave', () => {
              if (isMenuOpen) {
                hideMenu();
              }
            });

            // メニュー外をクリックしたら閉じる
            document.addEventListener('click', (e) => {
              if (isMenuOpen && 
                  !menu.contains(e.target) && 
                  !headerCategoryButton.contains(e.target)) {
                hideMenu();
              }
            });
          }
        }, 100);
      }
    }

    // ページ読み込み後に初期化
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initHeaderSearch();
      });
    } else {
      initHeaderSearch();
    }


    // 検索処理
    function handleSearch(event) {
      event.preventDefault();
      const formData = new FormData(event.target);
      const params = {
        q: formData.get('q') || '',
        category: formData.get('category') || '',
        date: formData.get('date') || '',
        area: formData.get('area') || ''
      };
      URLManager.setParams(params);
      window.location.href = `list.html?${new URLSearchParams(params).toString()}`;
    }

    // 曜日検索
    function searchByWeekday(weekday) {
      window.location.href = `list.html?weekday=${weekday}`;
    }

    // 週のオフセット（0=今週、1=次週、-1=先週など）
    let weekOffset = 0;

    // 当日始まりの1週間分を表示（次週ボタンでスライド入れ替え）
    function renderWeekCalendar(offset = 0) {
      const container = document.getElementById('week-calendar');
      if (!container) return;

      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // 当日始まりの1週間分を取得（offset=0なら今日から7日間、offset=1なら8日目から14日間）
      const startDate = new Date(today);
      startDate.setDate(today.getDate() + (offset * 7));

      const weekDays = [];
      for (let i = 0; i < 7; i++) {
        const date = new Date(startDate);
        date.setDate(startDate.getDate() + i);
        weekDays.push(date);
      }

      // 各日のイベント数をカウント
      const eventCounts = {};
      weekDays.forEach(date => {
        const dateStr = date.toISOString().split('T')[0];
        const count = (window.eventData?.events || []).filter(event =>
          event.dates && Array.isArray(event.dates) && event.dates.some(d => d.date === dateStr)
        ).length;
        eventCounts[dateStr] = count;
      });

      // 今日の日付文字列
      const todayStr = today.toISOString().split('T')[0];

      // 曜日名
      const weekDayNames = ['日', '月', '火', '水', '木', '金', '土'];

      // リスト生成
      let html = '<div class="week-calendar-list">';

      weekDays.forEach(date => {
        const dateStr = date.toISOString().split('T')[0];
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const dayIndex = date.getDay(); // 0=日曜日, 1=月曜日, ..., 6=土曜日
        const dayName = weekDayNames[dayIndex];
        const count = eventCounts[dateStr] || 0;
        const isToday = dateStr === todayStr;
        const hasEvents = count > 0;

        let itemClass = 'week-day-item';
        if (isToday) itemClass += ' today';
        if (hasEvents) itemClass += ' has-events';

        html += `<div class="${itemClass}" onclick="goToDateEvents('${dateStr}')">`;
        html += `<span class="week-day-date">${month}/${day}</span>`;
        html += `<span class="week-day-name">${dayName}</span>`;
        if (hasEvents) {
          html += `<span class="week-day-count">${count}件</span>`;
        }
        html += `</div>`;
      });

      html += '</div>';
      
      // スライドアニメーション用のクラスを追加
      container.classList.add('week-calendar-sliding');
      setTimeout(() => {
        container.classList.remove('week-calendar-sliding');
      }, 300);
      
      container.innerHTML = html;

      // 次週ボタンの表示を更新
      const nextWeekBtn = document.getElementById('next-week-btn');
      const weekTitleEl = document.getElementById('week-event-title');
      if (weekTitleEl) {
        weekTitleEl.textContent = offset === 0 ? '今週のイベント' : '来週のイベント';
      }
      if (nextWeekBtn) {
        if (offset === 0) {
          nextWeekBtn.textContent = '→';
          nextWeekBtn.onclick = () => showNextWeek();
        } else {
          nextWeekBtn.textContent = '←';
          nextWeekBtn.onclick = () => showThisWeek();
        }
      }
    }

    // 次週を表示
    function showNextWeek() {
      weekOffset = 1;
      renderWeekCalendar(weekOffset);
    }

    // 今週を表示
    function showThisWeek() {
      weekOffset = 0;
      renderWeekCalendar(weekOffset);
    }

    // 日付クリックでイベント一覧に遷移
    function goToDateEvents(dateStr) {
      window.location.href = `list.html?date=${dateStr}`;
    }

    // 2点間の距離を計算（Haversine formula）
    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 6371; // 地球の半径（km）
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = 
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c; // 距離（km）
    }

    // 都道府県の市区町村データ（座標付き）
    const prefectureCities = {
      'tokyo': [
        { name: '世田谷区', area: '世田谷区', lat: 35.6466, lng: 139.6533, hasSubAreas: true },
        { name: '渋谷区', area: '渋谷区', lat: 35.6580, lng: 139.7016, hasSubAreas: false },
        { name: '新宿区', area: '新宿区', lat: 35.6938, lng: 139.7034, hasSubAreas: false },
        { name: '港区', area: '港区', lat: 35.6586, lng: 139.7514, hasSubAreas: false },
        { name: '目黒区', area: '目黒区', lat: 35.6414, lng: 139.6982, hasSubAreas: false },
        { name: '品川区', area: '品川区', lat: 35.6156, lng: 139.7302, hasSubAreas: false },
        { name: '大田区', area: '大田区', lat: 35.5614, lng: 139.7161, hasSubAreas: false },
        { name: '杉並区', area: '杉並区', lat: 35.6995, lng: 139.6364, hasSubAreas: false },
        { name: '中野区', area: '中野区', lat: 35.7075, lng: 139.6639, hasSubAreas: false },
        { name: '練馬区', area: '練馬区', lat: 35.7356, lng: 139.6517, hasSubAreas: false },
        { name: '板橋区', area: '板橋区', lat: 35.7514, lng: 139.7095, hasSubAreas: false },
        { name: '北区', area: '北区', lat: 35.7528, lng: 139.7336, hasSubAreas: false },
        { name: '足立区', area: '足立区', lat: 35.7756, lng: 139.8047, hasSubAreas: false },
        { name: '葛飾区', area: '葛飾区', lat: 35.7434, lng: 139.8471, hasSubAreas: false },
        { name: '江戸川区', area: '江戸川区', lat: 35.7067, lng: 139.8683, hasSubAreas: false },
        { name: '墨田区', area: '墨田区', lat: 35.7106, lng: 139.8015, hasSubAreas: false },
        { name: '台東区', area: '台東区', lat: 35.7126, lng: 139.7802, hasSubAreas: false },
        { name: '中央区', area: '中央区', lat: 35.6719, lng: 139.7659, hasSubAreas: false },
        { name: '千代田区', area: '千代田区', lat: 35.6940, lng: 139.7536, hasSubAreas: false },
        { name: '文京区', area: '文京区', lat: 35.7078, lng: 139.7523, hasSubAreas: false },
        { name: '豊島区', area: '豊島区', lat: 35.7262, lng: 139.7158, hasSubAreas: false },
        { name: '荒川区', area: '荒川区', lat: 35.7364, lng: 139.7833, hasSubAreas: false },
        { name: '八王子市', area: '八王子市', lat: 35.6558, lng: 139.3439, hasSubAreas: false },
        { name: '立川市', area: '立川市', lat: 35.6938, lng: 139.4133, hasSubAreas: false },
        { name: '武蔵野市', area: '武蔵野市', lat: 35.7177, lng: 139.5663, hasSubAreas: false },
        { name: '三鷹市', area: '三鷹市', lat: 35.7026, lng: 139.5603, hasSubAreas: false },
        { name: '青梅市', area: '青梅市', lat: 35.7906, lng: 139.2581, hasSubAreas: false },
        { name: '奥多摩町', area: '奥多摩町', lat: 35.8097, lng: 139.1494, hasSubAreas: false }
      ],
      'kanagawa': [
        { name: '横浜市', area: '横浜市', lat: 35.4437, lng: 139.6380, hasSubAreas: false },
        { name: '川崎市', area: '川崎市', lat: 35.5309, lng: 139.7030, hasSubAreas: false },
        { name: '相模原市', area: '相模原市', lat: 35.5715, lng: 139.3735, hasSubAreas: false },
        { name: '鎌倉市', area: '鎌倉市', lat: 35.3192, lng: 139.5467, hasSubAreas: false },
        { name: '藤沢市', area: '藤沢市', lat: 35.3389, lng: 139.4874, hasSubAreas: false },
        { name: '茅ヶ崎市', area: '茅ヶ崎市', lat: 35.3274, lng: 139.4077, hasSubAreas: false },
        { name: '厚木市', area: '厚木市', lat: 35.4427, lng: 139.3781, hasSubAreas: false },
        { name: '小田原市', area: '小田原市', lat: 35.2564, lng: 139.1547, hasSubAreas: false }
      ],
      'saitama': [
        { name: 'さいたま市', area: 'さいたま市', lat: 35.8617, lng: 139.6455, hasSubAreas: false },
        { name: '川越市', area: '川越市', lat: 35.9251, lng: 139.4858, hasSubAreas: false },
        { name: '所沢市', area: '所沢市', lat: 35.7876, lng: 139.4733, hasSubAreas: false },
        { name: '越谷市', area: '越谷市', lat: 35.8886, lng: 139.7908, hasSubAreas: false },
        { name: '川口市', area: '川口市', lat: 35.8006, lng: 139.7208, hasSubAreas: false }
      ],
      'chiba': [
        { name: '千葉市', area: '千葉市', lat: 35.6074, lng: 140.1065, hasSubAreas: false },
        { name: '船橋市', area: '船橋市', lat: 35.6955, lng: 139.9826, hasSubAreas: false },
        { name: '松戸市', area: '松戸市', lat: 35.7874, lng: 139.9018, hasSubAreas: false },
        { name: '市川市', area: '市川市', lat: 35.7219, lng: 139.9317, hasSubAreas: false },
        { name: '柏市', area: '柏市', lat: 35.8617, lng: 139.9711, hasSubAreas: false }
      ],
      'ibaraki': [
        { name: '水戸市', area: '水戸市', lat: 36.3414, lng: 140.4467, hasSubAreas: false },
        { name: 'つくば市', area: 'つくば市', lat: 36.0836, lng: 140.0764, hasSubAreas: false },
        { name: '日立市', area: '日立市', lat: 36.5991, lng: 140.6517, hasSubAreas: false }
      ],
      'tochigi': [
        { name: '宇都宮市', area: '宇都宮市', lat: 36.5658, lng: 139.8836, hasSubAreas: false },
        { name: '足利市', area: '足利市', lat: 36.3077, lng: 139.4506, hasSubAreas: false },
        { name: '栃木市', area: '栃木市', lat: 36.3143, lng: 139.5783, hasSubAreas: false }
      ],
      'gunma': [
        { name: '前橋市', area: '前橋市', lat: 36.3911, lng: 139.0608, hasSubAreas: false },
        { name: '高崎市', area: '高崎市', lat: 36.3227, lng: 139.0124, hasSubAreas: false },
        { name: '太田市', area: '太田市', lat: 36.2943, lng: 139.3786, hasSubAreas: false }
      ],
      'yamanashi': [
        { name: '甲府市', area: '甲府市', lat: 35.6636, lng: 138.5684, hasSubAreas: false },
        { name: '富士吉田市', area: '富士吉田市', lat: 35.4928, lng: 138.8070, hasSubAreas: false }
      ]
    };

    // イベント数をカウントする関数（地名とイベントを正確に紐づける）
    async function countEventsByArea(area) {
      let source = Array.isArray(window.eventIndex) && window.eventIndex.length > 0
        ? window.eventIndex
        : (Array.isArray(window.eventData?.events) ? window.eventData.events : []);
      
      if (source.length === 0) return 0;
      
      const count = source.filter(event => {
        const eventArea = (event.area || event.city || event.prefecture || '').trim();
        const searchArea = area.trim();
        
        if (!eventArea || !searchArea) return false;
        
        // 完全一致を最優先
        if (eventArea === searchArea) return true;
        
        // 部分一致のチェック（より厳密に）
        // 「世田谷区」で検索する場合、「世田谷区 世田谷」は除外
        if (eventArea.includes(searchArea)) {
          // 都道府県名（「都」「府」「県」で終わる）の場合は部分一致も許可
          if (searchArea.endsWith('都') || searchArea.endsWith('府') || searchArea.endsWith('県')) {
            return true;
          }
          
          // 市区町村名（「区」「市」「町」「村」で終わる）の場合は厳密にチェック
          if (searchArea.endsWith('区') || searchArea.endsWith('市') || searchArea.endsWith('町') || searchArea.endsWith('村')) {
            // 「世田谷区」で始まる場合は一致（「世田谷区 世田谷」は除外）
            if (eventArea.startsWith(searchArea)) {
              // スペースやその他の文字が続く場合は除外
              const nextChar = eventArea[searchArea.length];
              if (!nextChar || nextChar === ' ' || nextChar === '　') {
                return true;
              }
            }
            // 「世田谷区」を含むが、前に文字がある場合は除外（例：「東京都世田谷区」は「世田谷区」に一致）
            const index = eventArea.indexOf(searchArea);
            if (index > 0) {
              const beforeChar = eventArea[index - 1];
              // 前の文字が都道府県名の一部でない場合は一致
              if (beforeChar !== '都' && beforeChar !== '府' && beforeChar !== '県') {
                return false;
              }
            }
            return false;
          }
          
          // その他の場合は部分一致を許可
          return true;
        }
        
        return false;
      }).length;
      
      return count;
    }
    
    // マーカーの位置を調整して重複を防ぐ関数
    function adjustMarkerPositions(markers, minDistance = 0.01) {
      if (!markers || markers.length === 0) return;
      
      // 距離が近いマーカーを検出して位置を調整
      for (let i = 0; i < markers.length; i++) {
        for (let j = i + 1; j < markers.length; j++) {
          try {
            const pos1 = markers[i].getPosition();
            const pos2 = markers[j].getPosition();
            
            if (!pos1 || !pos2) continue;
            
            const lat1 = pos1.lat();
            const lng1 = pos1.lng();
            const lat2 = pos2.lat();
            const lng2 = pos2.lng();
            
            const latDiff = Math.abs(lat1 - lat2);
            const lngDiff = Math.abs(lng1 - lng2);
            const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
            
            // 距離が近すぎる場合、位置を調整
            if (distance < minDistance) {
              // 2つのマーカーを対角線上に少しずらす
              const offset = (minDistance - distance) / 2 + 0.001;
              const angle = Math.atan2(lat2 - lat1, lng2 - lng1);
              
              // マーカー1を左上に、マーカー2を右下にずらす
              const newLat1 = lat1 - Math.sin(angle) * offset;
              const newLng1 = lng1 - Math.cos(angle) * offset;
              const newLat2 = lat2 + Math.sin(angle) * offset;
              const newLng2 = lng2 + Math.cos(angle) * offset;
              
              markers[i].setPosition({ lat: newLat1, lng: newLng1 });
              markers[j].setPosition({ lat: newLat2, lng: newLng2 });
            }
          } catch (e) {
            console.warn('[adjustMarkerPositions] Error adjusting marker position:', e);
          }
        }
      }
    }

    // 地図から探す機能の初期化
    function initMapSearch() {

      const initMap = () => {
        if (document.readyState === 'loading') {
          window.addEventListener('DOMContentLoaded', () => {
            createKantoSVGMap();
          });
        } else {
          createKantoSVGMap();
        }
      };

      initMap();

    }
    
    // TopoJSONデータの自動フォールバック関数（createKantoSVGMapより前に定義）
    async function loadTopoJson(primaryUrl, fallbackUrl) {
      try {
        const r = await fetch(primaryUrl, { cache: "no-store" });
        if (!r.ok) throw new Error(`primary fetch failed: ${r.status}`);
        return await r.json();
      } catch (e) {
        console.warn("[Topo] primary failed -> fallback", e);
        const r2 = await fetch(fallbackUrl, { cache: "no-store" });
        if (!r2.ok) throw new Error(`fallback fetch failed: ${r2.status}`);
        return await r2.json();
      }
    }
    
    // 二重実行防止のガード
    let kantoMapRendered = false;
    let kantoMapData = null;
    let prefLayerPaths = null;
    let labelLayerTexts = null;
    
    // 地図以外のSVG生成を一時停止するフラグ（地図だけに集中するため）
    const DISABLE_OTHER_SVG_GENERATION = true;
    
    // ★離島除外処理（本土だけを表示するため）
    // 本土（関東周辺）の範囲を厳しめに：伊豆諸島を落としやすい
    const TOKYO_MAINLAND_BBOX = [[138.6, 35.2], [140.4, 36.2]];

    const AREAKEY_TO_PREF = {
      tokyo: "東京都",
      kanagawa: "神奈川県",
      chiba: "千葉県",
      saitama: "埼玉県",
      ibaraki: "茨城県",
      tochigi: "栃木県",
      gunma: "群馬県",
      yamanashi: "山梨県"
    };

    const PREFECTURE_SHORT_MAP = {
      東京: "東京都",
      神奈川: "神奈川県",
      千葉: "千葉県",
      埼玉: "埼玉県",
      茨城: "茨城県",
      栃木: "栃木県",
      群馬: "群馬県",
      山梨: "山梨県"
    };

    const PREFECTURE_SUFFIXES = ["都", "道", "府", "県"];
    const MAP_DEFAULT_FILL = "#f6f8f7";
    const MAP_DEFAULT_STROKE = "rgba(0, 0, 0, 0.15)";
    const MAP_SELECTED_FILL = "rgba(0, 128, 96, 0.18)";
    const MAP_SELECTED_STROKE = "rgba(0, 128, 96, 0.8)";

    window.selectedPrefectures = [];
    window.selectedCategories = [];
    window.selectedTags = [];
    window.baseEvents = [];
    window.basePrefCounts = {};
    window.baseCategoryCounts = {};
    window.baseTagCounts = {};
    window.filteredEvents = [];
    window.categoryLabelMap = {};
    window.tagLabelMap = {};
    let cachedEventMeta = null;
    let metaLoadPromise = null;

    const PREF_NAMES = Object.keys(PREFECTURE_SHORT_MAP).concat(Object.values(PREFECTURE_SHORT_MAP));

    function normalizePrefectureName(value) {
      if (value === undefined || value === null) return "";
      let name = String(value).trim().replace(/[\u3000\s]+/g, "");
      if (!name) return "";
      if (PREFECTURE_SHORT_MAP[name]) {
        return PREFECTURE_SHORT_MAP[name];
      }
      for (const short of Object.keys(PREFECTURE_SHORT_MAP)) {
        if (name === short) {
          return PREFECTURE_SHORT_MAP[short];
        }
        if (name === PREFECTURE_SHORT_MAP[short]) {
          return name;
        }
      }
      const lastChar = name.slice(-1);
      if (!PREFECTURE_SUFFIXES.includes(lastChar)) {
        name = `${name}県`;
      }
      return name;
    }

    function findPrefectureInText(text) {
      if (!text || typeof text !== "string") return "";
      const normalized = text.replace(/[\u3000\s]+/g, "");
      for (const candidate of PREF_NAMES) {
        if (normalized.includes(candidate)) {
          return normalizePrefectureName(candidate);
        }
      }
      return "";
    }

    function getEventPrefecture(event) {
      if (!event || typeof event !== "object") return "";
      const directFields = [
        event.prefecture,
        event.pref,
        event.prefName,
        event.pref_name,
        event.area?.prefecture,
        event.area?.prefName,
        event.area?.pref_name,
        event.areaName,
        event.area_name,
        event.area,
        event.city,
        event.state,
        event.location?.prefecture,
        event.location?.pref,
        event.location?.address
      ];
      for (const candidate of directFields) {
        if (candidate) {
          const normalized = normalizePrefectureName(candidate);
          if (normalized) return normalized;
        }
      }
      const freeTextFields = [
        event.location?.address,
        event.location?.place,
        event.address,
        event.place,
        event.location,
        event.detail,
        event.description
      ];
      for (const field of freeTextFields) {
        const guess = findPrefectureInText(field);
        if (guess) return guess;
      }
      if (event.areaKey && AREAKEY_TO_PREF[event.areaKey]) {
        return AREAKEY_TO_PREF[event.areaKey];
      }
      return "";
    }

    function getCountsByPref(events) {
      return events.reduce((acc, event) => {
        const pref = getEventPrefecture(event);
        if (pref) {
          acc[pref] = (acc[pref] || 0) + 1;
        }
        return acc;
      }, {});
    }

    function logPrefectureCoverage() {
      const all = getAllEvents();
      if (!all.length) return;
      let okCount = 0;
      let ngCount = 0;
      const ngEvents = [];
      all.forEach(event => {
        const pref = getEventPrefecture(event);
        if (pref) {
          okCount++;
        } else {
          ngCount++;
          if (ngEvents.length < 5) ngEvents.push({
            id: event.id,
            title: event.title,
            city: event.city,
            area: event.area,
            rawPref: event.prefecture
          });
        }
      });
      console.log("[pref] total", all.length, "ok", okCount, "ng", ngCount);
      if (ngEvents.length) {
        console.table(ngEvents);
      }
    }

    const KANTO_MAP_VIEWBOX = { width: 900, height: 520 };
    const KANTO_MAP_VIEWBOX_VALUE = `0 0 ${KANTO_MAP_VIEWBOX.width} ${KANTO_MAP_VIEWBOX.height}`;

    function normalizeString(value) {
      if (value === undefined || value === null) return "";
      return String(value).trim().toLowerCase();
    }

    function normalizeCategoryId(event) {
      const rawCategory = event?.categoryId ?? event?.category?.id ?? event?.category;
      return normalizeString(rawCategory);
    }

    function extractTagIds(event) {
      const tagValues = new Set();
      if (Array.isArray(event?.tags)) {
        event.tags.forEach((tag) => {
          if (typeof tag === "string") {
            tagValues.add(tag);
          } else if (tag?.id) {
            tagValues.add(tag.id);
          } else if (tag?.name) {
            tagValues.add(tag.name);
          }
        });
      }
      if (Array.isArray(event?.tagIds)) {
        event.tagIds.forEach((tag) => {
          if (tag) tagValues.add(tag);
        });
      }
      return Array.from(tagValues)
        .map(normalizeString)
        .filter(Boolean);
    }

    function countByPref(events) {
      const result = {};
      (events || []).forEach((event) => {
        const pref = normalizePrefectureName(getEventPrefecture(event) || "");
        if (!pref) return;
        result[pref] = (result[pref] || 0) + 1;
      });
      return result;
    }

    function countByCategory(events) {
      return events.reduce((acc, event) => {
        if (!getEventPrefecture(event)) return acc;
        const normalized = normalizeCategoryId(event);
        if (!normalized) return acc;
        acc[normalized] = (acc[normalized] || 0) + 1;
        return acc;
      }, {});
    }

    function countByTag(events) {
      return events.reduce((acc, event) => {
        if (!getEventPrefecture(event)) return acc;
        extractTagIds(event).forEach((tagId) => {
          acc[tagId] = (acc[tagId] || 0) + 1;
        });
        return acc;
      }, {});
    }

    function filterEventsByPref(events, prefName) {
      const normalizedPref = normalizePrefectureName(prefName);
      if (!normalizedPref) return events;
      return events.filter(event => getEventPrefecture(event) === normalizedPref);
    }

    function getNameJa(p) {
      return p?.nam_ja || p?.name_ja || p?.NAME_JA || "";
    }

    function getPrefFillColor(d) {
      return "#f4f9f2";
    }

    // boundsが本土BBoxと交差してるか
    function ensureBaseStats() {
      if (!Array.isArray(window.baseEvents) || window.baseEvents.length === 0) {
        window.baseEvents = getAllEvents();
      }
      if (!window.baseEvents.length) return false;
      if (!window.basePrefCounts || Object.keys(window.basePrefCounts).length === 0) {
        window.basePrefCounts = countByPref(window.baseEvents);
      }
      if (!window.baseCategoryCounts || Object.keys(window.baseCategoryCounts).length === 0) {
        window.baseCategoryCounts = countByCategory(window.baseEvents);
      }
      if (!window.baseTagCounts || Object.keys(window.baseTagCounts).length === 0) {
        window.baseTagCounts = countByTag(window.baseEvents);
      }
      return true;
    }

    // boundsが本土BBoxと交差してるか
    function intersectsBbox(bounds, bbox) {
      const [[minX, minY], [maxX, maxY]] = bounds;
      const [[bx0, by0], [bx1, by1]] = bbox;
      return !(maxX < bx0 || minX > bx1 || maxY < by0 || minY > by1);
    }
    
    // 東京都の本土だけを残す（伊豆諸島・小笠原を除外）
    function keepTokyoMainland(feature) {
      if (!feature?.geometry) return feature;
      
      const g = feature.geometry;
      
      if (g.type === "Polygon") {
        const b = d3.geoBounds(feature);
        return intersectsBbox(b, TOKYO_MAINLAND_BBOX) ? feature : null;
      }
      
      if (g.type === "MultiPolygon") {
        const kept = g.coordinates.filter((polyCoords) => {
          const polyFeature = { type: "Feature", geometry: { type: "Polygon", coordinates: polyCoords } };
          const b = d3.geoBounds(polyFeature);
          return intersectsBbox(b, TOKYO_MAINLAND_BBOX);
        });
        
        if (!kept.length) return null;
        
        return {
          ...feature,
          geometry: { type: "MultiPolygon", coordinates: kept }
        };
      }
      
      return feature;
    }
    
    // 描画ロジックを分離（リサイズ時にも呼び出せるように）
    function renderKantoMap(kantoFeatures, areaKeyByName, getNameJa) {
      const svg = d3.select("#kantoMap");
      const container = document.getElementById("map-svg-container");
      if (!container) {
        console.error('[renderKantoMap] Container not found');
        return;
      }
      
      // SVGをクリア
      svg.selectAll("*").remove();
      
      const width = KANTO_MAP_VIEWBOX.width;
      const height = KANTO_MAP_VIEWBOX.height;
      
      svg
        .attr("viewBox", KANTO_MAP_VIEWBOX_VALUE)
        .attr("preserveAspectRatio", "xMidYMid slice");
      
      ensureBaseStats();
      const countsByPref = window.basePrefCounts;
      
      // ★関東だけのFeatureCollectionを作成（フィルタ後）
      const kantoGeoJson = {
        type: "FeatureCollection",
        features: kantoFeatures
      };
      
      // SVGにフィット（fitExtentで意図的な余白を入れる）
      const projection = d3.geoMercator();
      // 余白を"意図して"入れる（じゃらんはギチギチにしない）
      const pad = 12;
      projection.fitExtent(
        [[pad, pad], [width - pad, height - pad]],
        kantoGeoJson
      );
      const path = d3.geoPath().projection(projection);
      
      // 背景（白寄せ）
      svg.append("rect")
        .attr("width", width)
        .attr("height", height)
        .attr("fill", "#ffffff");
      
      // 県ポリゴン（じゃらん寄せのデザイン）
      const mapRoot = svg.append("g").attr("class", "map-root");
      const prefLayer = mapRoot.append("g").attr("class", "pref-layer");
      const getPrefFillColor = (count) => {
        if (count === 0) return "#f4f9f2";
        if (count <= 3) return "#dfece1";
        if (count <= 10) return "#c6e0c9";
        return "#add4b7";
      };

      const prefLayerPathsSelection = prefLayer.selectAll("path.pref")
        .data(kantoFeatures)
        .join("path")
          .attr("class", "pref")
          .attr("d", path)
          .attr("fill", MAP_DEFAULT_FILL)
          .attr("stroke", MAP_DEFAULT_STROKE)
          .attr("stroke-width", 1.1)
          .style("cursor", "pointer")
          .on("mouseenter", function() {
            d3.select(this).attr("stroke-width", 1.4);
          })
          .on("mouseleave", function() {
            if (!d3.select(this).classed("is-selected")) {
              d3.select(this).attr("stroke-width", 1.1);
            }
          })
          .on("click", (e, d) => {
            const name = getNameJa(d.properties);
            const normalizedPref = normalizePrefectureName(name);
            if (!normalizedPref) return;
            const baseName = name.replace("都", "").replace("県", "").replace("府", "").replace("道", "");
            const heroSearchInput = document.getElementById('search-query');
            const headerSearchInput = document.querySelector('#header-search .header-search-input');
            const currentSelection = Array.isArray(window.selectedPrefectures) ? window.selectedPrefectures : [];
            const isCurrentlySelected = currentSelection.includes(normalizedPref);
            window.selectedPrefectures = isCurrentlySelected
              ? currentSelection.filter(pref => pref !== normalizedPref)
              : [...currentSelection, normalizedPref];
            if (!isCurrentlySelected) {
              if (heroSearchInput) heroSearchInput.value = baseName;
              if (headerSearchInput) headerSearchInput.value = baseName;
            } else {
              if (heroSearchInput) heroSearchInput.value = "";
              if (headerSearchInput) headerSearchInput.value = "";
            }
            applyFiltersAndRender({ label: isCurrentlySelected ? "" : baseName });
          });

      prefLayerPaths = prefLayerPathsSelection;
      updateMapSelection();

      const labelLayer = mapRoot.selectAll("g.label-layer").data([0]).join("g").attr("class", "label-layer");
      const labels = labelLayer.selectAll("text.pref-label").data(kantoFeatures, d => getNameJa(d.properties));
      labels.exit().remove();
      const labelEnter = labels.enter().append("text").attr("class", "pref-label");
      const labelMerge = labelEnter.merge(labels);
      labelMerge
        .attr("transform", d => {
          const [x, y] = path.centroid(d);
          return `translate(${x},${y})`;
        })
        .attr("text-anchor", "middle")
        .attr("dy", "0.35em")
        .attr("pointer-events", "none")
        .text(d => {
          const name = getNameJa(d.properties);
          const baseName = name.replace("都", "").replace("県", "").replace("府", "").replace("道", "");
          const count = countsByPref?.[name] ?? 0;
          return `${baseName}（${count}）`;
        })
        .attr("fill", d => {
          const name = getNameJa(d.properties);
          const count = countsByPref?.[name] ?? 0;
          return count > 0 ? "#0f4f46" : "#9db0a3";
        });

      labelLayerTexts = labelLayer.selectAll("text.pref-label");

    }

    function updateMapSelection() {
      if (!prefLayerPaths) return;
      prefLayerPaths.each(function(d) {
        const name = getNameJa(d.properties);
        const normalizedName = normalizePrefectureName(name);
        const selectedPrefs = Array.isArray(window.selectedPrefectures) ? window.selectedPrefectures : [];
        const isActive = normalizedName && selectedPrefs.includes(normalizedName);
        const selection = d3.select(this);
        selection
          .classed("is-selected", isActive)
          .attr("fill", isActive ? MAP_SELECTED_FILL : MAP_DEFAULT_FILL)
          .attr("stroke", isActive ? MAP_SELECTED_STROKE : MAP_DEFAULT_STROKE)
          .attr("stroke-width", isActive ? 1.6 : 1.1)
          .attr("fill-opacity", isActive ? 1 : 0.75)
          .attr("stroke-opacity", isActive ? 1 : 0.65);
      });
    }

    function getDisplayPrefName(prefName) {
      if (!prefName) return "";
      if (prefName === "北海道") return prefName;
      return prefName.replace(/(都|道|府|県)$/, "");
    }

    function updateSelectedPrefectureState(filteredCount) {
      const clearBtn = document.getElementById("clearAreaBtn");
      const conditionLineEl = document.getElementById("conditionLine");
      const hasSelection = Array.isArray(window.selectedPrefectures) && window.selectedPrefectures.length > 0;
      if (conditionLineEl) {
        conditionLineEl.classList.toggle("has-selection", hasSelection);
      }
      if (clearBtn) {
        clearBtn.disabled = !hasSelection;
      }
      updateConditionLine(filteredCount);
    }
    
    // 関東地方のSVG地図を作成（TopoJSON使用）
    async function createKantoSVGMap(forceRerender = false) {
      // 二重実行防止（リサイズ時は再描画を許可）
      if (kantoMapRendered && !forceRerender) {
        console.log('[createKantoSVGMap] Already rendered, skipping...');
        return;
      }
      
      // デバッグ：SVG要素の存在確認
      const svgElement = document.getElementById("kantoMap");
      console.log('[createKantoSVGMap] SVG element:', svgElement);
      
      if (!svgElement) {
        console.error('[createKantoSVGMap] SVG element not found!');
        setTimeout(() => createKantoSVGMap(), 100);
        return;
      }
      
      // デバッグ：SVGが描画できるか確認（開発時のみ有効）
      // 本番ではコメントアウトしてください
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        svgElement.innerHTML = `<rect x="0" y="0" width="900" height="700" fill="#cfeee6"></rect>
                                 <text x="40" y="80" font-size="48" font-weight="800" fill="#143a33">
                                   SVG OK
                                 </text>`;
        console.log('[createKantoSVGMap] SVG OK test rendered');
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      // d3とtopojson-clientが読み込まれるまで待機
      if (typeof d3 === 'undefined') {
        console.warn('[createKantoSVGMap] d3 is not defined, retrying...');
        setTimeout(() => createKantoSVGMap(), 100);
        return;
      }
      
      const topojsonClient = window.topojson;
      if (!topojsonClient) {
        console.warn('[createKantoSVGMap] topojson is not defined, retrying...');
        console.warn('[createKantoSVGMap] Make sure topojson-client@3 is loaded from jsdelivr');
        setTimeout(() => createKantoSVGMap(), 100);
        return;
      }
      
      if (!topojsonClient.feature) {
        console.error('[createKantoSVGMap] topojson.feature is not available');
        console.error('[createKantoSVGMap] topojson object:', topojsonClient);
        return;
      }
      
      console.log('[createKantoSVGMap] d3 and topojson loaded');
      
      const svg = d3.select("#kantoMap");
      if (svg.empty()) {
        console.error('[createKantoSVGMap] d3.select failed!');
        setTimeout(() => createKantoSVGMap(), 100);
        return;
      }
      
      // SVGをクリア
      svg.selectAll("*").remove();
      
      // ★コンテナのサイズを動的に取得（重要！）
      const container = document.getElementById("map-svg-container");
      if (!container) {
        console.error('[createKantoSVGMap] Container not found');
        return;
      }
      
      svg
        .attr("viewBox", KANTO_MAP_VIEWBOX_VALUE)
        .attr("preserveAspectRatio", "xMidYMid slice");
      
      // 関東地方の都道府県
      const KANTO = new Set([
        "東京都", "神奈川県", "千葉県", "埼玉県", "茨城県", "栃木県", "群馬県", "山梨県"
      ]);
      
      // エリアkey対応
      const areaKeyByName = {
        "東京都": "tokyo",
        "神奈川県": "kanagawa",
        "千葉県": "chiba",
        "埼玉県": "saitama",
        "茨城県": "ibaraki",
        "栃木県": "tochigi",
        "群馬県": "gunma",
        "山梨県": "yamanashi"
      };
      
      try {
        // TopoJSONデータを取得（自動フォールバック）
        console.log('[createKantoSVGMap] Fetching TopoJSON...');
        const topo = await loadTopoJson(
          "https://raw.githubusercontent.com/dataofjapan/land/master/japan.topojson",
          "/assets/maps/japan.topojson"
        );
        console.log('[createKantoSVGMap] TopoJSON loaded:', topo);
        
        if (!topo || !topo.objects) {
          throw new Error('Invalid TopoJSON data');
        }
        
        // topojsonのobjects名を取得
        const objKey = Object.keys(topo.objects)[0];
        console.log('[createKantoSVGMap] Using object key:', objKey);
        
        // topojson-clientのfeature関数を使用（script方式で読み込まれた場合）
        const topojsonClient = window.topojson;
        if (!topojsonClient || !topojsonClient.feature) {
          throw new Error('topojson.feature is not available. Make sure topojson-client is loaded.');
        }
        
        const geo = topojsonClient.feature(topo, topo.objects[objKey]);
        console.log('[createKantoSVGMap] GeoJSON converted:', geo);
        
        // 日本語名を取得（関東判定と表示に使用）
        const getNameJa = (p) => p?.nam_ja || p?.name_ja || p?.NAME_JA || "";
        
        // 英語名を取得（必要に応じて使用）
        const getNameEn = (p) => p?.nam || p?.name || "";
        
        // デバッグ：実際のプロパティを確認
        if (geo.features && geo.features.length > 0) {
          console.log('[createKantoSVGMap] Sample props:', geo.features[0]?.properties);
          console.log('[createKantoSVGMap] First 10 ja names:', geo.features.slice(0, 10).map(f => getNameJa(f.properties)));
        }
        
        // 関東だけ抽出（日本語名で判定）+ 東京都の離島を除外
        const kantoFeaturesFiltered = geo.features
          .filter(f => KANTO.has(getNameJa(f.properties)))
          .map(f => (getNameJa(f.properties) === "東京都" ? keepTokyoMainland(f) : f))
          .filter(Boolean);
        
        // デバッグ：関東抽出の結果を確認
        console.log('[createKantoSVGMap] Total features:', geo.features.length);
        console.log('[createKantoSVGMap] Kanto features found (before filter):', geo.features.filter(f => KANTO.has(getNameJa(f.properties))).length);
        console.log('[createKantoSVGMap] Kanto features found (after filter):', kantoFeaturesFiltered.length);
        console.log('[createKantoSVGMap] Kanto names:', kantoFeaturesFiltered.map(f => getNameJa(f.properties)));
        
        // 0件の場合は警告を出して終了
        if (kantoFeaturesFiltered.length === 0) {
          console.warn('[createKantoSVGMap] No Kanto features matched. Check name mapping.');
          return;
        }
        
        // 最終的な関東FeatureCollection（離島除外済み）
        const kantoFeatures = kantoFeaturesFiltered;
        
        // 地図データを保持（リサイズ時に再描画用）
        kantoMapData = {
          kantoFeatures,
          areaKeyByName,
          getNameJa
        };
        
        // ★描画関数を呼び出し
        renderKantoMap(kantoFeatures, areaKeyByName, getNameJa);
        
        // 描画完了フラグを設定
        kantoMapRendered = true;
        console.log('[createKantoSVGMap] Map rendered successfully');
        
        
        // デバッグ：実際に描画されたpathの数を確認
        setTimeout(() => {
          const pathCount = document.querySelectorAll('#kantoMap path').length;
          console.log('[createKantoSVGMap] Path count in DOM:', pathCount);
          
          if (pathCount > 0) {
            const firstPath = document.querySelector('#kantoMap path');
            if (firstPath) {
              const computed = window.getComputedStyle(firstPath);
              console.log('[createKantoSVGMap] First path styles:', {
                fill: computed.fill,
                stroke: computed.stroke,
                opacity: computed.opacity,
                display: computed.display,
                visibility: computed.visibility
              });
            }
          }
          
          const svgRect = document.getElementById('kantoMap')?.getBoundingClientRect();
          console.log('[createKantoSVGMap] SVG bounding rect:', svgRect);
        }, 100);
      } catch (error) {
        console.error('[createKantoSVGMap] Error loading map:', error);
        console.error('[createKantoSVGMap] Error stack:', error.stack);
        
        // フォールバック：エラーメッセージを表示（DOM APIで生成、テンプレート文字列を使わない）
        const svgElement = document.getElementById("kantoMap");
        if (svgElement) {
          const width = 900, height = 700;
          const NS = "http://www.w3.org/2000/svg";
          
          // SVGをクリア
          svgElement.innerHTML = '';
          
          // 背景
          const rect = document.createElementNS(NS, "rect");
          rect.setAttribute("x", "0");
          rect.setAttribute("y", "0");
          rect.setAttribute("width", String(width));
          rect.setAttribute("height", String(height));
          rect.setAttribute("fill", "#f0f0f0");
          svgElement.appendChild(rect);
          
          // エラーメッセージ1
          const text1 = document.createElementNS(NS, "text");
          text1.setAttribute("x", String(width / 2));
          text1.setAttribute("y", String(height / 2 - 20));
          text1.setAttribute("text-anchor", "middle");
          text1.setAttribute("font-size", "20");
          text1.setAttribute("fill", "#666");
          text1.textContent = "地図の読み込みに失敗しました";
          svgElement.appendChild(text1);
          
          // エラーメッセージ2
          const text2 = document.createElementNS(NS, "text");
          text2.setAttribute("x", String(width / 2));
          text2.setAttribute("y", String(height / 2 + 10));
          text2.setAttribute("text-anchor", "middle");
          text2.setAttribute("font-size", "14");
          text2.setAttribute("fill", "#999");
          text2.textContent = error.message || 'Unknown error';
          svgElement.appendChild(text2);
          
          // エラーメッセージ3
          const text3 = document.createElementNS(NS, "text");
          text3.setAttribute("x", String(width / 2));
          text3.setAttribute("y", String(height / 2 + 40));
          text3.setAttribute("text-anchor", "middle");
          text3.setAttribute("font-size", "12");
          text3.setAttribute("fill", "#999");
          text3.textContent = "コンソールを確認してください";
          svgElement.appendChild(text3);
        }
      }
    }
    
    // 旧Google Maps実装（削除予定、互換性のため残す）
    function createKantoMap(container) {
      // コンテナをクリア
      container.innerHTML = '';
      
      // 関東地方の中心（東京）
      const centerLat = 35.6762;
      const centerLng = 139.6503;
      
      // 地図を作成（シンプルなデザイン、ズームレベルに応じてマーカーを制御）
      let currentMarkers = [];
      const map = new google.maps.Map(container, {
        center: { lat: centerLat, lng: centerLng },
        zoom: 8,
        mapTypeControl: false,
        streetViewControl: false,
        fullscreenControl: false,
        zoomControl: true,
        disableDefaultUI: false,
        minZoom: 7,
        maxZoom: 12,
        styles: [
          {
            featureType: "poi",
            elementType: "labels",
            stylers: [{ visibility: "off" }]
          },
          {
            featureType: "transit",
            elementType: "labels",
            stylers: [{ visibility: "off" }]
          }
        ]
      });
      
      // ズームレベルに応じてマーカーを制御する関数
      const updateMarkersByZoom = () => {
        const zoom = map.getZoom();
        // ズームアウト（7-8）: 都道府県のみ表示
        // ズーム中（9-11）: 都道府県表示（現在のレベル）
        // ズームイン（12+）: 市区町村表示（将来の拡張用）
        // 現在は都道府県レベルのみなので、すべて表示
        currentMarkers.forEach(marker => {
          if (marker) {
            marker.setVisible(true);
          }
        });
      };
      
      // ズーム変更時にマーカーを更新
      map.addListener('zoom_changed', updateMarkersByZoom);
      
      // 都道府県の座標
      const prefecturePositions = {
        'tokyo': { lat: 35.6762, lng: 139.6503, name: '東京都' },
        'kanagawa': { lat: 35.4475, lng: 139.6425, name: '神奈川県' },
        'saitama': { lat: 35.8617, lng: 139.6455, name: '埼玉県' },
        'chiba': { lat: 35.6074, lng: 140.1065, name: '千葉県' },
        'ibaraki': { lat: 36.3414, lng: 140.4467, name: '茨城県' },
        'tochigi': { lat: 36.5658, lng: 139.8836, name: '栃木県' },
        'gunma': { lat: 36.3911, lng: 139.0608, name: '群馬県' },
        'yamanashi': { lat: 35.6636, lng: 138.5684, name: '山梨県' }
      };
      
      // 都道府県マーカーを追加（0イベントは非表示）
      // 地図だけに集中するため、マーカー生成を一時停止
      if (DISABLE_OTHER_SVG_GENERATION) {
        console.log('[createKantoMap] Marker generation disabled for debugging');
        return;
      }
      
      const prefectureMarkers = [];
      const markerPromises = Object.keys(prefecturePositions).map(async (prefId) => {
        const pos = prefecturePositions[prefId];
        const prefectureName = pos.name;
        const count = await countEventsByArea(prefectureName);
        
        // 0イベントの場合はマーカーを表示しない（A案：潔さは信頼）
        if (count === 0) {
          return null;
        }
        
        // カスタムマーカーアイコン（都道府県名とイベント数）
        const textLength = Math.max(prefectureName.length, 8);
        const baseWidth = 100;
        const charWidth = 10;
        const padding = 20;
        const rectWidth = Math.max(baseWidth, textLength * charWidth + padding);
        const rectHeight = 50;
        const borderRadius = 8;
        
        const svg = `
          <svg width="${rectWidth}" height="${rectHeight + 8}" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <filter id="shadow${prefId}" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                <feOffset dx="0" dy="2" result="offsetblur"/>
                <feComponentTransfer>
                  <feFuncA type="linear" slope="0.3"/>
                </feComponentTransfer>
                <feMerge>
                  <feMergeNode/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <rect x="0" y="0" rx="${borderRadius}" ry="${borderRadius}" width="${rectWidth}" height="${rectHeight}" fill="#ffffff" stroke="#0b7a5d" stroke-width="2" filter="url(#shadow${prefId})"/>
            <text x="${rectWidth / 2}" y="${rectHeight / 2 - 4}" text-anchor="middle" font-size="13" font-weight="700" fill="#0b7a5d" font-family="Arial, sans-serif">${prefectureName}</text>
            <text x="${rectWidth / 2}" y="${rectHeight / 2 + 12}" text-anchor="middle" font-size="11" font-weight="500" fill="#666666" font-family="Arial, sans-serif">${count} イベント</text>
          </svg>
        `;
        
        const markerIcon = {
          url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg),
          scaledSize: new google.maps.Size(rectWidth, rectHeight + 8),
          anchor: new google.maps.Point(rectWidth / 2, rectHeight + 8),
          origin: new google.maps.Point(0, 0)
        };
        
        const marker = new google.maps.Marker({
          position: { lat: pos.lat, lng: pos.lng },
          map: map,
          title: `${prefectureName} - ${count} イベント`,
          icon: markerIcon,
          animation: google.maps.Animation.DROP
        });
        
        // マーカークリック時の処理
        marker.addListener('click', async () => {
          const cities = prefectureCities[prefId];
          const googleMapContainer = document.getElementById('map-google-map');
          
          if (cities && cities.length > 0 && googleMapContainer) {
            // 二段階目：市区町村のGoogle Mapsを表示
            initCityMap(prefId, prefectureName, cities, googleMapContainer);
          } else {
            // 市区町村データがない場合は都道府県で検索
            window.location.href = `list.html?area=${encodeURIComponent(prefectureName)}`;
          }
        });
        
        return marker;
      });
      
      // すべてのマーカーが追加されたら位置を調整
      Promise.all(markerPromises).then(markers => {
        const validMarkers = markers.filter(m => m !== null);
        prefectureMarkers.push(...validMarkers);
        currentMarkers = validMarkers;
        // マーカーの位置を調整（都道府県レベルでは距離が十分離れているので調整不要）
        updateMarkersByZoom();
      });
    }
    
    // 市区町村のGoogle Mapsを初期化（二段階目）
    function initCityMap(prefectureId, prefectureName, cities, container) {
      // コンテナをクリア
      container.innerHTML = '';
      
      // 都道府県の中心座標を取得
      const prefecturePositions = {
        'tokyo': { lat: 35.6762, lng: 139.6503 },
        'kanagawa': { lat: 35.4475, lng: 139.6425 },
        'saitama': { lat: 35.8617, lng: 139.6455 },
        'chiba': { lat: 35.6074, lng: 140.1065 },
        'ibaraki': { lat: 36.3414, lng: 140.4467 },
        'tochigi': { lat: 36.5658, lng: 139.8836 },
        'gunma': { lat: 36.3911, lng: 139.0608 },
        'yamanashi': { lat: 35.6636, lng: 138.5684 }
      };
      
      const centerPos = prefecturePositions[prefectureId] || { lat: 35.6762, lng: 139.6503 };
      
      // 地図を作成（ズームレベルに応じてマーカーを制御）
      const map = new google.maps.Map(container, {
        center: { lat: centerPos.lat, lng: centerPos.lng },
        zoom: 10,
        mapTypeControl: false,
        streetViewControl: false,
        fullscreenControl: false,
        zoomControl: true,
        minZoom: 8,
        maxZoom: 15
      });
      
      // ズームレベルに応じてマーカーを制御する関数
      const updateMarkersByZoom = () => {
        const zoom = map.getZoom();
        // ズームアウト（8-9）: 都道府県のみ表示（この関数は市区町村マップなので適用しない）
        // ズーム中（10-12）: 市区町村表示（現在のレベル）
        // ズームイン（13+）: より詳細な表示（将来の拡張用）
      };
      
      // ズーム変更時にマーカーを更新
      map.addListener('zoom_changed', updateMarkersByZoom);
      
      // 戻るボタンを追加（具体的な文言で）
      const backButton = document.createElement('button');
      backButton.className = 'map-back-button';
      backButton.textContent = '← エリア選択に戻る';
      backButton.style.position = 'absolute';
      backButton.style.top = '10px';
      backButton.style.left = '10px';
      backButton.style.zIndex = '1000';
      backButton.onclick = () => {
        initKantoMap(container);
      };
      container.appendChild(backButton);
      
      // タイトルを追加
      const titleDiv = document.createElement('div');
      titleDiv.className = 'map-city-title';
      titleDiv.textContent = prefectureName;
      titleDiv.style.position = 'absolute';
      titleDiv.style.top = '10px';
      titleDiv.style.left = '50%';
      titleDiv.style.transform = 'translateX(-50%)';
      titleDiv.style.zIndex = '1000';
      titleDiv.style.background = '#fff';
      titleDiv.style.padding = '8px 16px';
      titleDiv.style.borderRadius = '8px';
      titleDiv.style.fontWeight = '700';
      titleDiv.style.fontSize = '1.2rem';
      titleDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
      container.appendChild(titleDiv);
      
      // 市区町村マーカーを追加
      // 地図だけに集中するため、マーカー生成を一時停止
      if (DISABLE_OTHER_SVG_GENERATION) {
        console.log('[initCityMap] Marker generation disabled for debugging');
        return;
      }
      
      const bounds = new google.maps.LatLngBounds();
      const cityMarkers = [];
      
      const cityMarkerPromises = cities.map(async (city) => {
        const count = await countEventsByArea(city.area);
        
        // 0イベントの場合はマーカーを表示しない（A案：潔さは信頼）
        if (count === 0) {
          return null;
        }
        
        let lat = city.lat || centerPos.lat;
        let lng = city.lng || centerPos.lng;
        
        bounds.extend({ lat, lng });
        
        // カスタムマーカーアイコン
        const textLength = Math.max(city.name.length, 6);
        const baseWidth = 80;
        const charWidth = 9;
        const padding = 16;
        const rectWidth = Math.max(baseWidth, textLength * charWidth + padding);
        const rectHeight = 40;
        const borderRadius = 6;
        
        const svg = `
          <svg width="${rectWidth}" height="${rectHeight + 8}" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <filter id="shadow${city.area.replace(/\s/g, '')}" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="1.5"/>
                <feOffset dx="0" dy="2" result="offsetblur"/>
                <feComponentTransfer>
                  <feFuncA type="linear" slope="0.3"/>
                </feComponentTransfer>
                <feMerge>
                  <feMergeNode/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <rect x="0" y="0" rx="${borderRadius}" ry="${borderRadius}" width="${rectWidth}" height="${rectHeight}" fill="#ffffff" stroke="#0b7a5d" stroke-width="2" filter="url(#shadow${city.area.replace(/\s/g, '')})"/>
            <text x="${rectWidth / 2}" y="${rectHeight / 2 - 2}" text-anchor="middle" font-size="12" font-weight="700" fill="#0b7a5d" font-family="Arial, sans-serif">${city.name}</text>
            <text x="${rectWidth / 2}" y="${rectHeight / 2 + 10}" text-anchor="middle" font-size="10" font-weight="500" fill="#666666" font-family="Arial, sans-serif">${count} イベント</text>
          </svg>
        `;
        
        const markerIcon = {
          url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg),
          scaledSize: new google.maps.Size(rectWidth, rectHeight + 8),
          anchor: new google.maps.Point(rectWidth / 2, rectHeight + 8),
          origin: new google.maps.Point(0, 0)
        };
        
        const marker = new google.maps.Marker({
          position: { lat, lng },
          map: map,
          title: `${city.name} - ${count} イベント`,
          icon: markerIcon,
          animation: google.maps.Animation.DROP
        });
        
        // マーカークリック時の処理
        marker.addListener('click', async () => {
          // イベント数が多い場合（10件以上）は三段階目を表示
          if (count >= 10 && city.hasSubAreas) {
            // 三段階目：さらに細かいエリアを表示
            initSubAreaMap(city, container, map);
          } else {
            // イベント一覧ページに遷移（地名とイベントを正確に紐づける）
            window.location.href = `list.html?area=${encodeURIComponent(city.area)}`;
          }
        });
        
        return { marker, lat, lng };
      });
      
      // すべてのマーカーが追加されたら位置を調整
      Promise.all(cityMarkerPromises).then(markerData => {
        const validMarkerData = markerData.filter(m => m !== null);
        validMarkerData.forEach(({ marker }) => {
          cityMarkers.push(marker);
        });
        
        // マーカーの位置を調整して重複を防ぐ
        if (cityMarkers.length > 0) {
          setTimeout(() => {
            adjustMarkerPositions(cityMarkers, 0.008); // 市区町村レベルでは0.008度（約800m）以上離す
          }, 100);
          
          // すべてのマーカーが表示されるように地図を調整
          map.fitBounds(bounds);
        }
      });
    }
    
    // 三段階目：細かいエリアのGoogle Maps（イベントが多い場合）
    function initSubAreaMap(city, container, parentMap) {
      // 世田谷区の例：さらに細かいエリア
      if (city.area === '世田谷区') {
        const subAreas = [
          { name: '世田谷', area: '世田谷区 世田谷', lat: 35.6466, lng: 139.6533 },
          { name: '下北沢', area: '世田谷区 下北沢', lat: 35.6616, lng: 139.6669 },
          { name: '三軒茶屋', area: '世田谷区 三軒茶屋', lat: 35.6431, lng: 139.6703 },
          { name: '経堂', area: '世田谷区 経堂', lat: 35.6506, lng: 139.6286 },
          { name: '成城', area: '世田谷区 成城', lat: 35.6386, lng: 139.6069 }
        ];
        
        // 親マップを非表示にして、新しい地図を作成
        const subMapContainer = document.createElement('div');
        subMapContainer.className = 'map-google-map';
        subMapContainer.style.width = '100%';
        subMapContainer.style.height = '100%';
        subMapContainer.style.position = 'absolute';
        subMapContainer.style.top = '0';
        subMapContainer.style.left = '0';
        container.appendChild(subMapContainer);
        
        const subMap = new google.maps.Map(subMapContainer, {
          center: { lat: 35.6466, lng: 139.6533 },
          zoom: 13,
          mapTypeControl: false,
          streetViewControl: false,
          fullscreenControl: false,
          zoomControl: true
        });
        
        // 戻るボタン
        const backButton = document.createElement('button');
        backButton.className = 'map-back-button';
        backButton.textContent = '← 戻る';
        backButton.style.position = 'absolute';
        backButton.style.top = '10px';
        backButton.style.left = '10px';
        backButton.style.zIndex = '1000';
        backButton.onclick = () => {
          subMapContainer.remove();
          backButton.remove();
          titleDiv.remove();
        };
        container.appendChild(backButton);
        
        // タイトル
        const titleDiv = document.createElement('div');
        titleDiv.className = 'map-city-title';
        titleDiv.textContent = city.name;
        titleDiv.style.position = 'absolute';
        titleDiv.style.top = '10px';
        titleDiv.style.left = '50%';
        titleDiv.style.transform = 'translateX(-50%)';
        titleDiv.style.zIndex = '1000';
        titleDiv.style.background = '#fff';
        titleDiv.style.padding = '8px 16px';
        titleDiv.style.borderRadius = '8px';
        titleDiv.style.fontWeight = '700';
        titleDiv.style.fontSize = '1.2rem';
        titleDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
        container.appendChild(titleDiv);
        
        // 細かいエリアのマーカーを追加
        subAreas.forEach(async (subArea) => {
          const count = await countEventsByArea(subArea.area);
          
          const textLength = Math.max(subArea.name.length, 4);
          const baseWidth = 60;
          const charWidth = 8;
          const padding = 12;
          const rectWidth = Math.max(baseWidth, textLength * charWidth + padding);
          const rectHeight = 32;
          const borderRadius = 6;
          
          const svg = `
            <svg width="${rectWidth}" height="${rectHeight + 6}" xmlns="http://www.w3.org/2000/svg">
              <rect x="0" y="0" rx="${borderRadius}" ry="${borderRadius}" width="${rectWidth}" height="${rectHeight}" fill="#ffffff" stroke="#0b7a5d" stroke-width="1.5"/>
              <text x="${rectWidth / 2}" y="${rectHeight / 2 + 4}" text-anchor="middle" font-size="11" font-weight="600" fill="#0b7a5d" font-family="Arial, sans-serif">${subArea.name}</text>
            </svg>
          `;
          
          const markerIcon = {
            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg),
            scaledSize: new google.maps.Size(rectWidth, rectHeight + 6),
            anchor: new google.maps.Point(rectWidth / 2, rectHeight + 6),
            origin: new google.maps.Point(0, 0)
          };
          
          const marker = new google.maps.Marker({
            position: { lat: subArea.lat, lng: subArea.lng },
            map: subMap,
            title: `${subArea.name} - ${count} イベント`,
            icon: markerIcon
          });
          
          marker.addListener('click', () => {
            window.location.href = `list.html?area=${encodeURIComponent(subArea.area)}`;
          });
        });
      } else {
        // 三段階目がない場合は直接イベント一覧ページに遷移
        window.location.href = `list.html?area=${encodeURIComponent(city.area)}`;
      }
    }

    // 近くのイベントを表示するGoogle Mapsの初期化
    function initNearbyMap(userLat, userLng, container) {
      // Google Maps APIが読み込まれているか確認
      if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
        // Google Maps APIを読み込む
        if (!document.querySelector('script[src*="maps.googleapis.com"]')) {
          const script = document.createElement('script');
          script.src = `https://maps.googleapis.com/maps/api/js?key=${window.GOOGLE_MAPS_API_KEY}&callback=initNearbyMapCallback&language=ja&region=JP&loading=async`;
          script.async = true;
          script.defer = true;
          window.initNearbyMapCallback = () => {
            createNearbyMap(userLat, userLng, container);
          };
          document.head.appendChild(script);
        } else {
          // 既に読み込まれている場合は直接作成
          setTimeout(() => {
            createNearbyMap(userLat, userLng, container);
          }, 500);
        }
      } else {
        createNearbyMap(userLat, userLng, container);
      }
    }
    
    // Google Mapsを作成
    function createNearbyMap(userLat, userLng, container) {
      // コンテナをクリア
      container.innerHTML = '';
      
      // 地図を作成
      const map = new google.maps.Map(container, {
        center: { lat: userLat, lng: userLng },
        zoom: 13,
        mapTypeControl: true,
        streetViewControl: false,
        fullscreenControl: true
      });
      
      // 現在地マーカーを追加
      new google.maps.Marker({
        position: { lat: userLat, lng: userLng },
        map: map,
        title: '現在地',
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 10,
          fillColor: '#4285F4',
          fillOpacity: 1,
          strokeColor: '#fff',
          strokeWeight: 3
        }
      });
      
      // イベントデータを取得
      let source = Array.isArray(window.eventIndex) && window.eventIndex.length > 0
        ? window.eventIndex
        : (Array.isArray(window.eventData?.events) ? window.eventData.events : []);
      
      if (source.length === 0) {
        console.log('[initNearbyMap] No event data available');
        return;
      }
      
      // 位置情報があるイベントをフィルタリング
      const eventsWithLocation = source.filter(event => {
        const lat = event.location?.lat;
        const lng = event.location?.lng;
        return lat && lng && !isNaN(parseFloat(lat)) && !isNaN(parseFloat(lng));
      });
      
      // 距離でソート（近い順）
      const eventsWithDistance = eventsWithLocation.map(event => {
        const eventLat = parseFloat(event.location.lat);
        const eventLng = parseFloat(event.location.lng);
        const distance = calculateDistance(userLat, userLng, eventLat, eventLng);
        return { event, distance };
      }).sort((a, b) => a.distance - b.distance);
      
      // 近くのイベント（20km以内、最大20件）をマップに表示
      const nearbyEvents = eventsWithDistance
        .filter(item => item.distance <= 20)
        .slice(0, 20);
      
      console.log('[initNearbyMap] Found', nearbyEvents.length, 'nearby events');
      
      // イベントマーカーを追加
      nearbyEvents.forEach(({ event, distance }) => {
        const lat = parseFloat(event.location.lat);
        const lng = parseFloat(event.location.lng);
        const price = event.price ? event.price : 0;
        const priceLabel = price > 0 ? `¥ ${price.toLocaleString()}` : '';
        
        // カスタムマーカーアイコン（価格表示）
        let markerIcon = null;
        if (priceLabel) {
          const textLength = priceLabel.length;
          const baseWidth = 40;
          const charWidth = 8;
          const padding = 10;
          const rectWidth = Math.max(baseWidth, textLength * charWidth + padding);
          const rectHeight = 24;
          const borderRadius = 4;
          
          const svg = `
            <svg width="${rectWidth}" height="${rectHeight + 8}" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                  <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
                  <feOffset dx="0" dy="1" result="offsetblur"/>
                  <feComponentTransfer>
                    <feFuncA type="linear" slope="0.2"/>
                  </feComponentTransfer>
                  <feMerge>
                    <feMergeNode/>
                    <feMergeNode in="SourceGraphic"/>
                  </feMerge>
                </filter>
              </defs>
              <rect x="0" y="0" rx="${borderRadius}" ry="${borderRadius}" width="${rectWidth}" height="${rectHeight}" fill="#ffffff" stroke="#cccccc" stroke-width="1" filter="url(#shadow)"/>
              <text x="${rectWidth / 2}" y="${rectHeight / 2 + 4}" text-anchor="middle" font-size="12" font-weight="600" fill="#333333" font-family="Arial, sans-serif">${priceLabel}</text>
            </svg>
          `;
          
          markerIcon = {
            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg),
            scaledSize: new google.maps.Size(rectWidth, rectHeight + 8),
            anchor: new google.maps.Point(rectWidth / 2, rectHeight + 8),
            origin: new google.maps.Point(0, 0)
          };
        }
        
        const marker = new google.maps.Marker({
          position: { lat, lng },
          map: map,
          title: `${event.title || ''} - ${distance.toFixed(1)}km`,
          icon: markerIcon,
          animation: google.maps.Animation.DROP
        });
        
        // マーカークリック時にイベント詳細ページに遷移
        marker.addListener('click', () => {
          window.location.href = `experience.html?id=${event.id}`;
        });
      });
      
      // すべてのマーカーが表示されるように地図を調整
      if (nearbyEvents.length > 0) {
        const bounds = new google.maps.LatLngBounds();
        bounds.extend({ lat: userLat, lng: userLng });
        nearbyEvents.forEach(({ event }) => {
          bounds.extend({
            lat: parseFloat(event.location.lat),
            lng: parseFloat(event.location.lng)
          });
        });
        map.fitBounds(bounds);
      }
    }

    // 位置情報を取得して近場のイベントを表示（非推奨：地図から探すに置き換え）
    async function renderLocationBasedEvents() {
      const section = document.getElementById('location-based-events');
      const container = document.getElementById('location-events-list');
      const titleEl = document.getElementById('location-events-title');
      
      if (!section || !container) {
        console.log('[renderLocationBasedEvents] Section or container not found');
        return;
      }

      // 位置情報が利用可能かチェック
      if (!navigator.geolocation) {
        console.log('[renderLocationBasedEvents] Geolocation is not supported');
        return;
      }

      // イベントデータが読み込まれるまで待機
      let source = Array.isArray(window.eventIndex) && window.eventIndex.length > 0
        ? window.eventIndex
        : (Array.isArray(window.eventData?.events) ? window.eventData.events : []);

      if (source.length === 0) {
        console.log('[renderLocationBasedEvents] No event data available yet, waiting...');
        // データが読み込まれるまで少し待つ
        setTimeout(() => renderLocationBasedEvents(), 1000);
        return;
      }

      console.log('[renderLocationBasedEvents] Event data available:', source.length, 'events');

      // 位置情報がないイベントの詳細を読み込んで位置情報を補完（より多くのイベントを補完）
      const eventsWithoutLocation = source.filter(e => !e.location || !e.location.lat || !e.location.lng);
      if (eventsWithoutLocation.length > 0) {
        console.log('[renderLocationBasedEvents] Loading location data for', eventsWithoutLocation.length, 'events');
        try {
          // より多くのイベント（50件）から位置情報を補完
          const detailPromises = eventsWithoutLocation.slice(0, 50).map(e => 
            loadEventDetail(e.id).catch(() => null)
          );
          const details = await Promise.all(detailPromises);
          const detailMap = {};
          details.forEach(d => {
            if (d && d.id && d.location && d.location.lat && d.location.lng) {
              detailMap[d.id] = d.location;
            }
          });
          
          // sourceに位置情報を補完
          source = source.map(item => {
            const location = detailMap[item.id];
            if (location) {
              return { ...item, location: location };
            }
            return item;
          });
          
          console.log('[renderLocationBasedEvents] Enriched location data for', Object.keys(detailMap).length, 'events');
        } catch (e) {
          console.warn('[renderLocationBasedEvents] Failed to enrich location data:', e);
        }
      }

      // 位置情報があるイベントを事前にフィルタリング
      const eventsWithLocation = source.filter(event => {
        if (!event.location) return false;
        
        // lat/lngを数値に変換
        const lat = parseFloat(event.location.lat);
        const lng = parseFloat(event.location.lng);
        
        return !isNaN(lat) && !isNaN(lng) && isFinite(lat) && isFinite(lng);
      });

      console.log('[renderLocationBasedEvents] Events with location:', eventsWithLocation.length);

      if (eventsWithLocation.length === 0) {
        console.log('[renderLocationBasedEvents] No events with location data');
        return;
      }

      // 位置情報から都道府県を取得する関数
      const getPrefecture = async (lat, lng) => {
        const apiKey = window.GOOGLE_MAPS_API_KEY || 'AIzaSyDNV6H5ImWmE2DhWdRYupUER85Rb8ZqmQM';
        if (!apiKey || apiKey === 'YOUR_API_KEY_HERE') {
          return null;
        }

        try {
          const response = await fetch(
            `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=${apiKey}&language=ja&region=jp`
          );
          const data = await response.json();
          
          if (data.status === 'OK' && data.results && data.results.length > 0) {
            // 結果から都道府県を取得
            for (const result of data.results) {
              const addressComponents = result.address_components || [];
              for (const component of addressComponents) {
                if (component.types.includes('administrative_area_level_1')) {
                  return component.long_name;
                }
              }
            }
          }
        } catch (error) {
          console.warn('[renderLocationBasedEvents] Failed to get prefecture:', error);
        }
        return null;
      };

      // 位置情報から地名を取得する関数
      const getLocationName = async (lat, lng) => {
        const apiKey = window.GOOGLE_MAPS_API_KEY || 'AIzaSyDNV6H5ImWmE2DhWdRYupUER85Rb8ZqmQM';
        if (!apiKey || apiKey === 'YOUR_API_KEY_HERE') {
          return null;
        }

        try {
          const response = await fetch(
            `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=${apiKey}&language=ja&region=jp`
          );
          const data = await response.json();
          
          if (data.status === 'OK' && data.results && data.results.length > 0) {
            // 結果から市区町村名を取得
            for (const result of data.results) {
              const addressComponents = result.address_components || [];
              // 市区町村を探す
              for (const component of addressComponents) {
                if (component.types.includes('locality') || component.types.includes('administrative_area_level_2')) {
                  return component.long_name;
                }
              }
              // 都道府県を探す
              for (const component of addressComponents) {
                if (component.types.includes('administrative_area_level_1')) {
                  return component.long_name;
                }
              }
            }
            // フォールバック: 最初の結果のフォーマット済み住所から市区町村を抽出
            const formattedAddress = data.results[0].formatted_address;
            if (formattedAddress) {
              // 「東京都渋谷区」のような形式から「渋谷区」を抽出
              const match = formattedAddress.match(/([都道府県])([市区町村]+)/);
              if (match && match[2]) {
                return match[2];
              }
              // 「渋谷区」のような形式を直接抽出
              const match2 = formattedAddress.match(/([^都道府県市区町村]+[市区町村])/);
              if (match2 && match2[1]) {
                return match2[1];
              }
            }
          }
        } catch (error) {
          console.warn('[renderLocationBasedEvents] Failed to get location name:', error);
        }
        return null;
      };

      // イベントの位置情報から市区町村を取得する関数（キャッシュ付き）
      const eventLocationCache = {};
      const getEventLocationName = async (lat, lng) => {
        const cacheKey = `${lat.toFixed(4)},${lng.toFixed(4)}`;
        if (eventLocationCache[cacheKey]) {
          return eventLocationCache[cacheKey];
        }

        const apiKey = window.GOOGLE_MAPS_API_KEY || 'AIzaSyDNV6H5ImWmE2DhWdRYupUER85Rb8ZqmQM';
        if (!apiKey || apiKey === 'YOUR_API_KEY_HERE') {
          return null;
        }

        try {
          const response = await fetch(
            `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=${apiKey}&language=ja&region=jp`
          );
          const data = await response.json();
          
          if (data.status === 'OK' && data.results && data.results.length > 0) {
            // 結果から市区町村名を取得
            for (const result of data.results) {
              const addressComponents = result.address_components || [];
              // 市区町村を探す
              for (const component of addressComponents) {
                if (component.types.includes('locality') || component.types.includes('administrative_area_level_2')) {
                  eventLocationCache[cacheKey] = component.long_name;
                  return component.long_name;
                }
              }
            }
          }
        } catch (error) {
          console.warn('[renderLocationBasedEvents] Failed to get event location name:', error);
        }
        eventLocationCache[cacheKey] = null;
        return null;
      };

      // 位置情報の取得許可を求める（失敗時はデフォルト位置を使用）
      const processNearbyEvents = async (userLat, userLng, isDefaultLocation = false) => {
        console.log('[renderLocationBasedEvents] Processing events for location:', userLat, userLng);

        // ユーザーの市区町村を取得
        const userLocationName = await getLocationName(userLat, userLng);
        console.log('[renderLocationBasedEvents] User location name:', userLocationName);

        // 各イベントの距離と市区町村を計算
        const eventsWithInfo = await Promise.all(
          eventsWithLocation.map(async (event) => {
            const lat = parseFloat(event.location.lat);
            const lng = parseFloat(event.location.lng);
            const distance = calculateDistance(userLat, userLng, lat, lng);
            const eventLocationName = await getEventLocationName(lat, lng);
            const isSameLocation = userLocationName && eventLocationName && 
                                   userLocationName === eventLocationName;
            return { event, distance, isSameLocation };
          })
        );

        // ソート：同じ市区町村のイベントを優先、その後距離順
        const nearbyEvents = eventsWithInfo
          .sort((a, b) => {
            // 同じ市区町村のイベントを優先
            if (a.isSameLocation && !b.isSameLocation) return -1;
            if (!a.isSameLocation && b.isSameLocation) return 1;
            // 同じ条件なら距離順
            return a.distance - b.distance;
          })
          .slice(0, 8)
          .map(item => item.event);

        console.log('[renderLocationBasedEvents] Nearby events:', nearbyEvents.length);
        if (nearbyEvents.length > 0) {
          const firstEventInfo = eventsWithInfo.find(e => e.event.id === nearbyEvents[0].id);
          console.log('[renderLocationBasedEvents] First nearby event:', nearbyEvents[0].title, 
            'distance:', firstEventInfo ? firstEventInfo.distance.toFixed(2) + 'km' : 'unknown',
            'same location:', firstEventInfo ? firstEventInfo.isSameLocation : false);
        }

        if (nearbyEvents.length > 0) {
          // セクションを表示
          section.style.display = 'block';
          
          // 地名を取得してタイトルを更新
          let locationName = null;
          if (isDefaultLocation) {
            // デフォルト位置（世田谷区）の場合も地名を取得
            locationName = await getLocationName(userLat, userLng);
            if (!locationName) {
              locationName = '世田谷区'; // フォールバック
            }
          } else {
            locationName = await getLocationName(userLat, userLng);
          }
          
          if (titleEl) {
            if (locationName) {
              titleEl.textContent = `${locationName}のおすすめイベント`;
            } else {
              titleEl.textContent = '近くのおすすめイベント';
            }
          }

            // カルーセル表示で表示（CardRendererが読み込まれるまで待機）
            if (typeof CardRenderer !== 'undefined' && CardRenderer.renderCarousel) {
              CardRenderer.renderCarousel(nearbyEvents, 'location-events-list');
              console.log('[renderLocationBasedEvents] Events rendered successfully');
            } else {
              console.warn('[renderLocationBasedEvents] CardRenderer not loaded yet, waiting...');
              // CardRendererが読み込まれるまで待機してリトライ
              let retryCount = 0;
              const maxRetries = 10;
              const retryInterval = setInterval(() => {
                retryCount++;
                if (typeof CardRenderer !== 'undefined' && CardRenderer.renderCarousel) {
                  CardRenderer.renderCarousel(nearbyEvents, 'location-events-list');
                  console.log('[renderLocationBasedEvents] Events rendered successfully (retry ' + retryCount + ')');
                  clearInterval(retryInterval);
                } else if (retryCount >= maxRetries) {
                  console.error('[renderLocationBasedEvents] CardRenderer is still not available after retries');
                  clearInterval(retryInterval);
                }
              }, 200);
            }
        }
      };

      // 位置情報の取得を試みる
      navigator.geolocation.getCurrentPosition(
        async (position) => {
          const userLat = position.coords.latitude;
          const userLng = position.coords.longitude;
          
          // 都道府県を取得して関東かどうか判定
          const prefecture = await getPrefecture(userLat, userLng);
          const kantoPrefectures = ['東京都', '神奈川県', '千葉県', '埼玉県', '群馬県', '栃木県', '茨城県'];
          const isKanto = prefecture && kantoPrefectures.includes(prefecture);
          
          if (isKanto) {
            // 関東の場合は取得した位置情報を使用
            await processNearbyEvents(userLat, userLng, false);
          } else {
            // 関東以外の場合は世田谷区を使用
            console.log('[renderLocationBasedEvents] Not in Kanto region, using Setagaya as default');
            const defaultLat = 35.6466; // 世田谷区の緯度
            const defaultLng = 139.6533; // 世田谷区の経度
            await processNearbyEvents(defaultLat, defaultLng, true);
          }
        },
        async (error) => {
          console.log('[renderLocationBasedEvents] Geolocation error:', error.code, error.message);
          // エラー時はデフォルト位置（世田谷区）を使用して近くのイベントを表示
          console.log('[renderLocationBasedEvents] Using default location (Setagaya)');
          const defaultLat = 35.6466; // 世田谷区の緯度
          const defaultLng = 139.6533; // 世田谷区の経度
          await processNearbyEvents(defaultLat, defaultLng, true);
        },
        {
          enableHighAccuracy: true, // GPSを使用してより正確な位置情報を取得
          timeout: 20000, // タイムアウトを20秒に延長（GPS取得に時間がかかる場合があるため）
          maximumAge: 0 // キャッシュを使わず、常に最新の位置情報を取得
        }
      );
    }

    // イベントブロックの表示（events_index ベース）
    async function renderEventBlocks(sourceEvents = null) {
      const MAX_HOME_EVENTS = 8;
      
      // eventIndex を優先、なければ eventData.events から構築
      let source = Array.isArray(sourceEvents) && sourceEvents.length > 0
        ? sourceEvents
        : (Array.isArray(window.eventIndex) && window.eventIndex.length > 0
          ? window.eventIndex
          : (Array.isArray(window.eventData?.events) ? window.eventData.events : []));
      
      // next_date が無い場合、最初の数件の詳細JSONから日付を補完
      if (source.length > 0 && !source[0].next_date && !source[0].date_min && (!source[0].dates || source[0].dates.length === 0)) {
        console.log('[renderEventBlocks] next_date not found, enriching from detail JSONs...');
        try {
          const sampleIds = source.slice(0, 20).map(e => e.id).filter(Boolean);
          const detailPromises = sampleIds.map(id => 
            loadEventDetail(id).catch(() => null)
          );
          const details = await Promise.all(detailPromises);
          const detailMap = {};
          details.forEach(d => {
            if (d && d.id) detailMap[d.id] = d;
          });
          
          // source に dates を補完
          source = source.map(item => {
            const detail = detailMap[item.id];
            if (detail && detail.dates && Array.isArray(detail.dates) && detail.dates.length > 0) {
              return { ...item, dates: detail.dates, next_date: detail.dates[0].date };
            }
            return item;
          });
        } catch (e) {
          console.warn('[renderEventBlocks] Failed to enrich dates:', e);
        }
      }

      console.log('[renderEventBlocks] source length:', source.length);
      if (source.length > 0) {
        console.log('[renderEventBlocks] sample event:', source[0]);
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // おすすめ：isRecommended でフィルタ
      const recommended = source
        .filter(e => e.isRecommended)
        .slice(0, MAX_HOME_EVENTS);

      // 新着：isNew でフィルタ（publishedAt があればそれでソート、なければそのまま）
      const newEvents = source
        .filter(e => e.isNew)
        .sort((a, b) => {
          const aDate = a.publishedAt ? new Date(a.publishedAt) : new Date(0);
          const bDate = b.publishedAt ? new Date(b.publishedAt) : new Date(0);
          return bDate - aDate; // 新しい順
        })
        .slice(0, MAX_HOME_EVENTS);

      // 直近開催：source（eventIndex、日付補完済み）から、今日以降のイベントを日付の近い順にソート
      console.log('[renderEventBlocks] source for upcoming:', source.length);
      if (source.length > 0) {
        console.log('[renderEventBlocks] first event:', source[0]);
        console.log('[renderEventBlocks] first event dates:', source[0].dates);
        console.log('[renderEventBlocks] first event next_date:', source[0].next_date);
      }
      console.log('[renderEventBlocks] today:', today.toISOString().split('T')[0]);
      
      // dates または next_date から日付を取得するヘルパー
      const getEventDate = (event) => {
        // dates 配列から取得（優先）
        if (event.dates && event.dates.length > 0 && event.dates[0] && event.dates[0].date) {
          const d = new Date(event.dates[0].date);
          if (!isNaN(d.getTime())) {
            return d;
          }
        }
        // next_date から取得（フォールバック）
        if (event.next_date) {
          const d = new Date(event.next_date);
          if (!isNaN(d.getTime())) {
            return d;
          }
        }
        // date_min から取得（フォールバック）
        if (event.date_min) {
          const d = new Date(event.date_min);
          if (!isNaN(d.getTime())) {
            return d;
          }
        }
        return null;
      };
      
      const upcomingCandidatesWithDates = source.map(event => {
        const eventDate = getEventDate(event);
        return { event, eventDate };
      });
      
      console.log('[renderEventBlocks] events with valid dates:', 
        upcomingCandidatesWithDates.filter(({ eventDate }) => eventDate !== null).length
      );
      
      const upcomingCandidates = upcomingCandidatesWithDates
        .filter(({ event, eventDate }) => {
          if (!eventDate || isNaN(eventDate.getTime())) {
            console.log('[renderEventBlocks] rejected (no date):', event.id);
            return false;
          }
          const eventDateOnly = new Date(eventDate);
          eventDateOnly.setHours(0, 0, 0, 0);
          const isUpcoming = eventDateOnly >= today;
          if (!isUpcoming) {
            console.log('[renderEventBlocks] rejected (past date):', event.id, eventDateOnly.toISOString().split('T')[0], 'today:', today.toISOString().split('T')[0]);
          }
          return isUpcoming;
        });
      
      console.log('[renderEventBlocks] upcomingCandidates:', upcomingCandidates.length);
      upcomingCandidates.forEach(({ event, eventDate }) => {
        console.log('[renderEventBlocks] upcoming:', event.id, event.title, eventDate.toISOString().split('T')[0]);
      });
      
      const upcoming = upcomingCandidates
        .sort((a, b) => a.eventDate - b.eventDate) // 日付の近い順（早い順）
        .slice(0, MAX_HOME_EVENTS)
        .map(({ event }) => event); // event オブジェクトのみを返す
      
      console.log('[renderEventBlocks] final upcoming count:', upcoming.length);

      // CardRendererが定義されているか確認（読み込まれるまで待機）
      if (typeof CardRenderer === 'undefined' || !CardRenderer.renderCarousel) {
        console.warn('[renderEventBlocks] CardRenderer not loaded yet, waiting...');
        // CardRendererが読み込まれるまで待機してリトライ
        setTimeout(() => renderEventBlocks(), 100);
        return;
      }

      CardRenderer.renderCarousel(recommended, 'recommended-events');
      CardRenderer.renderCarousel(newEvents, 'new-events');
      CardRenderer.renderCarousel(upcoming, 'upcoming-events');
    }

    // カルーセルスクロール
    function scrollCarousel(carouselId, direction) {
      const carousel = document.getElementById(carouselId);
      if (!carousel) return;
      
      const scrollAmount = 400;
      const currentScroll = carousel.scrollLeft;
      const newScroll = direction === 'right' 
        ? currentScroll + scrollAmount 
        : currentScroll - scrollAmount;
      
      carousel.scrollTo({
        left: newScroll,
        behavior: 'smooth'
      });
    }

    // ヒーロー背景画像の自動切り替え（滑らかなフェード）
    function setupHeroBackground() {
      // Cloudinaryからヒーロー画像URLを取得
      const heroImages = [];
      if (typeof window.getHeroImageUrl === 'function') {
        heroImages.push(window.getHeroImageUrl('winter_ctfkee'));
        heroImages.push(window.getHeroImageUrl('fuji_ebl1nh'));
      } else {
        // フォールバック（Cloudinary関数が利用できない場合） - 空の配列にする
        console.warn('[setupHeroBackground] getHeroImageUrl is not available');
      }

      // 画像を事前に読み込む
      heroImages.forEach(src => {
        const img = new Image();
        img.src = src;
      });

      const bg1 = document.getElementById('hero-bg-1');
      const bg2 = document.getElementById('hero-bg-2');
      if (!bg1 || !bg2) return;

      // 背景画像を設定
      if (heroImages[0]) {
        bg1.style.backgroundImage = `url('${heroImages[0]}')`;
      }
      if (heroImages[1]) {
        bg2.style.backgroundImage = `url('${heroImages[1]}')`;
      }

      let currentBg = bg1;
      let nextBg = bg2;

      function changeBackground() {
        // 次の画像を表示
        nextBg.classList.add('active');
        currentBg.classList.remove('active');
        
        // 次の切り替えのために入れ替え
        const temp = currentBg;
        currentBg = nextBg;
        nextBg = temp;
      }

      // 5秒ごとに切り替え
      setInterval(changeBackground, 5000);
    }

    function renderMetaChips(forceReload = false) {
      const categoryChips = document.getElementById("categoryChips");
      if (!ensureBaseStats()) return;

      const categoryCounts = window.baseCategoryCounts;

      const renderChips = (container, items, fallback, counts, activeFilters) => {
        if (!container) return;
        container.innerHTML = "";
        const sources = items && items.length ? items : fallback;
        const availableCounts = counts || {};
        sources.forEach((item) => {
          const displayName = (item?.label || item?.name || item?.title || item?.text || (typeof item === "string" ? item : item?.id) || "no-title");
          const filterValue = item?.id ?? item?.value ?? item?.name ?? item?.label ?? item;
          const normalizedPayload = normalizeString(filterValue);
          const chipCount = normalizedPayload ? (availableCounts[normalizedPayload] ?? 0) : 0;
          if (chipCount === 0) return;
          const chip = document.createElement("button");
          chip.type = "button";
          chip.className = "chip";
          chip.dataset.key = normalizedPayload || "";

          const textSpan = document.createElement("span");
          textSpan.className = "chip__text";
          textSpan.textContent = displayName;

          const countSpan = document.createElement("span");
          countSpan.className = "chip__count";
          countSpan.textContent = chipCount.toLocaleString();

          chip.appendChild(textSpan);
          chip.appendChild(countSpan);

          const isActive = normalizedPayload && activeFilters.includes(normalizedPayload);
          chip.classList.toggle("is-selected", isActive);
          const shouldDisable = !isActive && chipCount === 0;
          chip.classList.toggle("is-zero", shouldDisable);
          chip.disabled = shouldDisable;

          if (normalizedPayload) {
            window.categoryLabelMap[normalizedPayload] = displayName;
          }

          if (!shouldDisable) {
            chip.addEventListener("click", () => {
              if (!normalizedPayload) return;
              handleCategoryToggle(normalizedPayload, displayName, isActive);
            });
          }

          container.appendChild(chip);
        });
      };

      const renderWithMeta = (metaCategories = []) => {
        renderChips(categoryChips, metaCategories, [], categoryCounts, window.selectedCategories);
      };

      if (!forceReload && cachedEventMeta) {
        renderWithMeta(cachedEventMeta.categories || []);
        return;
      }

      if (typeof window.loadEventMeta === "function") {
        renderWithMeta([]);
        if (!metaLoadPromise) {
          metaLoadPromise = window.loadEventMeta()
            .then((meta) => {
              cachedEventMeta = meta || {};
              metaLoadPromise = null;
              renderWithMeta(cachedEventMeta.categories || []);
              return meta;
            })
            .catch(() => {
              metaLoadPromise = null;
              renderWithMeta([]);
              return null;
            });
        } else {
          metaLoadPromise
            .then((meta) => {
              renderWithMeta(meta?.categories || []);
            })
            .catch(() => {
              renderWithMeta([]);
            });
        }
        return;
      }

      renderWithMeta([]);
    }

    function getAllEvents() {
      if (Array.isArray(window.eventData?.events) && window.eventData.events.length > 0) {
        return window.eventData.events;
      }
      if (Array.isArray(window.eventIndex) && window.eventIndex.length > 0) {
        return window.eventIndex;
      }
      return [];
    }

    function filterEvents(allEvents, filters = {}) {
      const {
        categories = [],
        tags = [],
        prefectures = []
      } = filters;
      const normalizedPrefectures = Array.isArray(prefectures)
        ? prefectures.map(normalizePrefectureName).filter(Boolean)
        : (prefectures ? [normalizePrefectureName(prefectures)].filter(Boolean) : []);
      return allEvents.filter((event) => {
        if (normalizedPrefectures.length) {
          const eventPref = normalizePrefectureName(getEventPrefecture(event));
          if (!eventPref || !normalizedPrefectures.includes(eventPref)) {
            return false;
          }
        }
        const categoryId = event?.categoryId || event?.category?.id || event?.category;
        if (categories.length) {
          const normalizedCategory = categoryId !== undefined ? String(categoryId).toLowerCase() : null;
          const matchesCategory = categories.some(cat => normalizedCategory === String(cat).toLowerCase());
          if (!matchesCategory) return false;
        }
        if (tags.length) {
          const eventTags = [];
          if (Array.isArray(event?.tags)) {
            event.tags.forEach((tag) => {
              if (typeof tag === "string") {
                eventTags.push(tag);
              } else if (tag?.id) {
                eventTags.push(tag.id);
              } else if (tag?.name) {
                eventTags.push(tag.name);
              }
            });

          }
          if (Array.isArray(event?.tagIds)) {
            event.tagIds.forEach(tag => eventTags.push(tag));
          }
          const normalizedTags = eventTags.map(tag => String(tag).toLowerCase());
          const matchesTag = tags.some(tagFilter => normalizedTags.includes(String(tagFilter).toLowerCase()));
          if (!matchesTag) return false;
        }
        return true;
      });
    }

    function getCurrentKeyword() {
      const hero = document.getElementById('search-query');
      const header = document.querySelector('#header-search .header-search-input');
      const keyword = (hero?.value || header?.value || "").trim();
      return keyword;
    }

    function buildConditionSentence(filteredCount) {
      const segments = [];
      const prefs = Array.isArray(window.selectedPrefectures) ? window.selectedPrefectures : [];
      if (prefs.length) {
        const prefLabels = prefs
          .map(pref => getDisplayPrefName(pref))
          .filter(Boolean);
        if (prefLabels.length) {
          segments.push(prefLabels.join('・'));
        }
      }
      const categoryLabels = window.selectedCategories
        .map(cat => window.categoryLabelMap[cat] || cat)
        .filter(Boolean);
      if (categoryLabels.length) {
        segments.push(categoryLabels.join('・'));
      }
      const tagLabels = window.selectedTags
        .map(tag => window.tagLabelMap[tag] || tag)
        .filter(Boolean);
      if (tagLabels.length) {
        segments.push(tagLabels.join('・'));
      }

      const keyword = getCurrentKeyword();
      if (keyword) {
        segments.push(`"${keyword}"`);
      }

      const totalCount = window.baseEvents?.length || 0;
      if (!segments.length) {
        return `条件：未選択（全${totalCount.toLocaleString()}件）`;
      }
      const countValue = typeof filteredCount === "number"
        ? filteredCount
        : 0;
      return `条件：${segments.join(' × ')}（${countValue.toLocaleString()}件）`;
    }

    function updateConditionLine(filteredCount) {
      const sentenceEl = document.getElementById("conditionSentence");
      if (sentenceEl) {
        sentenceEl.textContent = buildConditionSentence(filteredCount);
      }
      updateCtaText(filteredCount);
      renderSelectedChips();
    }

    function updateCtaText(filteredCount) {
      const button = document.getElementById("searchToListBtn");
      if (!button) return;
      const countValue = typeof filteredCount === "number" ? filteredCount : 0;
      button.textContent = `${countValue.toLocaleString()}件を一覧で見る`;
    }

    function removePrefectureSelection(pref) {
      const normalized = normalizePrefectureName(pref);
      if (!normalized) return;
      const selection = Array.isArray(window.selectedPrefectures) ? window.selectedPrefectures : [];
      if (!selection.includes(normalized)) return;
      window.selectedPrefectures = selection.filter(p => p !== normalized);
      applyFiltersAndRender({ label: "" });
    }

    function handleSelectedChipRemove(type, value) {
      if (!value) return;
      if (type === "pref") {
        removePrefectureSelection(value);
        return;
      }
      if (type === "category") {
        const label = window.categoryLabelMap[value] || value;
        handleCategoryToggle(value, label, true);
        return;
      }
      if (type === "tag") {
        const label = window.tagLabelMap[value] || value;
        handleTagToggle(value, label, true);
        return;
      }
    }

    function renderSelectedChips() {
      const container = document.getElementById("selectedChips");
      if (!container) return;
      container.innerHTML = "";
      const createChip = (text, type, value) => {
        const chip = document.createElement("button");
        chip.type = "button";
        chip.className = `selection-chip selection-chip--${type}`;
        chip.innerHTML = `
          <span>${text}</span>
          <span class="selection-chip__remove" aria-hidden="true">×</span>
        `;
        chip.addEventListener("click", (event) => {
          event.preventDefault();
          handleSelectedChipRemove(type, value);
        });
        return chip;
      };

      const addPrefChips = () => {
        const prefs = Array.isArray(window.selectedPrefectures) ? window.selectedPrefectures : [];
        prefs.forEach(pref => {
          const label = getDisplayPrefName(pref);
          const chip = createChip(label, "pref", pref);
          container.appendChild(chip);
        });
      };

      const addCategoryChips = () => {
        window.selectedCategories.forEach(cat => {
          const label = window.categoryLabelMap[cat] || cat;
          const chip = createChip(label, "category", cat);
          container.appendChild(chip);
        });
      };

      const addTagChips = () => {
        window.selectedTags.forEach(tag => {
          const label = window.tagLabelMap[tag] || tag;
          const chip = createChip(label, "tag", tag);
          container.appendChild(chip);
        });
      };

      addPrefChips();
      addCategoryChips();
      addTagChips();
    }

    function updateFilterResultsNotice(filteredCount) {
      const mapSearchMap = document.getElementById('map-search-map');
      if (!mapSearchMap) return;
      let notice = mapSearchMap.querySelector('.map-filter-no-results');
      if (!notice) {
        notice = document.createElement('div');
        notice.className = 'map-filter-no-results';
        mapSearchMap.appendChild(notice);
      }
      if (filteredCount === 0) {
        const sentence = buildConditionSentence(filteredCount);
        notice.innerHTML = `
          <div class="no-results-sentence">${sentence}</div>
          <p class="no-results-guidance">エリアを広げる、カテゴリやタグを1つ外すなど、少し条件を緩めてみましょう。</p>
        `;
        notice.style.display = 'flex';
      } else {
        notice.style.display = 'none';
      }
    }

    async function applyFiltersAndRender(options = {}) {
      const { label = "", refreshMetaChips = true } = options;
      const heroSearchInput = document.getElementById('search-query');
      const headerSearchInput = document.querySelector('#header-search .header-search-input');

      if (label) {
        if (heroSearchInput) heroSearchInput.value = label;
        if (headerSearchInput) headerSearchInput.value = label;
      }

      if (!ensureBaseStats()) return;

      const filters = {
        prefectures: window.selectedPrefectures,
        categories: window.selectedCategories,
        tags: window.selectedTags
      };

      const filteredEvents = filterEvents(window.baseEvents, filters);
      window.filteredEvents = filteredEvents;

      await renderEventBlocks(filteredEvents);
      updateFilterResultsNotice(filteredEvents.length);
      updateSelectedPrefectureState(filteredEvents.length);
      if (refreshMetaChips) {
        renderMetaChips();
      }
      updateMapSelection();
    }

    // 初期化（イベントデータ読み込み → 描画）
    document.addEventListener('DOMContentLoaded', async () => {
      // ヒーロー背景画像の自動切り替えを開始
      setupHeroBackground();
      try {
        // イベントデータを読み込み（data.js で定義）
        await loadEventData();
        
        // メタデータ（カテゴリ・提供元）を読み込み
        if (typeof loadEventMeta === 'function') {
          try {
            await loadEventMeta();
          } catch (e) {
            console.warn('Failed to load eventMeta:', e);
          }
        }
        
        // eventIndex が読み込まれているか確認（なければ再読み込み）
        if (!Array.isArray(window.eventIndex) || window.eventIndex.length === 0) {
          try {
            await loadEventIndex();
          } catch (e) {
            console.warn('Failed to load eventIndex:', e);
          }
        }
        logPrefectureCoverage();

        const yearElement = document.getElementById('current-year');
        if (yearElement) {
          yearElement.textContent = new Date().getFullYear();
        }

        renderPopSection(); // ポップセクションを描画
        // 位置情報ベースのイベントを最優先で表示（データ読み込み後すぐに実行）
        // 地図から探す機能を初期化
        initMapSearch();
        renderCategories();
        initCategoryMenu(); // カテゴリメニューを初期化（ホバー表示用）
        renderWeekCalendar();
        initSearchToListButton();
        initAreaClearButton();
        await applyFiltersAndRender();
        // データ読み込み後にカテゴリカウントを更新
        console.log('[index.html] After loadEventData - eventData:', window.eventData);
        console.log('[index.html] After loadEventData - eventData.events:', Array.isArray(window.eventData?.events) ? window.eventData.events.length : 'not array');
        if (window.eventData?.events && window.eventData.events.length > 0) {
          console.log('[index.html] Sample event:', window.eventData.events[0]);
          console.log('[index.html] Sample event categoryId:', window.eventData.events[0].categoryId);
        }
        renderPopularSearch(); // 人気タグ・地域検索セクションを描画

      } catch (e) {
        console.error(e);
        const el = document.getElementById('error');
        if (el) el.textContent = 'データの読み込みに失敗しました';
      }
    });
  </script>
</body>
</html>
