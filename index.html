<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="description" content="è‡ªç„¶ä½“é¨“ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¢ã—ã¦äºˆç´„ã§ãã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã€‚ãƒˆãƒ¬ãƒƒã‚­ãƒ³ã‚°ã€ã‚«ãƒ¤ãƒƒã‚¯ã€æ˜Ÿç©ºè¦³å¯Ÿãªã©ã€ã‚ãªãŸã«ã´ã£ãŸã‚Šã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’è¦‹ã¤ã‘ã‚ˆã†ã€‚">
  <title>è‡ªç„¶ä½“é¨“ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ  | ãã¨ãªã³</title>
  <link rel="icon" type="image/png" href="https://res.cloudinary.com/ddrxsy9jw/image/upload/f_auto,q_auto,w_32/logo_tfqqd0">
  <link rel="apple-touch-icon" href="https://res.cloudinary.com/ddrxsy9jw/image/upload/f_auto,q_auto,w_180/logo_tfqqd0">
  <link rel="stylesheet" href="styles.css">
  <!-- d3.js and topojson-client for SVG map (scriptæ–¹å¼ã§çµ±ä¸€) -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "ãã¨ãªã³",
    "description": "è‡ªç„¶ä½“é¨“ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¢ã—ã¦äºˆç´„ã§ãã‚‹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ",
    "url": "https://example.com"
  }
  </script>
  <script>
    // GitHub raw URLï¼ˆå…¨ãƒšãƒ¼ã‚¸å…±é€šè¨­å®šï¼‰
    window.GITHUB_RAW_BASE = "https://raw.githubusercontent.com/setagayatankyubase-create/trip-platform/main";
    // Google Maps API ã‚­ãƒ¼
    window.GOOGLE_MAPS_API_KEY = window.GOOGLE_MAPS_API_KEY || 'AIzaSyDNV6H5ImWmE2DhWdRYupUER85Rb8ZqmQM';
  </script>
  <script>
    // ãƒ­ã‚´ç”»åƒã‚’Cloudinaryã‹ã‚‰å–å¾—ï¼ˆdata.jsèª­ã¿è¾¼ã¿å¾Œã«å®Ÿè¡Œï¼‰
    (function() {
      function setLogoUrl() {
        const logoImage = document.querySelector('.logo-image');
        if (logoImage && typeof window.getLogoUrl === 'function') {
          logoImage.src = window.getLogoUrl();
        }
      }
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setLogoUrl);
      } else {
        setLogoUrl();
      }
    })();
  </script>
<body>
  <header class="main-header" id="main-header">
    <div class="nav">
      <div class="nav-left">
        <a href="index.html" class="logo">
          <img src="" alt="ãã¨ãªã³" class="logo-image">
        </a>
        <div class="header-search" id="header-search" style="display: none;">
          <form class="header-search-form" onsubmit="handleSearch(event)">
            <button type="button" class="header-category-menu-button" id="header-category-menu-button" aria-label="ã‚«ãƒ†ã‚´ãƒªãƒ¡ãƒ‹ãƒ¥ãƒ¼">
              <span class="hamburger-icon">
                <span></span>
                <span></span>
                <span></span>
              </span>
            </button>
            <input type="text" placeholder="å ´æ‰€åãƒ»ä½“é¨“åã§æ¢ã™" name="q" class="header-search-input">
            <button type="submit" class="header-search-button">æ¤œç´¢</button>
          </form>
        </div>
      </div>
      <div class="nav-links">
        <a href="list.html">ã‚¤ãƒ™ãƒ³ãƒˆä¸€è¦§</a>
        <a href="organizer-list.html">æä¾›å…ƒ</a>
        <a href="column.html">ã‚³ãƒ©ãƒ </a>
      </div>
    </div>
  </header>

  <!-- Hero Section -->
  <section class="hero-section">
    <div class="hero-section-background" id="hero-bg-1" style="opacity: 1;"></div>
    <div class="hero-section-background" id="hero-bg-2"></div>
    <div class="hero-content">
      <h1 class="hero-title">æ±äº¬ã®ã™ããã°ã«ã€ã¾ã çŸ¥ã‚‰ãªã„<br>è‡ªç„¶ãŒã‚ã‚‹</h1>
      <div class="search-wrapper">
        <form class="hero-search-form" id="main-search-form" onsubmit="handleSearch(event)">
          <button type="button" class="category-menu-button" id="category-menu-button" aria-label="ã‚«ãƒ†ã‚´ãƒªãƒ¡ãƒ‹ãƒ¥ãƒ¼">
            <span class="hamburger-icon">
              <span></span>
              <span></span>
              <span></span>
            </span>
          </button>
          <input type="text" id="search-query" placeholder="å ´æ‰€åãƒ»ä½“é¨“åã§æ¢ã™" name="q" class="hero-search-input">
          <button type="submit" class="hero-search-button">æ¤œç´¢</button>
        </form>
        <div class="category-menu" id="category-menu">
          <div class="category-menu-content" id="category-menu-list"></div>
        </div>
      </div>
      <p class="hero-subtext">é€±æœ«ã‚’ã€ãã¨ãªã³ã§</p>
    </div>
  </section>

  <main>
    <!-- ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆå­£ç¯€ãƒ»ç·¨é›†éƒ¨ãŠã™ã™ã‚ï¼‰ -->
    <section class="section pop-section">
      <!-- 1æ®µç›®ï¼šå¤§ããªæ¨ªé•·ãƒãƒŠãƒ¼ -->
      <div class="pop-banner-wrapper">
        <div id="pop-banner-container"></div>
      </div>
      <!-- 2æ®µç›®ï¼šã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰ -->
      <div class="pop-campaigns-wrapper">
        <div class="pop-carousel-wrapper">
          <div class="pop-carousel" id="pop-carousel"></div>
        </div>
      </div>
    </section>

    <!-- ä»Šé€±ã®ã‚¤ãƒ™ãƒ³ãƒˆ -->
    <section class="section event-block">
      <div class="week-event-header">
        <h2>ä»Šé€±ã®ã‚¤ãƒ™ãƒ³ãƒˆ</h2>
      </div>
      <div class="week-calendar-wrapper">
        <div class="week-calendar" id="week-calendar"></div>
        <button id="next-week-btn" class="week-nav-arrow" onclick="showNextWeek()">â†’</button>
      </div>
    </section>

    <!-- è¡ŒããŸã„ã‚¨ãƒªã‚¢ã‚’é¸ã¶ -->
    <section class="section event-block" id="map-search-section">
      <div class="event-block-header">
        <h2>è¡ŒããŸã„ã‚¨ãƒªã‚¢ã‚’é¸ã¶</h2>
      </div>
      <div class="map-search-container">
        <div class="map-search-description">
          <p>åœ°å›³ã‹ã‚‰ã‚¨ãƒªã‚¢ã‚’é¸ã‚“ã§ä½“é¨“ã‚’è¦‹ã‚‹</p>
          <button class="map-nearby-button" id="map-nearby-button">
            <span class="map-nearby-icon">ğŸ“</span>
            <span>è¿‘ãã‹ã‚‰æ¢ã™</span>
          </button>
        </div>
        <div class="map-search-map" id="map-search-map">
          <div class="map-svg-container" id="map-svg-container">
            <svg id="kantoMap"></svg>
          </div>
          <div class="map-cities-list" id="map-cities-list" style="display: none;">
            <button class="map-back-button" id="map-back-button">â† ã‚¨ãƒªã‚¢é¸æŠã«æˆ»ã‚‹</button>
            <h3 class="map-cities-title" id="map-cities-title"></h3>
            <div class="map-cities-grid" id="map-cities-grid"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- ç›´è¿‘é–‹å‚¬ã‚¤ãƒ™ãƒ³ãƒˆ -->
    <section class="section event-block">
      <div class="event-block-header">
        <h2>ç›´è¿‘é–‹å‚¬ã‚¤ãƒ™ãƒ³ãƒˆ</h2>
        <a href="list.html?upcoming=1" class="view-all">ã™ã¹ã¦è¦‹ã‚‹ â†’</a>
      </div>
      <div class="card-carousel-wrapper">
        <div class="card-carousel" id="upcoming-events"></div>
      </div>
    </section>

    <!-- æ–°ç€ã‚¤ãƒ™ãƒ³ãƒˆ -->
    <section class="section event-block">
      <div class="event-block-header">
        <h2>æ–°ç€ã‚¤ãƒ™ãƒ³ãƒˆ</h2>
        <a href="list.html?new=1" class="view-all">ã™ã¹ã¦è¦‹ã‚‹ â†’</a>
      </div>
      <div class="card-carousel-wrapper">
        <div class="card-carousel" id="new-events"></div>
      </div>
    </section>

    <!-- äººæ°—ã‚«ãƒ†ã‚´ãƒª -->
    <section id="categories" class="section">
      <h2>äººæ°—ã‚«ãƒ†ã‚´ãƒª</h2>
      <div class="categories" id="category-list"></div>
    </section>

    <!-- äººæ°—ã‚¤ãƒ™ãƒ³ãƒˆ -->
    <section class="section event-block">
      <div class="event-block-header">
        <h2>äººæ°—ã‚¤ãƒ™ãƒ³ãƒˆ</h2>
        <a href="list.html?recommended=1" class="view-all">ã™ã¹ã¦è¦‹ã‚‹ â†’</a>
      </div>
      <div class="card-carousel-wrapper">
        <div class="card-carousel" id="recommended-events"></div>
      </div>
    </section>
  </main>

  <!-- ã‚¿ã‚°ãƒ»åœ°åŸŸæ¤œç´¢ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
  <section class="section popular-search-section">
    <div class="popular-search-container">
      <div class="popular-search-tabs">
        <button class="popular-tab active" data-tab="categories">ã‚«ãƒ†ã‚´ãƒªãƒ¼</button>
        <button class="popular-tab" data-tab="areas">è¡Œãå…ˆ</button>
        <button class="popular-tab" data-tab="tags">ã‚¿ã‚°</button>
      </div>
      <div class="popular-search-content">
        <div class="popular-list-container" id="popular-categories-list"></div>
        <div class="popular-list-container hidden" id="popular-areas-list"></div>
        <div class="popular-list-container hidden" id="popular-tags-list"></div>
      </div>
    </div>
  </section>

  <footer class="main-footer">
    <div class="footer-content">
      <div class="footer-column">
        <h3>ã‚µãƒãƒ¼ãƒˆ</h3>
        <a href="contact.html">ãŠå•ã„åˆã‚ã›</a>
        <a href="terms.html">åˆ©ç”¨è¦ç´„</a>
        <a href="privacy.html">ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼</a>
      </div>
      <div class="footer-column">
        <h3>é‹å–¶æƒ…å ±</h3>
        <a href="about.html">é‹å–¶ã«ã¤ã„ã¦</a>
      </div>
      <div class="footer-column">
        <h3>æ²è¼‰ã«ã¤ã„ã¦</h3>
        <a href="publish.html">æ²è¼‰ã«ã¤ã„ã¦</a>
      </div>
    </div>
    <div class="footer-bottom">
      <div class="footer-copyright">
        Â© <span id="current-year"></span> ãã¨ãªã³. è£½ä½œ
      </div>
    </div>
  </footer>

  <script src="data.js?v=4_2025-12-25"></script>
  <script src="app.js"></script>
  <script>
    // ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    function renderPopSection() {
      const bannerContainer = document.getElementById('pop-banner-container');
      const carouselContainer = document.getElementById('pop-carousel');
      
      // ãƒãƒŠãƒ¼ãƒ‡ãƒ¼ã‚¿
      const bannerData = {
        type: 'banner',
        title: 'å­£ç¯€ã§æ¥½ã—ã‚€ã€è‡ªç„¶ã®ã‚ãã³ã€‚',
        subtitle: 'å±±ãƒ»æ£®ãƒ»å·ãƒ»æµ·ã€‚<br>å­ã©ã‚‚ã‚‚å¤§äººã‚‚ã€æ°—è»½ã«å‚åŠ ã§ãã‚‹è‡ªç„¶ä½“é¨“ã‚’é›†ã‚ã¾ã—ãŸã€‚',
        badge: '',
        cta: 'ä½“é¨“ã‚’æ¢ã™',
        image: 'pop1_j2wr9k', // ãƒãƒŠãƒ¼ç”»åƒ
        bgColor: '#6BB6FF', // å³å´ã®èƒŒæ™¯è‰²
        link: '/list.html'
      };

      // ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿
      const campaignData = [
        {
          type: 'card',
          title: 'å†¬ã®è‡ªç„¶ä½“é¨“',
          subtitle: 'é›ªãƒ»é‡é³¥ãƒ»é‡Œå±±',
          badge: 'å­£ç¯€',
          image: 'pop4_fucevc', // å†¬ã®ç”»åƒ
          link: '/?season=winter'
        },
        {
          type: 'card',
          title: 'æ˜¥ã®è‡ªç„¶è¦³å¯Ÿ',
          subtitle: 'æ¤ç‰©ãƒ»ç”Ÿãç‰©ãƒ»é‡Œå±±',
          badge: 'å­£ç¯€',
          image: 'pop2_go0z71', // æ˜¥ã®ç”»åƒ
          link: '/?season=spring'
        },
        {
          type: 'card',
          title: 'è¦ªå­ã§æ¥½ã—ã‚€è‡ªç„¶ä½“é¨“',
          subtitle: 'å®¶æ—ã§ä¸€ç·’ã«è‡ªç„¶ã‚’å­¦ã¶',
          badge: 'è¦ªå­',
          image: 'pop3_y2bf8t', // è¦ªå­ã®ç”»åƒ
          link: '/?q=è¦ªå­'
        },
        {
          type: 'card',
          title: 'å°ç¬ åŸè«¸å³¶',
          subtitle: 'ä¸–ç•Œè‡ªç„¶éºç”£ã®å³¶ã€…',
          badge: 'ç‰¹åˆ¥',
          image: 'pop5_wkswlf', // å°ç¬ åŸè«¸å³¶ã®ç”»åƒ
          link: '/?area=å°ç¬ åŸè«¸å³¶'
        }
      ];

      // 1æ®µç›®ï¼šãƒãƒŠãƒ¼ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      if (bannerContainer && bannerData) {
        let imageUrl = '';
        if (bannerData.image) {
          if (typeof window.cloudinaryUrl === 'function') {
            imageUrl = window.cloudinaryUrl(bannerData.image, { w: 1000, h: 560 });
          } else if (bannerData.image.startsWith('http')) {
            imageUrl = bannerData.image;
          } else {
            imageUrl = `https://res.cloudinary.com/ddrxsy9jw/image/upload/f_auto,q_auto,w_1000,h_560/${bannerData.image}`;
          }
        }

        const imageStyle = imageUrl 
          ? `background-image: url('${imageUrl.replace(/'/g, "\\'")}');`
          : '';
        
        const bgColor = bannerData.bgColor || '#6BB6FF';

        bannerContainer.innerHTML = `
          <a href="${bannerData.link || '#'}" class="pop-banner">
            <div class="pop-banner-image" style="${imageStyle}">
              <div class="pop-banner-image-overlay">
                ${bannerData.badge ? `<span class="pop-banner-badge">${bannerData.badge}</span>` : ''}
                <div class="pop-banner-title">
                  ${bannerData.title || ''}
                </div>
              </div>
            </div>
            <div class="pop-banner-content" style="background: ${bgColor};">
              <div class="pop-banner-subtitle">${bannerData.subtitle || ''}</div>
              ${bannerData.cta ? `<span class="pop-banner-button">${bannerData.cta}</span>` : ''}
            </div>
          </a>
        `;
      }

      // 2æ®µç›®ï¼šã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾å¿œï¼‰
      if (carouselContainer && campaignData && campaignData.length > 0) {
        // ã‚«ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹é–¢æ•°
        const renderCard = (pop) => {
          let imageUrl = '';
          if (pop.image) {
            if (typeof window.cloudinaryUrl === 'function') {
              imageUrl = window.cloudinaryUrl(pop.image, { w: 640, h: 480 });
            } else if (pop.image.startsWith('http')) {
              imageUrl = pop.image;
            } else {
              imageUrl = `https://res.cloudinary.com/ddrxsy9jw/image/upload/f_auto,q_auto,w_640,h_480/${pop.image}`;
            }
          }

          const imageStyle = imageUrl 
            ? `background-image: url('${imageUrl.replace(/'/g, "\\'")}');`
            : '';

          return `
            <a href="${pop.link || '#'}" class="pop-card">
              <div class="pop-card-image" style="${imageStyle}">
                <div class="pop-card-overlay">
                  ${pop.badge ? `<span class="pop-card-badge">${pop.badge}</span>` : ''}
                  <div class="pop-card-title">${pop.title || ''}</div>
                  ${pop.subtitle ? `<div class="pop-card-subtitle">${pop.subtitle}</div>` : ''}
                  <span class="pop-card-cta">è©³ã—ãè¦‹ã‚‹ â†’</span>
                </div>
              </div>
            </a>
          `;
        };

        // ã‚«ãƒ¼ãƒ‰ã‚’2ã‚»ãƒƒãƒˆä½œæˆï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—ç”¨ï¼‰
        const cardsHtml = campaignData.map(renderCard).join('');
        carouselContainer.innerHTML = cardsHtml + cardsHtml; // å…ƒã®ã‚»ãƒƒãƒˆ + è¤‡è£½ã‚»ãƒƒãƒˆ
        
        // ç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹
        setTimeout(() => {
          const wrapper = carouselContainer.parentElement;
          if (wrapper) {
            wrapper.classList.add('pop-carousel-infinite');
          }
        }, 100);
      } else if (carouselContainer && (!campaignData || campaignData.length === 0)) {
        carouselContainer.parentElement.parentElement.style.display = 'none';
      }
    }

    // ã‚¿ã‚°ãƒ»åœ°åŸŸæ¤œç´¢ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    async function renderPopularSearch() {
      // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
      document.querySelectorAll('.popular-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const tabName = tab.dataset.tab;
          
          // ã™ã¹ã¦ã®ã‚¿ãƒ–ã¨ã‚³ãƒ³ãƒ†ãƒŠã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
          document.querySelectorAll('.popular-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.popular-list-container').forEach(c => c.classList.add('hidden'));
          
          // é¸æŠã•ã‚ŒãŸã‚¿ãƒ–ã¨ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
          tab.classList.add('active');
          document.getElementById(`popular-${tabName}-list`).classList.remove('hidden');
        });
      });

      // ã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆéåŒæœŸï¼‰
      await renderPopularCategories();
      renderPopularAreas();
      renderPopularTags();
    }

    // ã‚«ãƒ†ã‚´ãƒªä¸€è¦§
    async function renderPopularCategories() {
      const container = document.getElementById('popular-categories-list');
      if (!container || !window.eventMeta || !window.eventMeta.categories) {
        console.log('[renderPopularCategories] Container or categories not found');
        return;
      }

      const categories = window.eventMeta.categories; // ã™ã¹ã¦ã®ã‚«ãƒ†ã‚´ãƒªã‚’è¡¨ç¤º
      console.log('[renderPopularCategories] Rendering', categories.length, 'categories');
      
      // eventData.eventsã®ç¢ºèª
      const eventDataCount = Array.isArray(window.eventData?.events) ? window.eventData.events.length : 0;
      console.log('[renderPopularCategories] eventData.events:', eventDataCount, 'events');
      
      if (eventDataCount === 0) {
        console.warn('[renderPopularCategories] eventData.events is empty, categories will show 0 events');
        container.innerHTML = categories.map(cat => `
          <a href="list.html?category=${cat.id}" class="popular-item" data-item-id="${cat.id}">
            <span class="popular-item-name">${cat.name}</span>
            <span class="popular-item-count">0 ã‚¤ãƒ™ãƒ³ãƒˆ</span>
          </a>
        `).join('');
        return;
      }
      
      // ã¾ãšåŒæœŸç‰ˆã§ã‚«ã‚¦ãƒ³ãƒˆï¼ˆcategoryIdãŒæ—¢ã«ã‚ã‚‹å ´åˆï¼‰
      let html = categories.map(cat => {
        const eventCount = countEventsByCategorySync(cat.id);
        return { cat, count: eventCount };
      }).map(({ cat, count }) => `
        <a href="list.html?category=${cat.id}" class="popular-item" data-item-id="${cat.id}">
          <span class="popular-item-name">${cat.name}</span>
          <span class="popular-item-count">${count} ã‚¤ãƒ™ãƒ³ãƒˆ</span>
        </a>
      `).join('');
      
      container.innerHTML = html;
      
      // éåŒæœŸã§categoryIdã‚’è£œå®Œã—ã¦å†ã‚«ã‚¦ãƒ³ãƒˆ
      const categoryCounts = await Promise.all(
        categories.map(async cat => {
          const count = await countEventsByCategory(cat.id);
          return { cat, count };
        })
      );
      
      // æ›´æ–°ã•ã‚ŒãŸã‚«ã‚¦ãƒ³ãƒˆã§å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      html = categoryCounts.map(({ cat, count }) => `
        <a href="list.html?category=${cat.id}" class="popular-item" data-item-id="${cat.id}">
          <span class="popular-item-name">${cat.name}</span>
          <span class="popular-item-count">${count} ã‚¤ãƒ™ãƒ³ãƒˆ</span>
        </a>
      `).join('');
      
      container.innerHTML = html;
      console.log('[renderPopularCategories] Updated category counts:', categoryCounts.map(({ cat, count }) => `${cat.name}: ${count}`).join(', '));
    }

    // ã‚¨ãƒªã‚¢ä¸€è¦§ï¼ˆé–¢æ±ï¼‹å±±æ¢¨ï¼‰
    function renderPopularAreas() {
      const container = document.getElementById('popular-areas-list');
      if (!container || !Array.isArray(window.eventIndex)) return;

      // é–¢æ±åœ°æ–¹ï¼‹å±±æ¢¨çœŒã®éƒ½é“åºœçœŒãƒªã‚¹ãƒˆ
      const kantoPrefectures = [
        'æ±äº¬éƒ½',
        'ç¥å¥ˆå·çœŒ',
        'åƒè‘‰çœŒ',
        'åŸ¼ç‰çœŒ',
        'ç¾¤é¦¬çœŒ',
        'æ ƒæœ¨çœŒ',
        'èŒ¨åŸçœŒ',
        'å±±æ¢¨çœŒ'
      ];

      // éƒ½é“åºœçœŒã”ã¨ã«ã‚¤ãƒ™ãƒ³ãƒˆæ•°ã‚’é›†è¨ˆ
      const prefectureMap = new Map();
      window.eventIndex.forEach(event => {
        const prefecture = event.prefecture || '';
        if (prefecture && kantoPrefectures.includes(prefecture)) {
          prefectureMap.set(prefecture, (prefectureMap.get(prefecture) || 0) + 1);
        }
      });

      // é–¢æ±ï¼‹å±±æ¢¨ã®éƒ½é“åºœçœŒã‚’é †ç•ªã«è¡¨ç¤ºï¼ˆã‚¤ãƒ™ãƒ³ãƒˆæ•°é †ï¼‰
      const areas = kantoPrefectures
        .map(pref => ({
          name: pref,
          count: prefectureMap.get(pref) || 0
        }))
        .sort((a, b) => b.count - a.count);

      container.innerHTML = areas.map(area => {
        return `
          <a href="list.html?area=${encodeURIComponent(area.name)}" class="popular-item" data-item-name="${area.name}">
            <span class="popular-item-name">${area.name}</span>
            <span class="popular-item-count">${area.count} ã‚¤ãƒ™ãƒ³ãƒˆ</span>
          </a>
        `;
      }).join('');
    }

    // ã‚¿ã‚°ä¸€è¦§
    function renderPopularTags() {
      const container = document.getElementById('popular-tags-list');
      if (!container) return;

      // eventData.eventsã‚’å„ªå…ˆã€ãªã‘ã‚Œã°eventIndexã‚’ä½¿ç”¨
      const source = Array.isArray(window.eventData?.events) && window.eventData.events.length > 0
        ? window.eventData.events
        : (Array.isArray(window.eventIndex) ? window.eventIndex : []);

      if (source.length === 0) return;

      // ã‚¿ã‚°ã¨ã—ã¦äººæ°—ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ï¼ˆã‚¿ã‚°åã¨æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼‰
      const tagConfigs = [
        { name: 'å·éŠã³', keywords: ['å·', 'å·éŠã³', 'æ°´éŠã³'] },
        { name: 'æµ·ãƒ»ãƒ“ãƒ¼ãƒ', keywords: ['æµ·', 'ãƒ“ãƒ¼ãƒ', 'æµ·å²¸', 'ãƒãƒªãƒ³ã‚¹ãƒãƒ¼ãƒ„'] },
        { name: 'é‡Œå±±ä½“é¨“', keywords: ['é‡Œå±±', 'é‡Œå±±ä½“é¨“', 'ç”°èˆ'] },
        { name: 'è‡ªç„¶è¦³å¯Ÿ', keywords: ['è¦³å¯Ÿ', 'è‡ªç„¶è¦³å¯Ÿ', 'è¦³å¯Ÿä¼š'] },
        { name: 'ç”Ÿãç‰©', keywords: ['ç”Ÿãç‰©', 'ç”Ÿç‰©', 'å‹•ç‰©', 'æ˜†è™«'] },
        { name: 'è¾²æ¥­ä½“é¨“', keywords: ['è¾²æ¥­', 'è¾²æ¥­ä½“é¨“', 'è¾²ä½œæ¥­'] },
        { name: 'åç©«ä½“é¨“', keywords: ['åç©«', 'åç©«ä½“é¨“', 'æ¡ã‚Š'] },
        { name: 'æ¤ç‰©', keywords: ['æ¤ç‰©', 'è‰èŠ±', 'èŠ±', 'æ¨¹æœ¨'] },
        { name: 'é‡é³¥', keywords: ['é‡é³¥', 'é³¥', 'ãƒãƒ¼ãƒ‰ã‚¦ã‚©ãƒƒãƒãƒ³ã‚°'] },
        { name: 'æ˜Ÿç©º', keywords: ['æ˜Ÿç©º', 'æ˜Ÿ', 'å¤©ä½“', 'æ˜Ÿåº§'] },
        { name: 'ã‚­ãƒ£ãƒ³ãƒ—', keywords: ['ã‚­ãƒ£ãƒ³ãƒ—', 'ãƒ†ãƒ³ãƒˆ', 'ç„šãç«'] },
        { name: 'è¦ªå­', keywords: ['è¦ªå­', 'å®¶æ—', 'å­ã©ã‚‚', 'å­ä¾›'] },
      ];

      // å„ã‚¿ã‚°ã®ã‚¤ãƒ™ãƒ³ãƒˆæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆè¤‡æ•°ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§æ¤œç´¢ï¼‰
      const tags = tagConfigs.map(tagConfig => {
        const count = source.filter(e => {
          const searchTexts = [
            e.title,
            e.name,
            e.description,
            e.detail,
            e.city,
            e.prefecture,
            e.area,
            e.area_name,
            e.category,
            e.category_name,
            e.category && e.category.name ? e.category.name : null
          ].filter(Boolean).join(' ').toLowerCase();
          
          // ã‚¿ã‚°ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ã„ãšã‚Œã‹ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
          return tagConfig.keywords.some(keyword => 
            searchTexts.includes(keyword.toLowerCase())
          );
        }).length;
        
        return { name: tagConfig.name, count: count, keywords: tagConfig.keywords };
      }).filter(tag => tag.count > 0).sort((a, b) => b.count - a.count);

      container.innerHTML = tags.map(tag => {
        // ã‚¿ã‚°åã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ä¸¡æ–¹ã§æ¤œç´¢ã§ãã‚‹ã‚ˆã†ã«ã€æœ€åˆã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨
        const searchQuery = tag.keywords[0];
        return `
          <a href="list.html?q=${encodeURIComponent(searchQuery)}" class="popular-item" data-tag-name="${tag.name}">
            <span class="popular-item-name">${tag.name}</span>
            <span class="popular-item-count">${tag.count} ã‚¤ãƒ™ãƒ³ãƒˆ</span>
          </a>
        `;
      }).join('');
    }

    // ã‚«ãƒ†ã‚´ãƒªåˆ¥ã‚¤ãƒ™ãƒ³ãƒˆæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆè©³ç´°JSONã‹ã‚‰categoryIdã‚’å–å¾—ã—ã¦è¨ˆæ¸¬ï¼‰
    async function countEventsByCategory(categoryId) {
      // eventData.eventsã‚’å„ªå…ˆã—ã¦ä½¿ç”¨
      const source = Array.isArray(window.eventData?.events) ? window.eventData.events : [];
      
      if (source.length === 0) {
        console.log('[countEventsByCategory] No eventData.events available for category:', categoryId);
        return 0;
      }
      
      // categoryIdãŒç©ºã®ã‚¤ãƒ™ãƒ³ãƒˆã®è©³ç´°ã‚’èª­ã¿è¾¼ã‚“ã§è£œå®Œï¼ˆã™ã¹ã¦ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¯¾è±¡ï¼‰
      const eventsWithoutCategory = source.filter(e => !e.categoryId && !e.category_id && !e.category);
      if (eventsWithoutCategory.length > 0) {
        console.log('[countEventsByCategory] Loading categoryId for', eventsWithoutCategory.length, 'events');
        try {
          // ã™ã¹ã¦ã®ã‚¤ãƒ™ãƒ³ãƒˆã®è©³ç´°ã‚’èª­ã¿è¾¼ã‚“ã§ categoryId ã‚’è£œå®Œ
          const detailPromises = eventsWithoutCategory.map(e => 
            loadEventDetail(e.id).catch(() => null)
          );
          const details = await Promise.all(detailPromises);
          const detailMap = {};
          details.forEach(d => {
            if (d && d.id && d.categoryId) {
              detailMap[d.id] = d.categoryId;
            }
          });
          
          // sourceã«categoryIdã‚’è£œå®Œ
          source.forEach(item => {
            if (detailMap[item.id]) {
              item.categoryId = detailMap[item.id];
            }
          });
          
          console.log('[countEventsByCategory] Enriched categoryId for', Object.keys(detailMap).length, 'events');
        } catch (e) {
          console.warn('[countEventsByCategory] Failed to enrich categoryId:', e);
        }
      }
      
      const matches = source.filter(e => {
        const catId = e.categoryId || e.category_id || e.category;
        return String(catId) === String(categoryId);
      });
      
      return matches.length;
    }
    
    // åŒæœŸç‰ˆï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼‰
    function countEventsByCategorySync(categoryId) {
      const source = Array.isArray(window.eventData?.events) ? window.eventData.events : [];
      if (source.length === 0) return 0;
      
      const matches = source.filter(e => {
        const catId = e.categoryId || e.category_id || e.category;
        return String(catId) === String(categoryId);
      });
      
      return matches.length;
    }

    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰åˆ¥ã‚¤ãƒ™ãƒ³ãƒˆæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆeventData.eventsã‚’å„ªå…ˆï¼‰
    function countEventsByKeyword(keyword) {
      // eventData.eventsã‚’å„ªå…ˆã€ãªã‘ã‚Œã°eventIndexã‚’ä½¿ç”¨
      const source = Array.isArray(window.eventData?.events) && window.eventData.events.length > 0
        ? window.eventData.events
        : (Array.isArray(window.eventIndex) ? window.eventIndex : []);
      
      if (source.length === 0) return 0;
      
      const kw = keyword.toLowerCase();
      return source.filter(e => {
        const texts = [
          e.title,
          e.name, // APIå´ã§ title ãŒ name ã«ãªã£ã¦ã„ã‚‹å ´åˆã«å¯¾å¿œ
          e.description,
          e.city,
          e.prefecture,
          e.area,
          e.area_name,
          e.category,
          e.category_name,
          e.category && e.category.name ? e.category.name : null
        ].filter(Boolean); // null/undefinedã‚’é™¤å¤–
        
        return texts.some(t => typeof t === 'string' && t.toLowerCase().includes(kw));
      }).length;
    }

    // ã‚«ãƒ†ã‚´ãƒªIDã‹ã‚‰lucide-staticã‚¢ã‚¤ã‚³ãƒ³åã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°
    const categoryIconMap = {
      'river-water': 'waves',
      'sea-beach': 'shell',
      'mountain-satoyama': 'mountain',
      'forest': 'trees',
      'wildlife': 'paw-print',
      'farm-harvest': 'wheat',
      'animals': 'dog',
      'fire-outdoor': 'flame',
      'camp': 'tent',
      'natural-materials': 'leaf',
      'cycling': 'bike',
      'seasonal': 'sun-snow'
    };

    // ã‚«ãƒ†ã‚´ãƒªã‚¢ã‚¤ã‚³ãƒ³ã®URLã‚’å–å¾—
    function getCategoryIconUrl(categoryId) {
      const iconName = categoryIconMap[categoryId];
      if (!iconName) return '';
      return `https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/${iconName}.svg`;
    }

    // ã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã®è¡¨ç¤ºï¼ˆäººæ°—ã‚«ãƒ†ã‚´ãƒªï¼šã‚¤ãƒ™ãƒ³ãƒˆæ•°ã®å¤šã„é †ã«æœ€å¤§6ä»¶ï¼‰
    function renderCategories() {
      const container = document.getElementById('category-list');
      if (!container) return;

      // eventMeta.categories ã‚’å„ªå…ˆã€ãªã‘ã‚Œã° eventData.categories ã‚’ä½¿ç”¨
      const categories = (window.eventMeta && window.eventMeta.categories) 
        ? window.eventMeta.categories 
        : (window.eventData && window.eventData.categories) 
          ? window.eventData.categories 
          : null;
      
      console.log('[index.html] renderCategories - categories:', categories);
      
      if (!categories || !Array.isArray(categories) || categories.length === 0) {
        console.warn('[index.html] renderCategories - No categories found');
        return;
      }

      // ã‚¤ãƒ™ãƒ³ãƒˆã”ã¨ã®ã‚«ãƒ†ã‚´ãƒªå‡ºç¾å›æ•°ã‚’é›†è¨ˆ
      const events = (window.eventData && Array.isArray(window.eventData.events))
        ? window.eventData.events
        : [];

      const counts = {};
      if (events.length > 0) {
        events.forEach(ev => {
          const ids = new Set();
          if (ev.categoryId) ids.add(String(ev.categoryId));
          if (ev.category_id) ids.add(String(ev.category_id));
          if (ev.category) ids.add(String(ev.category));
          if (Array.isArray(ev.categories)) {
            ev.categories.forEach(c => {
              if (!c) return;
              if (typeof c === 'string') {
                ids.add(c);
              } else if (c.id) {
                ids.add(String(c.id));
              }
            });
          }
          ids.forEach(id => {
            counts[id] = (counts[id] || 0) + 1;
          });
        });
      }

      console.log('[index.html] renderCategories - counts:', counts);

      // äººæ°—é †ã«ã‚½ãƒ¼ãƒˆã—ã€æœ€å¤§6ä»¶ã«çµã‚‹
      let sorted = categories.slice();
      if (Object.keys(counts).length > 0) {
        sorted.sort((a, b) => {
          const ca = counts[a.id] || 0;
          const cb = counts[b.id] || 0;
          if (cb !== ca) return cb - ca; // å¤šã„é †
          // åŒæ•°ãªã‚‰å…ƒã®é †åºã‚’ç¶­æŒï¼ˆidã§å®‰å®šã‚½ãƒ¼ãƒˆï¼‰
          return String(a.id).localeCompare(String(b.id));
        });

        // 1ä»¶ä»¥ä¸Šã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚‹ã‚«ãƒ†ã‚´ãƒªã ã‘ã«çµã‚‹
        sorted = sorted.filter(cat => (counts[cat.id] || 0) > 0);
      }

      // æœ€å¤§6ä»¶ã¾ã§
      const topCategories = sorted.slice(0, 6);

      container.innerHTML = topCategories.map(cat => {
        const iconUrl = getCategoryIconUrl(cat.id);
        return `
        <a href="list.html?category=${cat.id}" class="cat">
          ${iconUrl ? `<img src="${iconUrl}" alt="${cat.name || ''}" class="category-icon" />` : '<span></span>'}
          <span>${cat.name || ''}</span>
        </a>
      `;
      }).join('');
    }

    // ã‚«ãƒ†ã‚´ãƒªãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ä½ç½®ã‚’è¨ˆç®—ï¼ˆfixed positionç”¨ï¼‰
    function positionCategoryMenu() {
      const btn = document.getElementById('category-menu-button');
      const menu = document.querySelector('.category-menu');
      if (!btn || !menu) return;

      const rect = btn.getBoundingClientRect();
      const gap = 8;

      menu.style.top = `${rect.bottom + gap}px`;
      menu.style.left = `${rect.left}px`;

      // å³ã«ã¯ã¿å‡ºã™å ´åˆã®ä¿é™º
      const menuRect = menu.getBoundingClientRect();
      const overflowRight = menuRect.right - window.innerWidth;
      if (overflowRight > 0) {
        menu.style.left = `${Math.max(8, rect.left - overflowRight - 8)}px`;
      }

      // ä¸‹ã«ã¯ã¿å‡ºã™å ´åˆã¯ max-height ã‚’èª¿æ•´
      const available = window.innerHeight - (rect.bottom + gap) - 8;
      menu.style.maxHeight = `${Math.max(120, available)}px`;
    }

    // ã‚«ãƒ†ã‚´ãƒªãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’åˆæœŸåŒ–ï¼ˆãƒ›ãƒãƒ¼ã§è¡¨ç¤ºã•ã‚Œã‚‹ã®ã§ã€äº‹å‰ã«ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã¦ãŠãï¼‰
    function initCategoryMenu() {
      const menuList = document.getElementById('category-menu-list');
      if (!menuList) return;

      // eventMeta.categories ã‚’å„ªå…ˆã€ãªã‘ã‚Œã° eventData.categories ã‚’ä½¿ç”¨
      const categories = (window.eventMeta && window.eventMeta.categories) 
        ? window.eventMeta.categories 
        : (window.eventData && window.eventData.categories) 
          ? window.eventData.categories 
          : null;
      
      console.log('[index.html] initCategoryMenu - categories:', categories);
      
      if (!categories || !Array.isArray(categories) || categories.length === 0) {
        console.warn('[index.html] initCategoryMenu - No categories found');
        return;
      }
      
      menuList.innerHTML = categories.map(cat => {
        const iconUrl = getCategoryIconUrl(cat.id);
        return `
        <a href="list.html?category=${cat.id}" class="category-menu-item">
          ${iconUrl ? `<img src="${iconUrl}" alt="${cat.name || ''}" class="icon" />` : '<span class="icon"></span>'}
          <span class="name">${cat.name || ''}</span>
        </a>
      `;
      }).join('');

      const menu = document.querySelector('.category-menu');
      const categoryButton = document.getElementById('category-menu-button');
      let hideTimer = null;
      let isMenuOpen = false; // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®é–‹é–‰çŠ¶æ…‹ã‚’ç®¡ç†

      // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
      function showMenu() {
        if (hideTimer) {
          clearTimeout(hideTimer);
          hideTimer = null;
        }
        positionCategoryMenu();
        menu.style.opacity = '1';
        menu.style.visibility = 'visible';
        menu.style.pointerEvents = 'auto';
        menu.style.transform = 'translateY(0)';
        isMenuOpen = true;
      }

      // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’éè¡¨ç¤ºã«ã™ã‚‹é–¢æ•°
      function hideMenu() {
        if (hideTimer) {
          clearTimeout(hideTimer);
          hideTimer = null;
        }
        menu.style.opacity = '0';
        menu.style.visibility = 'hidden';
        menu.style.pointerEvents = 'none';
        menu.style.transform = 'translateY(-10px)';
        isMenuOpen = false;
      }

      // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ãƒˆã‚°ãƒ«ã™ã‚‹é–¢æ•°ï¼ˆã‚¯ãƒªãƒƒã‚¯æ™‚ï¼‰
      function toggleMenu() {
        if (isMenuOpen) {
          hideMenu();
        } else {
          showMenu();
        }
      }

      // ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
      if (categoryButton) {
        categoryButton.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleMenu();
        });
      }

      // ãƒ¡ãƒ‹ãƒ¥ãƒ¼è‡ªä½“ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒå…¥ã£ãŸæ™‚ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼å†…ã‚’ç§»å‹•ã™ã‚‹éš›ã«éè¡¨ç¤ºã«ãªã‚‰ãªã„ã‚ˆã†ã«ï¼‰
      if (menu) {
        menu.addEventListener('mouseenter', () => {
          if (isMenuOpen) {
            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒé–‹ã„ã¦ã„ã‚‹æ™‚ã®ã¿ã€ãƒã‚¦ã‚¹ãŒå…¥ã£ãŸã‚‰è¡¨ç¤ºã‚’ç¶­æŒ
            if (hideTimer) {
              clearTimeout(hideTimer);
              hideTimer = null;
            }
          }
        });
        menu.addEventListener('mouseleave', () => {
          // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ãƒã‚¦ã‚¹ãŒé›¢ã‚ŒãŸã‚‰é–‰ã˜ã‚‹ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é–‹ã„ãŸå ´åˆã‚‚ï¼‰
          if (isMenuOpen) {
            hideMenu();
          }
        });
      }

      // ãƒ¡ãƒ‹ãƒ¥ãƒ¼å¤–ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰é–‰ã˜ã‚‹
      document.addEventListener('click', (e) => {
        if (isMenuOpen && 
            !menu.contains(e.target) && 
            !categoryButton.contains(e.target)) {
          hideMenu();
        }
      });

      // ãƒªã‚µã‚¤ã‚º/ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ™‚ã«ã‚‚ä½ç½®ã‚’æ›´æ–°
      window.addEventListener('resize', () => {
        if (menu && menu.style.visibility !== 'hidden') {
          positionCategoryMenu();
        }
      });

      window.addEventListener('scroll', () => {
        if (menu && menu.style.visibility !== 'hidden') {
          positionCategoryMenu();
        }
      }, { passive: true });
    }

    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ™‚ã«ãƒ˜ãƒƒãƒ€ãƒ¼ã«æ¤œç´¢æ¬„ã‚’è¡¨ç¤º
    function initHeaderSearch() {
      const header = document.getElementById('main-header');
      const headerSearch = document.getElementById('header-search');
      const heroSearchForm = document.getElementById('main-search-form');
      const headerSearchForm = headerSearch?.querySelector('.header-search-form');
      const heroSearchInput = document.getElementById('search-query');
      const headerSearchInput = headerSearch?.querySelector('.header-search-input');

      if (!header || !headerSearch || !heroSearchForm || !headerSearchForm) return;

      // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆ
      window.addEventListener('scroll', () => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ãŸã‚‰æ¤œç´¢æ¬„ã‚’è¡¨ç¤º
        if (scrollTop > 100) {
          headerSearch.style.display = 'flex';
          header.classList.add('scrolled');
        } else {
          headerSearch.style.display = 'none';
          header.classList.remove('scrolled');
        }
      }, { passive: true });

      // æ¤œç´¢å…¥åŠ›ã®åŒæœŸï¼ˆãƒ’ãƒ¼ãƒ­ãƒ¼ã¨ãƒ˜ãƒƒãƒ€ãƒ¼ï¼‰
      if (heroSearchInput && headerSearchInput) {
        heroSearchInput.addEventListener('input', (e) => {
          headerSearchInput.value = e.target.value;
        });
        headerSearchInput.addEventListener('input', (e) => {
          heroSearchInput.value = e.target.value;
        });
      }

      // ãƒ˜ãƒƒãƒ€ãƒ¼ã®ã‚«ãƒ†ã‚´ãƒªãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ã«ã‚‚ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
      const headerCategoryButton = document.getElementById('header-category-menu-button');
      if (headerCategoryButton) {
        // ã‚«ãƒ†ã‚´ãƒªãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®åˆæœŸåŒ–ã‚’å¾…ã¤
        setTimeout(() => {
          const menu = document.querySelector('.category-menu');
          if (menu) {
            let hideTimer = null;
            let isMenuOpen = false; // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®é–‹é–‰çŠ¶æ…‹ã‚’ç®¡ç†

            function showMenu() {
              if (hideTimer) {
                clearTimeout(hideTimer);
                hideTimer = null;
              }
              const btnRect = headerCategoryButton.getBoundingClientRect();
              menu.style.top = `${btnRect.bottom + 8}px`;
              menu.style.left = `${btnRect.left}px`;
              menu.style.opacity = '1';
              menu.style.visibility = 'visible';
              menu.style.pointerEvents = 'auto';
              menu.style.transform = 'translateY(0)';
              isMenuOpen = true;
            }

            function hideMenu() {
              if (hideTimer) {
                clearTimeout(hideTimer);
                hideTimer = null;
              }
              menu.style.opacity = '0';
              menu.style.visibility = 'hidden';
              menu.style.pointerEvents = 'none';
              menu.style.transform = 'translateY(-10px)';
              isMenuOpen = false;
            }

            function toggleMenu() {
              if (isMenuOpen) {
                hideMenu();
              } else {
                showMenu();
              }
            }

            // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            headerCategoryButton.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              toggleMenu();
            });
            
            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼è‡ªä½“ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒå…¥ã£ãŸæ™‚ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒé–‹ã„ã¦ã„ã‚‹æ™‚ã®ã¿è¡¨ç¤ºã‚’ç¶­æŒï¼‰
            menu.addEventListener('mouseenter', () => {
              if (isMenuOpen) {
                if (hideTimer) {
                  clearTimeout(hideTimer);
                  hideTimer = null;
                }
              }
            });
            
            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ãƒã‚¦ã‚¹ãŒé›¢ã‚ŒãŸã‚‰é–‰ã˜ã‚‹
            menu.addEventListener('mouseleave', () => {
              if (isMenuOpen) {
                hideMenu();
              }
            });

            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼å¤–ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰é–‰ã˜ã‚‹
            document.addEventListener('click', (e) => {
              if (isMenuOpen && 
                  !menu.contains(e.target) && 
                  !headerCategoryButton.contains(e.target)) {
                hideMenu();
              }
            });
          }
        }, 100);
      }
    }

    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å¾Œã«åˆæœŸåŒ–
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initHeaderSearch();
      });
    } else {
      initHeaderSearch();
    }


    // æ¤œç´¢å‡¦ç†
    function handleSearch(event) {
      event.preventDefault();
      const formData = new FormData(event.target);
      const params = {
        q: formData.get('q') || '',
        category: formData.get('category') || '',
        date: formData.get('date') || '',
        area: formData.get('area') || ''
      };
      URLManager.setParams(params);
      window.location.href = `list.html?${new URLSearchParams(params).toString()}`;
    }

    // æ›œæ—¥æ¤œç´¢
    function searchByWeekday(weekday) {
      window.location.href = `list.html?weekday=${weekday}`;
    }

    // é€±ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆ0=ä»Šé€±ã€1=æ¬¡é€±ã€-1=å…ˆé€±ãªã©ï¼‰
    let weekOffset = 0;

    // å½“æ—¥å§‹ã¾ã‚Šã®1é€±é–“åˆ†ã‚’è¡¨ç¤ºï¼ˆæ¬¡é€±ãƒœã‚¿ãƒ³ã§ã‚¹ãƒ©ã‚¤ãƒ‰å…¥ã‚Œæ›¿ãˆï¼‰
    function renderWeekCalendar(offset = 0) {
      const container = document.getElementById('week-calendar');
      if (!container) return;

      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // å½“æ—¥å§‹ã¾ã‚Šã®1é€±é–“åˆ†ã‚’å–å¾—ï¼ˆoffset=0ãªã‚‰ä»Šæ—¥ã‹ã‚‰7æ—¥é–“ã€offset=1ãªã‚‰8æ—¥ç›®ã‹ã‚‰14æ—¥é–“ï¼‰
      const startDate = new Date(today);
      startDate.setDate(today.getDate() + (offset * 7));

      const weekDays = [];
      for (let i = 0; i < 7; i++) {
        const date = new Date(startDate);
        date.setDate(startDate.getDate() + i);
        weekDays.push(date);
      }

      // å„æ—¥ã®ã‚¤ãƒ™ãƒ³ãƒˆæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
      const eventCounts = {};
      weekDays.forEach(date => {
        const dateStr = date.toISOString().split('T')[0];
        const count = (window.eventData?.events || []).filter(event =>
          event.dates && Array.isArray(event.dates) && event.dates.some(d => d.date === dateStr)
        ).length;
        eventCounts[dateStr] = count;
      });

      // ä»Šæ—¥ã®æ—¥ä»˜æ–‡å­—åˆ—
      const todayStr = today.toISOString().split('T')[0];

      // æ›œæ—¥å
      const weekDayNames = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];

      // ãƒªã‚¹ãƒˆç”Ÿæˆ
      let html = '<div class="week-calendar-list">';

      weekDays.forEach(date => {
        const dateStr = date.toISOString().split('T')[0];
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const dayIndex = date.getDay(); // 0=æ—¥æ›œæ—¥, 1=æœˆæ›œæ—¥, ..., 6=åœŸæ›œæ—¥
        const dayName = weekDayNames[dayIndex];
        const count = eventCounts[dateStr] || 0;
        const isToday = dateStr === todayStr;
        const hasEvents = count > 0;

        let itemClass = 'week-day-item';
        if (isToday) itemClass += ' today';
        if (hasEvents) itemClass += ' has-events';

        html += `<div class="${itemClass}" onclick="goToDateEvents('${dateStr}')">`;
        html += `<span class="week-day-date">${month}/${day}</span>`;
        html += `<span class="week-day-name">${dayName}</span>`;
        if (hasEvents) {
          html += `<span class="week-day-count">${count}ä»¶</span>`;
        }
        html += `</div>`;
      });

      html += '</div>';
      
      // ã‚¹ãƒ©ã‚¤ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
      container.classList.add('week-calendar-sliding');
      setTimeout(() => {
        container.classList.remove('week-calendar-sliding');
      }, 300);
      
      container.innerHTML = html;

      // æ¬¡é€±ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°
      const nextWeekBtn = document.getElementById('next-week-btn');
      if (nextWeekBtn) {
        if (offset === 0) {
          nextWeekBtn.textContent = 'â†’';
          nextWeekBtn.onclick = () => showNextWeek();
        } else {
          nextWeekBtn.textContent = 'â†';
          nextWeekBtn.onclick = () => showThisWeek();
        }
      }
    }

    // æ¬¡é€±ã‚’è¡¨ç¤º
    function showNextWeek() {
      weekOffset = 1;
      renderWeekCalendar(weekOffset);
    }

    // ä»Šé€±ã‚’è¡¨ç¤º
    function showThisWeek() {
      weekOffset = 0;
      renderWeekCalendar(weekOffset);
    }

    // æ—¥ä»˜ã‚¯ãƒªãƒƒã‚¯ã§ã‚¤ãƒ™ãƒ³ãƒˆä¸€è¦§ã«é·ç§»
    function goToDateEvents(dateStr) {
      window.location.href = `list.html?date=${dateStr}`;
    }

    // 2ç‚¹é–“ã®è·é›¢ã‚’è¨ˆç®—ï¼ˆHaversine formulaï¼‰
    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 6371; // åœ°çƒã®åŠå¾„ï¼ˆkmï¼‰
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = 
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c; // è·é›¢ï¼ˆkmï¼‰
    }

    // éƒ½é“åºœçœŒã®å¸‚åŒºç”ºæ‘ãƒ‡ãƒ¼ã‚¿ï¼ˆåº§æ¨™ä»˜ãï¼‰
    const prefectureCities = {
      'tokyo': [
        { name: 'ä¸–ç”°è°·åŒº', area: 'ä¸–ç”°è°·åŒº', lat: 35.6466, lng: 139.6533, hasSubAreas: true },
        { name: 'æ¸‹è°·åŒº', area: 'æ¸‹è°·åŒº', lat: 35.6580, lng: 139.7016, hasSubAreas: false },
        { name: 'æ–°å®¿åŒº', area: 'æ–°å®¿åŒº', lat: 35.6938, lng: 139.7034, hasSubAreas: false },
        { name: 'æ¸¯åŒº', area: 'æ¸¯åŒº', lat: 35.6586, lng: 139.7514, hasSubAreas: false },
        { name: 'ç›®é»’åŒº', area: 'ç›®é»’åŒº', lat: 35.6414, lng: 139.6982, hasSubAreas: false },
        { name: 'å“å·åŒº', area: 'å“å·åŒº', lat: 35.6156, lng: 139.7302, hasSubAreas: false },
        { name: 'å¤§ç”°åŒº', area: 'å¤§ç”°åŒº', lat: 35.5614, lng: 139.7161, hasSubAreas: false },
        { name: 'æ‰ä¸¦åŒº', area: 'æ‰ä¸¦åŒº', lat: 35.6995, lng: 139.6364, hasSubAreas: false },
        { name: 'ä¸­é‡åŒº', area: 'ä¸­é‡åŒº', lat: 35.7075, lng: 139.6639, hasSubAreas: false },
        { name: 'ç·´é¦¬åŒº', area: 'ç·´é¦¬åŒº', lat: 35.7356, lng: 139.6517, hasSubAreas: false },
        { name: 'æ¿æ©‹åŒº', area: 'æ¿æ©‹åŒº', lat: 35.7514, lng: 139.7095, hasSubAreas: false },
        { name: 'åŒ—åŒº', area: 'åŒ—åŒº', lat: 35.7528, lng: 139.7336, hasSubAreas: false },
        { name: 'è¶³ç«‹åŒº', area: 'è¶³ç«‹åŒº', lat: 35.7756, lng: 139.8047, hasSubAreas: false },
        { name: 'è‘›é£¾åŒº', area: 'è‘›é£¾åŒº', lat: 35.7434, lng: 139.8471, hasSubAreas: false },
        { name: 'æ±Ÿæˆ¸å·åŒº', area: 'æ±Ÿæˆ¸å·åŒº', lat: 35.7067, lng: 139.8683, hasSubAreas: false },
        { name: 'å¢¨ç”°åŒº', area: 'å¢¨ç”°åŒº', lat: 35.7106, lng: 139.8015, hasSubAreas: false },
        { name: 'å°æ±åŒº', area: 'å°æ±åŒº', lat: 35.7126, lng: 139.7802, hasSubAreas: false },
        { name: 'ä¸­å¤®åŒº', area: 'ä¸­å¤®åŒº', lat: 35.6719, lng: 139.7659, hasSubAreas: false },
        { name: 'åƒä»£ç”°åŒº', area: 'åƒä»£ç”°åŒº', lat: 35.6940, lng: 139.7536, hasSubAreas: false },
        { name: 'æ–‡äº¬åŒº', area: 'æ–‡äº¬åŒº', lat: 35.7078, lng: 139.7523, hasSubAreas: false },
        { name: 'è±Šå³¶åŒº', area: 'è±Šå³¶åŒº', lat: 35.7262, lng: 139.7158, hasSubAreas: false },
        { name: 'è’å·åŒº', area: 'è’å·åŒº', lat: 35.7364, lng: 139.7833, hasSubAreas: false },
        { name: 'å…«ç‹å­å¸‚', area: 'å…«ç‹å­å¸‚', lat: 35.6558, lng: 139.3439, hasSubAreas: false },
        { name: 'ç«‹å·å¸‚', area: 'ç«‹å·å¸‚', lat: 35.6938, lng: 139.4133, hasSubAreas: false },
        { name: 'æ­¦è”µé‡å¸‚', area: 'æ­¦è”µé‡å¸‚', lat: 35.7177, lng: 139.5663, hasSubAreas: false },
        { name: 'ä¸‰é·¹å¸‚', area: 'ä¸‰é·¹å¸‚', lat: 35.7026, lng: 139.5603, hasSubAreas: false },
        { name: 'é’æ¢…å¸‚', area: 'é’æ¢…å¸‚', lat: 35.7906, lng: 139.2581, hasSubAreas: false },
        { name: 'å¥¥å¤šæ‘©ç”º', area: 'å¥¥å¤šæ‘©ç”º', lat: 35.8097, lng: 139.1494, hasSubAreas: false }
      ],
      'kanagawa': [
        { name: 'æ¨ªæµœå¸‚', area: 'æ¨ªæµœå¸‚', lat: 35.4437, lng: 139.6380, hasSubAreas: false },
        { name: 'å·å´å¸‚', area: 'å·å´å¸‚', lat: 35.5309, lng: 139.7030, hasSubAreas: false },
        { name: 'ç›¸æ¨¡åŸå¸‚', area: 'ç›¸æ¨¡åŸå¸‚', lat: 35.5715, lng: 139.3735, hasSubAreas: false },
        { name: 'éŒå€‰å¸‚', area: 'éŒå€‰å¸‚', lat: 35.3192, lng: 139.5467, hasSubAreas: false },
        { name: 'è—¤æ²¢å¸‚', area: 'è—¤æ²¢å¸‚', lat: 35.3389, lng: 139.4874, hasSubAreas: false },
        { name: 'èŒ…ãƒ¶å´å¸‚', area: 'èŒ…ãƒ¶å´å¸‚', lat: 35.3274, lng: 139.4077, hasSubAreas: false },
        { name: 'åšæœ¨å¸‚', area: 'åšæœ¨å¸‚', lat: 35.4427, lng: 139.3781, hasSubAreas: false },
        { name: 'å°ç”°åŸå¸‚', area: 'å°ç”°åŸå¸‚', lat: 35.2564, lng: 139.1547, hasSubAreas: false }
      ],
      'saitama': [
        { name: 'ã•ã„ãŸã¾å¸‚', area: 'ã•ã„ãŸã¾å¸‚', lat: 35.8617, lng: 139.6455, hasSubAreas: false },
        { name: 'å·è¶Šå¸‚', area: 'å·è¶Šå¸‚', lat: 35.9251, lng: 139.4858, hasSubAreas: false },
        { name: 'æ‰€æ²¢å¸‚', area: 'æ‰€æ²¢å¸‚', lat: 35.7876, lng: 139.4733, hasSubAreas: false },
        { name: 'è¶Šè°·å¸‚', area: 'è¶Šè°·å¸‚', lat: 35.8886, lng: 139.7908, hasSubAreas: false },
        { name: 'å·å£å¸‚', area: 'å·å£å¸‚', lat: 35.8006, lng: 139.7208, hasSubAreas: false }
      ],
      'chiba': [
        { name: 'åƒè‘‰å¸‚', area: 'åƒè‘‰å¸‚', lat: 35.6074, lng: 140.1065, hasSubAreas: false },
        { name: 'èˆ¹æ©‹å¸‚', area: 'èˆ¹æ©‹å¸‚', lat: 35.6955, lng: 139.9826, hasSubAreas: false },
        { name: 'æ¾æˆ¸å¸‚', area: 'æ¾æˆ¸å¸‚', lat: 35.7874, lng: 139.9018, hasSubAreas: false },
        { name: 'å¸‚å·å¸‚', area: 'å¸‚å·å¸‚', lat: 35.7219, lng: 139.9317, hasSubAreas: false },
        { name: 'æŸå¸‚', area: 'æŸå¸‚', lat: 35.8617, lng: 139.9711, hasSubAreas: false }
      ],
      'ibaraki': [
        { name: 'æ°´æˆ¸å¸‚', area: 'æ°´æˆ¸å¸‚', lat: 36.3414, lng: 140.4467, hasSubAreas: false },
        { name: 'ã¤ãã°å¸‚', area: 'ã¤ãã°å¸‚', lat: 36.0836, lng: 140.0764, hasSubAreas: false },
        { name: 'æ—¥ç«‹å¸‚', area: 'æ—¥ç«‹å¸‚', lat: 36.5991, lng: 140.6517, hasSubAreas: false }
      ],
      'tochigi': [
        { name: 'å®‡éƒ½å®®å¸‚', area: 'å®‡éƒ½å®®å¸‚', lat: 36.5658, lng: 139.8836, hasSubAreas: false },
        { name: 'è¶³åˆ©å¸‚', area: 'è¶³åˆ©å¸‚', lat: 36.3077, lng: 139.4506, hasSubAreas: false },
        { name: 'æ ƒæœ¨å¸‚', area: 'æ ƒæœ¨å¸‚', lat: 36.3143, lng: 139.5783, hasSubAreas: false }
      ],
      'gunma': [
        { name: 'å‰æ©‹å¸‚', area: 'å‰æ©‹å¸‚', lat: 36.3911, lng: 139.0608, hasSubAreas: false },
        { name: 'é«˜å´å¸‚', area: 'é«˜å´å¸‚', lat: 36.3227, lng: 139.0124, hasSubAreas: false },
        { name: 'å¤ªç”°å¸‚', area: 'å¤ªç”°å¸‚', lat: 36.2943, lng: 139.3786, hasSubAreas: false }
      ],
      'yamanashi': [
        { name: 'ç”²åºœå¸‚', area: 'ç”²åºœå¸‚', lat: 35.6636, lng: 138.5684, hasSubAreas: false },
        { name: 'å¯Œå£«å‰ç”°å¸‚', area: 'å¯Œå£«å‰ç”°å¸‚', lat: 35.4928, lng: 138.8070, hasSubAreas: false }
      ]
    };

    // ã‚¤ãƒ™ãƒ³ãƒˆæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹é–¢æ•°ï¼ˆåœ°åã¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ­£ç¢ºã«ç´ã¥ã‘ã‚‹ï¼‰
    async function countEventsByArea(area) {
      let source = Array.isArray(window.eventIndex) && window.eventIndex.length > 0
        ? window.eventIndex
        : (Array.isArray(window.eventData?.events) ? window.eventData.events : []);
      
      if (source.length === 0) return 0;
      
      const count = source.filter(event => {
        const eventArea = (event.area || event.city || event.prefecture || '').trim();
        const searchArea = area.trim();
        
        if (!eventArea || !searchArea) return false;
        
        // å®Œå…¨ä¸€è‡´ã‚’æœ€å„ªå…ˆ
        if (eventArea === searchArea) return true;
        
        // éƒ¨åˆ†ä¸€è‡´ã®ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚Šå³å¯†ã«ï¼‰
        // ã€Œä¸–ç”°è°·åŒºã€ã§æ¤œç´¢ã™ã‚‹å ´åˆã€ã€Œä¸–ç”°è°·åŒº ä¸–ç”°è°·ã€ã¯é™¤å¤–
        if (eventArea.includes(searchArea)) {
          // éƒ½é“åºœçœŒåï¼ˆã€Œéƒ½ã€ã€Œåºœã€ã€ŒçœŒã€ã§çµ‚ã‚ã‚‹ï¼‰ã®å ´åˆã¯éƒ¨åˆ†ä¸€è‡´ã‚‚è¨±å¯
          if (searchArea.endsWith('éƒ½') || searchArea.endsWith('åºœ') || searchArea.endsWith('çœŒ')) {
            return true;
          }
          
          // å¸‚åŒºç”ºæ‘åï¼ˆã€ŒåŒºã€ã€Œå¸‚ã€ã€Œç”ºã€ã€Œæ‘ã€ã§çµ‚ã‚ã‚‹ï¼‰ã®å ´åˆã¯å³å¯†ã«ãƒã‚§ãƒƒã‚¯
          if (searchArea.endsWith('åŒº') || searchArea.endsWith('å¸‚') || searchArea.endsWith('ç”º') || searchArea.endsWith('æ‘')) {
            // ã€Œä¸–ç”°è°·åŒºã€ã§å§‹ã¾ã‚‹å ´åˆã¯ä¸€è‡´ï¼ˆã€Œä¸–ç”°è°·åŒº ä¸–ç”°è°·ã€ã¯é™¤å¤–ï¼‰
            if (eventArea.startsWith(searchArea)) {
              // ã‚¹ãƒšãƒ¼ã‚¹ã‚„ãã®ä»–ã®æ–‡å­—ãŒç¶šãå ´åˆã¯é™¤å¤–
              const nextChar = eventArea[searchArea.length];
              if (!nextChar || nextChar === ' ' || nextChar === 'ã€€') {
                return true;
              }
            }
            // ã€Œä¸–ç”°è°·åŒºã€ã‚’å«ã‚€ãŒã€å‰ã«æ–‡å­—ãŒã‚ã‚‹å ´åˆã¯é™¤å¤–ï¼ˆä¾‹ï¼šã€Œæ±äº¬éƒ½ä¸–ç”°è°·åŒºã€ã¯ã€Œä¸–ç”°è°·åŒºã€ã«ä¸€è‡´ï¼‰
            const index = eventArea.indexOf(searchArea);
            if (index > 0) {
              const beforeChar = eventArea[index - 1];
              // å‰ã®æ–‡å­—ãŒéƒ½é“åºœçœŒåã®ä¸€éƒ¨ã§ãªã„å ´åˆã¯ä¸€è‡´
              if (beforeChar !== 'éƒ½' && beforeChar !== 'åºœ' && beforeChar !== 'çœŒ') {
                return false;
              }
            }
            return false;
          }
          
          // ãã®ä»–ã®å ´åˆã¯éƒ¨åˆ†ä¸€è‡´ã‚’è¨±å¯
          return true;
        }
        
        return false;
      }).length;
      
      return count;
    }
    
    // ãƒãƒ¼ã‚«ãƒ¼ã®ä½ç½®ã‚’èª¿æ•´ã—ã¦é‡è¤‡ã‚’é˜²ãé–¢æ•°
    function adjustMarkerPositions(markers, minDistance = 0.01) {
      if (!markers || markers.length === 0) return;
      
      // è·é›¢ãŒè¿‘ã„ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¤œå‡ºã—ã¦ä½ç½®ã‚’èª¿æ•´
      for (let i = 0; i < markers.length; i++) {
        for (let j = i + 1; j < markers.length; j++) {
          try {
            const pos1 = markers[i].getPosition();
            const pos2 = markers[j].getPosition();
            
            if (!pos1 || !pos2) continue;
            
            const lat1 = pos1.lat();
            const lng1 = pos1.lng();
            const lat2 = pos2.lat();
            const lng2 = pos2.lng();
            
            const latDiff = Math.abs(lat1 - lat2);
            const lngDiff = Math.abs(lng1 - lng2);
            const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
            
            // è·é›¢ãŒè¿‘ã™ãã‚‹å ´åˆã€ä½ç½®ã‚’èª¿æ•´
            if (distance < minDistance) {
              // 2ã¤ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’å¯¾è§’ç·šä¸Šã«å°‘ã—ãšã‚‰ã™
              const offset = (minDistance - distance) / 2 + 0.001;
              const angle = Math.atan2(lat2 - lat1, lng2 - lng1);
              
              // ãƒãƒ¼ã‚«ãƒ¼1ã‚’å·¦ä¸Šã«ã€ãƒãƒ¼ã‚«ãƒ¼2ã‚’å³ä¸‹ã«ãšã‚‰ã™
              const newLat1 = lat1 - Math.sin(angle) * offset;
              const newLng1 = lng1 - Math.cos(angle) * offset;
              const newLat2 = lat2 + Math.sin(angle) * offset;
              const newLng2 = lng2 + Math.cos(angle) * offset;
              
              markers[i].setPosition({ lat: newLat1, lng: newLng1 });
              markers[j].setPosition({ lat: newLat2, lng: newLng2 });
            }
          } catch (e) {
            console.warn('[adjustMarkerPositions] Error adjusting marker position:', e);
          }
        }
      }
    }

    // åœ°å›³ã‹ã‚‰æ¢ã™æ©Ÿèƒ½ã®åˆæœŸåŒ–
    function initMapSearch() {
      const citiesList = document.getElementById('map-cities-list');
      const citiesGrid = document.getElementById('map-cities-grid');
      const citiesTitle = document.getElementById('map-cities-title');
      const backButton = document.getElementById('map-back-button');
      const svgContainer = document.getElementById('map-svg-container');
      
      // æˆ»ã‚‹ãƒœã‚¿ãƒ³ã®å‡¦ç†ï¼ˆå¸‚åŒºç”ºæ‘ãƒªã‚¹ãƒˆã‹ã‚‰éƒ½é“åºœçœŒåœ°å›³ã«æˆ»ã‚‹ï¼‰
      if (backButton) {
        backButton.addEventListener('click', () => {
          citiesList.style.display = 'none';
          if (svgContainer) svgContainer.style.display = 'block';
          // é–¢æ±åœ°æ–¹ã®åœ°å›³ã‚’å†è¡¨ç¤º
          createKantoSVGMap();
        });
      }
      
      // é–¢æ±åœ°æ–¹ã®SVGåœ°å›³ã‚’åˆæœŸåŒ–ï¼ˆDOMContentLoadedã§å®Ÿè¡Œï¼‰
      if (document.readyState === 'loading') {
        window.addEventListener('DOMContentLoaded', () => {
          createKantoSVGMap();
        });
      } else {
        // DOMãŒæ—¢ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯å³åº§ã«å®Ÿè¡Œ
        createKantoSVGMap();
      }
      
      // ã€Œè¿‘ãã‹ã‚‰æ¢ã™ã€ãƒœã‚¿ãƒ³ã®å‡¦ç†
      const nearbyButton = document.getElementById('map-nearby-button');
      
      if (nearbyButton) {
        nearbyButton.addEventListener('click', () => {
          // ä½ç½®æƒ…å ±ã‚’å–å¾—
          if (!navigator.geolocation) {
            alert('ä½ç½®æƒ…å ±ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
            return;
          }
          
          nearbyButton.disabled = true;
          nearbyButton.innerHTML = '<span class="map-nearby-icon">ğŸ“</span><span>ä½ç½®æƒ…å ±ã‚’å–å¾—ä¸­...</span>';
          
          navigator.geolocation.getCurrentPosition(
            async (position) => {
              const lat = position.coords.latitude;
              const lng = position.coords.longitude;
              
              // åœ°å›³è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
              if (citiesList) citiesList.style.display = 'none';
              if (googleMapContainer) {
                googleMapContainer.style.display = 'block';
                // Google Mapsã‚’åˆæœŸåŒ–ï¼ˆç¾åœ¨åœ°å‘¨è¾ºï¼‰
                initNearbyMap(lat, lng, googleMapContainer);
              }
              
              nearbyButton.disabled = false;
              nearbyButton.innerHTML = '<span class="map-nearby-icon">ğŸ“</span><span>è¿‘ãã‹ã‚‰æ¢ã™</span>';
            },
            (error) => {
              alert('ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
              nearbyButton.disabled = false;
              nearbyButton.innerHTML = '<span class="map-nearby-icon">ğŸ“</span><span>è¿‘ãã‹ã‚‰æ¢ã™</span>';
            },
            {
              enableHighAccuracy: true,
              timeout: 20000,
              maximumAge: 0
            }
          );
        });
      }
    }
    
    // TopoJSONãƒ‡ãƒ¼ã‚¿ã®è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ï¼ˆcreateKantoSVGMapã‚ˆã‚Šå‰ã«å®šç¾©ï¼‰
    async function loadTopoJson(primaryUrl, fallbackUrl) {
      try {
        const r = await fetch(primaryUrl, { cache: "no-store" });
        if (!r.ok) throw new Error(`primary fetch failed: ${r.status}`);
        return await r.json();
      } catch (e) {
        console.warn("[Topo] primary failed -> fallback", e);
        const r2 = await fetch(fallbackUrl, { cache: "no-store" });
        if (!r2.ok) throw new Error(`fallback fetch failed: ${r2.status}`);
        return await r2.json();
      }
    }
    
    // äºŒé‡å®Ÿè¡Œé˜²æ­¢ã®ã‚¬ãƒ¼ãƒ‰
    let kantoMapRendered = false;
    let kantoMapData = null; // åœ°å›³ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼ˆãƒªã‚µã‚¤ã‚ºæ™‚ã«å†æç”»ç”¨ï¼‰
    let resizeObserver = null; // ResizeObserverã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    
    // åœ°å›³ä»¥å¤–ã®SVGç”Ÿæˆã‚’ä¸€æ™‚åœæ­¢ã™ã‚‹ãƒ•ãƒ©ã‚°ï¼ˆåœ°å›³ã ã‘ã«é›†ä¸­ã™ã‚‹ãŸã‚ï¼‰
    const DISABLE_OTHER_SVG_GENERATION = true;
    
    // â˜…é›¢å³¶é™¤å¤–å‡¦ç†ï¼ˆæœ¬åœŸã ã‘ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ï¼‰
    // é–¢æ±æœ¬åœŸã®ã ã„ãŸã„ã®ç¯„å›²ï¼ˆå°‘ã—åºƒã‚ã«ï¼‰
    // lon: 138ã€œ141.5 / lat: 34ã€œ37.5
    const MAINLAND_BBOX = [[138.0, 34.0], [141.5, 37.5]];
    
    // boundsãŒæœ¬åœŸBBoxã¨äº¤å·®ã—ã¦ã‚‹ã‹
    function intersectsBbox(bounds, bbox) {
      const [[minX, minY], [maxX, maxY]] = bounds;
      const [[bx0, by0], [bx1, by1]] = bbox;
      return !(maxX < bx0 || minX > bx1 || maxY < by0 || minY > by1);
    }
    
    // Featureï¼ˆPolygon/MultiPolygonï¼‰ã‹ã‚‰æœ¬åœŸBBoxã«ã‹ã‹ã‚‹ãƒãƒªã‚´ãƒ³ã ã‘æ®‹ã™
    function keepMainlandPolygons(feature, bbox = MAINLAND_BBOX) {
      if (!feature?.geometry) return feature;
      
      const g = feature.geometry;
      
      if (g.type === "Polygon") {
        const b = d3.geoBounds(feature);
        return intersectsBbox(b, bbox) ? feature : null;
      }
      
      if (g.type === "MultiPolygon") {
        // MultiPolygonã‚’ Polygonã”ã¨ã«åˆ†è§£ã—ã¦åˆ¤å®š
        const kept = g.coordinates.filter((polyCoords) => {
          const polyFeature = { type: "Feature", geometry: { type: "Polygon", coordinates: polyCoords } };
          const b = d3.geoBounds(polyFeature);
          return intersectsBbox(b, bbox);
        });
        
        if (!kept.length) return null;
        
        return {
          ...feature,
          geometry: { type: "MultiPolygon", coordinates: kept }
        };
      }
      
      return feature;
    }
    
    // æç”»ãƒ­ã‚¸ãƒƒã‚¯ã‚’åˆ†é›¢ï¼ˆãƒªã‚µã‚¤ã‚ºæ™‚ã«ã‚‚å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ï¼‰
    function renderKantoMap(kantoFeatures, eventCountByAreaKey, areaKeyByName, getNameJa) {
      const svg = d3.select("#kantoMap");
      const container = document.getElementById("map-svg-container");
      if (!container) {
        console.error('[renderKantoMap] Container not found');
        return;
      }
      
      // SVGã‚’ã‚¯ãƒªã‚¢
      svg.selectAll("*").remove();
      
      // â˜…ã‚³ãƒ³ãƒ†ãƒŠã®ã‚µã‚¤ã‚ºã‚’å‹•çš„ã«å–å¾—ï¼ˆé‡è¦ï¼ï¼‰
      const { width, height } = container.getBoundingClientRect();
      
      // â˜…SVGè¦ç´ ã®ã‚µã‚¤ã‚ºã¨viewBoxã‚’è¨­å®šï¼ˆé‡è¦ï¼ï¼‰
      svg
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet");
      
      const SHOW_ZERO = false;
      
      // â˜…é–¢æ±ã ã‘ã®FeatureCollectionã‚’ä½œæˆï¼ˆãƒ•ã‚£ãƒ«ã‚¿å¾Œï¼‰
      const kantoGeoJson = {
        type: "FeatureCollection",
        features: kantoFeatures
      };
      
      // SVGã«ãƒ•ã‚£ãƒƒãƒˆï¼ˆfitExtentã§æ„å›³çš„ãªä½™ç™½ã‚’å…¥ã‚Œã‚‹ï¼‰
      const projection = d3.geoMercator();
      // ä½™ç™½ã‚’"æ„å›³ã—ã¦"å…¥ã‚Œã‚‹ï¼ˆã˜ã‚ƒã‚‰ã‚“ã¯ã‚®ãƒã‚®ãƒã«ã—ãªã„ï¼‰
      const pad = 12;
      projection.fitExtent(
        [[pad, pad], [width - pad, height - pad]],
        kantoGeoJson
      );
      const path = d3.geoPath().projection(projection);
      
      // èƒŒæ™¯
      svg.append("rect")
        .attr("width", width)
        .attr("height", height)
        .attr("fill", "#eaf6f2");
      
      // çœŒãƒãƒªã‚´ãƒ³ï¼ˆå±æ€§ã‚’æ˜ç¤ºçš„ã«è¨­å®šã—ã¦è¦‹ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼‰
      svg.append("g")
        .selectAll("path")
        .data(kantoFeatures)
        .join("path")
          .attr("d", path)
          .attr("fill", "#e2f2ee")
          .attr("stroke", "#2aa58d")
          .attr("stroke-width", 2.5)
          .attr("opacity", 1)
          .style("fill", "#e2f2ee")
          .style("stroke", "#2aa58d")
          .style("stroke-width", "2.5px")
          .style("opacity", "1")
          .style("cursor", d => {
            const name = getNameJa(d.properties);
            const key = areaKeyByName[name];
            const c = eventCountByAreaKey[key] ?? 0;
            return (!SHOW_ZERO && c === 0) ? "not-allowed" : "pointer";
          })
          .on("mouseenter", function(e, d) {
            const name = getNameJa(d.properties);
            const key = areaKeyByName[name];
            const c = eventCountByAreaKey[key] ?? 0;
            if (SHOW_ZERO || c > 0) {
              d3.select(this)
                .attr("fill", "#c8e8dc")
                .attr("stroke-width", 3)
                .style("fill", "#c8e8dc")
                .style("stroke-width", "3px");
            }
          })
          .on("mouseleave", function(e, d) {
            d3.select(this)
              .attr("fill", "#e2f2ee")
              .attr("stroke-width", 2.5)
              .style("fill", "#e2f2ee")
              .style("stroke-width", "2.5px");
          })
          .on("click", async (e, d) => {
            const name = getNameJa(d.properties);
            const key = areaKeyByName[name];
            const c = eventCountByAreaKey[key] ?? 0;
            if (!SHOW_ZERO && c === 0) return;
            
            // å¸‚åŒºç”ºæ‘ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯å¸‚åŒºç”ºæ‘ãƒãƒƒãƒ—ã‚’è¡¨ç¤º
            const cities = prefectureCities[key];
            const citiesList = document.getElementById('map-cities-list');
            const svgContainer = document.getElementById('map-svg-container');
            
            if (cities && cities.length > 0 && citiesList && svgContainer) {
              // äºŒæ®µéšç›®ï¼šå¸‚åŒºç”ºæ‘ã®Google Mapsã‚’è¡¨ç¤º
              // Google Mapsç”¨ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
              const googleMapContainer = document.createElement('div');
              googleMapContainer.className = 'map-google-map';
              googleMapContainer.style.width = '100%';
              googleMapContainer.style.height = '500px';
              svgContainer.style.display = 'none';
              svgContainer.parentElement.appendChild(googleMapContainer);
              initCityMap(key, name, cities, googleMapContainer);
            } else {
              // ã‚¤ãƒ™ãƒ³ãƒˆä¸€è¦§ãƒšãƒ¼ã‚¸ã«é·ç§»
              window.location.href = `list.html?area=${encodeURIComponent(name)}`;
            }
          });
      
      // ãƒ©ãƒ™ãƒ«ï¼†ãƒãƒƒã‚¸ï¼ˆé‡å¿ƒã«ç½®ãï¼‰
      const labelG = svg.append("g");
      
      labelG.selectAll("g")
        .data(kantoFeatures)
        .join("g")
          .each(function(d) {
            const name = getNameJa(d.properties);
            const key = areaKeyByName[name];
            const c = eventCountByAreaKey[key] ?? 0;
            if (!SHOW_ZERO && c === 0) return;
            
            const [x, y] = path.centroid(d);
            const g = d3.select(this);
            
            // çœŒåï¼ˆéƒ½ãƒ»çœŒãƒ»åºœãƒ»é“ã‚’å‰Šé™¤ï¼‰
            const label = name.replace("éƒ½", "").replace("çœŒ", "").replace("åºœ", "").replace("é“", "");
            g.append("text")
              .attr("x", x)
              .attr("y", y - 8)
              .attr("text-anchor", "middle")
              .attr("dominant-baseline", "central")
              .attr("font-weight", 800)
              .attr("font-size", 18)
              .attr("fill", "#143a33")
              .text(label);
            
            // ä»¶æ•°ãƒãƒƒã‚¸
            g.append("circle")
              .attr("cx", x)
              .attr("cy", y + 12)
              .attr("r", 16)
              .attr("fill", "#0f7a63");
            
            g.append("text")
              .attr("x", x)
              .attr("y", y + 12)
              .attr("text-anchor", "middle")
              .attr("dominant-baseline", "central")
              .attr("font-weight", 900)
              .attr("font-size", 13)
              .attr("fill", "#fff")
              .text(c);
          });
    }
    
    // é–¢æ±åœ°æ–¹ã®SVGåœ°å›³ã‚’ä½œæˆï¼ˆTopoJSONä½¿ç”¨ï¼‰
    async function createKantoSVGMap(forceRerender = false) {
      // äºŒé‡å®Ÿè¡Œé˜²æ­¢ï¼ˆãƒªã‚µã‚¤ã‚ºæ™‚ã¯å†æç”»ã‚’è¨±å¯ï¼‰
      if (kantoMapRendered && !forceRerender) {
        console.log('[createKantoSVGMap] Already rendered, skipping...');
        return;
      }
      
      // ãƒ‡ãƒãƒƒã‚°ï¼šSVGè¦ç´ ã®å­˜åœ¨ç¢ºèª
      const svgElement = document.getElementById("kantoMap");
      console.log('[createKantoSVGMap] SVG element:', svgElement);
      
      if (!svgElement) {
        console.error('[createKantoSVGMap] SVG element not found!');
        setTimeout(() => createKantoSVGMap(), 100);
        return;
      }
      
      // ãƒ‡ãƒãƒƒã‚°ï¼šSVGãŒæç”»ã§ãã‚‹ã‹ç¢ºèªï¼ˆé–‹ç™ºæ™‚ã®ã¿æœ‰åŠ¹ï¼‰
      // æœ¬ç•ªã§ã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¦ãã ã•ã„
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        svgElement.innerHTML = `<rect x="0" y="0" width="900" height="700" fill="#cfeee6"></rect>
                                 <text x="40" y="80" font-size="48" font-weight="800" fill="#143a33">
                                   SVG OK
                                 </text>`;
        console.log('[createKantoSVGMap] SVG OK test rendered');
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      // d3ã¨topojson-clientãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
      if (typeof d3 === 'undefined') {
        console.warn('[createKantoSVGMap] d3 is not defined, retrying...');
        setTimeout(() => createKantoSVGMap(), 100);
        return;
      }
      
      const topojsonClient = window.topojson;
      if (!topojsonClient) {
        console.warn('[createKantoSVGMap] topojson is not defined, retrying...');
        console.warn('[createKantoSVGMap] Make sure topojson-client@3 is loaded from jsdelivr');
        setTimeout(() => createKantoSVGMap(), 100);
        return;
      }
      
      if (!topojsonClient.feature) {
        console.error('[createKantoSVGMap] topojson.feature is not available');
        console.error('[createKantoSVGMap] topojson object:', topojsonClient);
        return;
      }
      
      console.log('[createKantoSVGMap] d3 and topojson loaded');
      
      const svg = d3.select("#kantoMap");
      if (svg.empty()) {
        console.error('[createKantoSVGMap] d3.select failed!');
        setTimeout(() => createKantoSVGMap(), 100);
        return;
      }
      
      // SVGã‚’ã‚¯ãƒªã‚¢
      svg.selectAll("*").remove();
      
      // â˜…ã‚³ãƒ³ãƒ†ãƒŠã®ã‚µã‚¤ã‚ºã‚’å‹•çš„ã«å–å¾—ï¼ˆé‡è¦ï¼ï¼‰
      const container = document.getElementById("map-svg-container");
      if (!container) {
        console.error('[createKantoSVGMap] Container not found');
        return;
      }
      const { width, height } = container.getBoundingClientRect();
      
      // â˜…SVGè¦ç´ ã®ã‚µã‚¤ã‚ºã¨viewBoxã‚’è¨­å®šï¼ˆé‡è¦ï¼ï¼‰
      svg
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet");
      
      // é–¢æ±åœ°æ–¹ã®éƒ½é“åºœçœŒ
      const KANTO = new Set([
        "æ±äº¬éƒ½", "ç¥å¥ˆå·çœŒ", "åƒè‘‰çœŒ", "åŸ¼ç‰çœŒ", "èŒ¨åŸçœŒ", "æ ƒæœ¨çœŒ", "ç¾¤é¦¬çœŒ"
      ]);
      
      // ã‚¨ãƒªã‚¢keyå¯¾å¿œ
      const areaKeyByName = {
        "æ±äº¬éƒ½": "tokyo",
        "ç¥å¥ˆå·çœŒ": "kanagawa",
        "åƒè‘‰çœŒ": "chiba",
        "åŸ¼ç‰çœŒ": "saitama",
        "èŒ¨åŸçœŒ": "ibaraki",
        "æ ƒæœ¨çœŒ": "tochigi",
        "ç¾¤é¦¬çœŒ": "gunma"
      };
      
      try {
        // TopoJSONãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆè‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        console.log('[createKantoSVGMap] Fetching TopoJSON...');
        const topo = await loadTopoJson(
          "https://raw.githubusercontent.com/dataofjapan/land/master/japan.topojson",
          "/assets/maps/japan.topojson"
        );
        console.log('[createKantoSVGMap] TopoJSON loaded:', topo);
        
        if (!topo || !topo.objects) {
          throw new Error('Invalid TopoJSON data');
        }
        
        // topojsonã®objectsåã‚’å–å¾—
        const objKey = Object.keys(topo.objects)[0];
        console.log('[createKantoSVGMap] Using object key:', objKey);
        
        // topojson-clientã®featureé–¢æ•°ã‚’ä½¿ç”¨ï¼ˆscriptæ–¹å¼ã§èª­ã¿è¾¼ã¾ã‚ŒãŸå ´åˆï¼‰
        const topojsonClient = window.topojson;
        if (!topojsonClient || !topojsonClient.feature) {
          throw new Error('topojson.feature is not available. Make sure topojson-client is loaded.');
        }
        
        const geo = topojsonClient.feature(topo, topo.objects[objKey]);
        console.log('[createKantoSVGMap] GeoJSON converted:', geo);
        
        // æ—¥æœ¬èªåã‚’å–å¾—ï¼ˆé–¢æ±åˆ¤å®šã¨è¡¨ç¤ºã«ä½¿ç”¨ï¼‰
        const getNameJa = (p) => p?.nam_ja || p?.name_ja || p?.NAME_JA || "";
        
        // è‹±èªåã‚’å–å¾—ï¼ˆå¿…è¦ã«å¿œã˜ã¦ä½¿ç”¨ï¼‰
        const getNameEn = (p) => p?.nam || p?.name || "";
        
        // ãƒ‡ãƒãƒƒã‚°ï¼šå®Ÿéš›ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ç¢ºèª
        if (geo.features && geo.features.length > 0) {
          console.log('[createKantoSVGMap] Sample props:', geo.features[0]?.properties);
          console.log('[createKantoSVGMap] First 10 ja names:', geo.features.slice(0, 10).map(f => getNameJa(f.properties)));
        }
        
        // é–¢æ±ã ã‘æŠ½å‡ºï¼ˆæ—¥æœ¬èªåã§åˆ¤å®šï¼‰+ æ±äº¬éƒ½ã®é›¢å³¶ã‚’é™¤å¤–
        const kantoFeaturesFiltered = geo.features
          .filter(f => KANTO.has(getNameJa(f.properties)))
          .map(f => (getNameJa(f.properties) === "æ±äº¬éƒ½" ? keepMainlandPolygons(f) : f))
          .filter(Boolean);
        
        // ãƒ‡ãƒãƒƒã‚°ï¼šé–¢æ±æŠ½å‡ºã®çµæœã‚’ç¢ºèª
        console.log('[createKantoSVGMap] Total features:', geo.features.length);
        console.log('[createKantoSVGMap] Kanto features found (before filter):', geo.features.filter(f => KANTO.has(getNameJa(f.properties))).length);
        console.log('[createKantoSVGMap] Kanto features found (after filter):', kantoFeaturesFiltered.length);
        console.log('[createKantoSVGMap] Kanto names:', kantoFeaturesFiltered.map(f => getNameJa(f.properties)));
        
        // 0ä»¶ã®å ´åˆã¯è­¦å‘Šã‚’å‡ºã—ã¦çµ‚äº†
        if (kantoFeaturesFiltered.length === 0) {
          console.warn('[createKantoSVGMap] No Kanto features matched. Check name mapping.');
          return;
        }
        
        // æœ€çµ‚çš„ãªé–¢æ±FeatureCollectionï¼ˆé›¢å³¶é™¤å¤–æ¸ˆã¿ï¼‰
        const kantoFeatures = kantoFeaturesFiltered;
        
        // ã‚¤ãƒ™ãƒ³ãƒˆæ•°ã‚’å–å¾—
        const eventCountByAreaKey = {};
        for (const [name, key] of Object.entries(areaKeyByName)) {
          eventCountByAreaKey[key] = await countEventsByArea(name);
        }
        
        // åœ°å›³ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼ˆãƒªã‚µã‚¤ã‚ºæ™‚ã«å†æç”»ç”¨ï¼‰
        kantoMapData = {
          kantoFeatures,
          eventCountByAreaKey,
          areaKeyByName,
          getNameJa
        };
        
        // â˜…æç”»é–¢æ•°ã‚’å‘¼ã³å‡ºã—
        renderKantoMap(kantoFeatures, eventCountByAreaKey, areaKeyByName, getNameJa);
        
        // æç”»å®Œäº†ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
        kantoMapRendered = true;
        console.log('[createKantoSVGMap] Map rendered successfully');
        
        // â˜…ãƒªã‚µã‚¤ã‚ºå¯¾å¿œï¼šResizeObserverã‚’è¨­å®šï¼ˆåˆå›ã®ã¿ï¼‰
        if (!resizeObserver && container) {
          resizeObserver = new ResizeObserver(() => {
            console.log('[createKantoSVGMap] Container resized, re-rendering...');
            if (kantoMapData) {
              // ãƒ‡ãƒ¼ã‚¿ãŒæ—¢ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯å†æç”»
              renderKantoMap(
                kantoMapData.kantoFeatures,
                kantoMapData.eventCountByAreaKey,
                kantoMapData.areaKeyByName,
                kantoMapData.getNameJa
              );
            }
          });
          resizeObserver.observe(container);
        }
        
        // ãƒ‡ãƒãƒƒã‚°ï¼šå®Ÿéš›ã«æç”»ã•ã‚ŒãŸpathã®æ•°ã‚’ç¢ºèª
        setTimeout(() => {
          const pathCount = document.querySelectorAll('#kantoMap path').length;
          console.log('[createKantoSVGMap] Path count in DOM:', pathCount);
          
          if (pathCount > 0) {
            const firstPath = document.querySelector('#kantoMap path');
            if (firstPath) {
              const computed = window.getComputedStyle(firstPath);
              console.log('[createKantoSVGMap] First path styles:', {
                fill: computed.fill,
                stroke: computed.stroke,
                opacity: computed.opacity,
                display: computed.display,
                visibility: computed.visibility
              });
            }
          }
          
          const svgRect = document.getElementById('kantoMap')?.getBoundingClientRect();
          console.log('[createKantoSVGMap] SVG bounding rect:', svgRect);
        }, 100);
      } catch (error) {
        console.error('[createKantoSVGMap] Error loading map:', error);
        console.error('[createKantoSVGMap] Error stack:', error.stack);
        
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºï¼ˆDOM APIã§ç”Ÿæˆã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ–‡å­—åˆ—ã‚’ä½¿ã‚ãªã„ï¼‰
        const svgElement = document.getElementById("kantoMap");
        if (svgElement) {
          const width = 900, height = 700;
          const NS = "http://www.w3.org/2000/svg";
          
          // SVGã‚’ã‚¯ãƒªã‚¢
          svgElement.innerHTML = '';
          
          // èƒŒæ™¯
          const rect = document.createElementNS(NS, "rect");
          rect.setAttribute("x", "0");
          rect.setAttribute("y", "0");
          rect.setAttribute("width", String(width));
          rect.setAttribute("height", String(height));
          rect.setAttribute("fill", "#f0f0f0");
          svgElement.appendChild(rect);
          
          // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸1
          const text1 = document.createElementNS(NS, "text");
          text1.setAttribute("x", String(width / 2));
          text1.setAttribute("y", String(height / 2 - 20));
          text1.setAttribute("text-anchor", "middle");
          text1.setAttribute("font-size", "20");
          text1.setAttribute("fill", "#666");
          text1.textContent = "åœ°å›³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ";
          svgElement.appendChild(text1);
          
          // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸2
          const text2 = document.createElementNS(NS, "text");
          text2.setAttribute("x", String(width / 2));
          text2.setAttribute("y", String(height / 2 + 10));
          text2.setAttribute("text-anchor", "middle");
          text2.setAttribute("font-size", "14");
          text2.setAttribute("fill", "#999");
          text2.textContent = error.message || 'Unknown error';
          svgElement.appendChild(text2);
          
          // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸3
          const text3 = document.createElementNS(NS, "text");
          text3.setAttribute("x", String(width / 2));
          text3.setAttribute("y", String(height / 2 + 40));
          text3.setAttribute("text-anchor", "middle");
          text3.setAttribute("font-size", "12");
          text3.setAttribute("fill", "#999");
          text3.textContent = "ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„";
          svgElement.appendChild(text3);
        }
      }
    }
    
    // æ—§Google Mapså®Ÿè£…ï¼ˆå‰Šé™¤äºˆå®šã€äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
    function createKantoMap(container) {
      // ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¯ãƒªã‚¢
      container.innerHTML = '';
      
      // é–¢æ±åœ°æ–¹ã®ä¸­å¿ƒï¼ˆæ±äº¬ï¼‰
      const centerLat = 35.6762;
      const centerLng = 139.6503;
      
      // åœ°å›³ã‚’ä½œæˆï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªãƒ‡ã‚¶ã‚¤ãƒ³ã€ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãƒãƒ¼ã‚«ãƒ¼ã‚’åˆ¶å¾¡ï¼‰
      let currentMarkers = [];
      const map = new google.maps.Map(container, {
        center: { lat: centerLat, lng: centerLng },
        zoom: 8,
        mapTypeControl: false,
        streetViewControl: false,
        fullscreenControl: false,
        zoomControl: true,
        disableDefaultUI: false,
        minZoom: 7,
        maxZoom: 12,
        styles: [
          {
            featureType: "poi",
            elementType: "labels",
            stylers: [{ visibility: "off" }]
          },
          {
            featureType: "transit",
            elementType: "labels",
            stylers: [{ visibility: "off" }]
          }
        ]
      });
      
      // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãƒãƒ¼ã‚«ãƒ¼ã‚’åˆ¶å¾¡ã™ã‚‹é–¢æ•°
      const updateMarkersByZoom = () => {
        const zoom = map.getZoom();
        // ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ7-8ï¼‰: éƒ½é“åºœçœŒã®ã¿è¡¨ç¤º
        // ã‚ºãƒ¼ãƒ ä¸­ï¼ˆ9-11ï¼‰: éƒ½é“åºœçœŒè¡¨ç¤ºï¼ˆç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«ï¼‰
        // ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ï¼ˆ12+ï¼‰: å¸‚åŒºç”ºæ‘è¡¨ç¤ºï¼ˆå°†æ¥ã®æ‹¡å¼µç”¨ï¼‰
        // ç¾åœ¨ã¯éƒ½é“åºœçœŒãƒ¬ãƒ™ãƒ«ã®ã¿ãªã®ã§ã€ã™ã¹ã¦è¡¨ç¤º
        currentMarkers.forEach(marker => {
          if (marker) {
            marker.setVisible(true);
          }
        });
      };
      
      // ã‚ºãƒ¼ãƒ å¤‰æ›´æ™‚ã«ãƒãƒ¼ã‚«ãƒ¼ã‚’æ›´æ–°
      map.addListener('zoom_changed', updateMarkersByZoom);
      
      // éƒ½é“åºœçœŒã®åº§æ¨™
      const prefecturePositions = {
        'tokyo': { lat: 35.6762, lng: 139.6503, name: 'æ±äº¬éƒ½' },
        'kanagawa': { lat: 35.4475, lng: 139.6425, name: 'ç¥å¥ˆå·çœŒ' },
        'saitama': { lat: 35.8617, lng: 139.6455, name: 'åŸ¼ç‰çœŒ' },
        'chiba': { lat: 35.6074, lng: 140.1065, name: 'åƒè‘‰çœŒ' },
        'ibaraki': { lat: 36.3414, lng: 140.4467, name: 'èŒ¨åŸçœŒ' },
        'tochigi': { lat: 36.5658, lng: 139.8836, name: 'æ ƒæœ¨çœŒ' },
        'gunma': { lat: 36.3911, lng: 139.0608, name: 'ç¾¤é¦¬çœŒ' },
        'yamanashi': { lat: 35.6636, lng: 138.5684, name: 'å±±æ¢¨çœŒ' }
      };
      
      // éƒ½é“åºœçœŒãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½åŠ ï¼ˆ0ã‚¤ãƒ™ãƒ³ãƒˆã¯éè¡¨ç¤ºï¼‰
      // åœ°å›³ã ã‘ã«é›†ä¸­ã™ã‚‹ãŸã‚ã€ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆã‚’ä¸€æ™‚åœæ­¢
      if (DISABLE_OTHER_SVG_GENERATION) {
        console.log('[createKantoMap] Marker generation disabled for debugging');
        return;
      }
      
      const prefectureMarkers = [];
      const markerPromises = Object.keys(prefecturePositions).map(async (prefId) => {
        const pos = prefecturePositions[prefId];
        const prefectureName = pos.name;
        const count = await countEventsByArea(prefectureName);
        
        // 0ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã¯ãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤ºã—ãªã„ï¼ˆAæ¡ˆï¼šæ½”ã•ã¯ä¿¡é ¼ï¼‰
        if (count === 0) {
          return null;
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ã‚«ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆéƒ½é“åºœçœŒåã¨ã‚¤ãƒ™ãƒ³ãƒˆæ•°ï¼‰
        const textLength = Math.max(prefectureName.length, 8);
        const baseWidth = 100;
        const charWidth = 10;
        const padding = 20;
        const rectWidth = Math.max(baseWidth, textLength * charWidth + padding);
        const rectHeight = 50;
        const borderRadius = 8;
        
        const svg = `
          <svg width="${rectWidth}" height="${rectHeight + 8}" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <filter id="shadow${prefId}" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                <feOffset dx="0" dy="2" result="offsetblur"/>
                <feComponentTransfer>
                  <feFuncA type="linear" slope="0.3"/>
                </feComponentTransfer>
                <feMerge>
                  <feMergeNode/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <rect x="0" y="0" rx="${borderRadius}" ry="${borderRadius}" width="${rectWidth}" height="${rectHeight}" fill="#ffffff" stroke="#0b7a5d" stroke-width="2" filter="url(#shadow${prefId})"/>
            <text x="${rectWidth / 2}" y="${rectHeight / 2 - 4}" text-anchor="middle" font-size="13" font-weight="700" fill="#0b7a5d" font-family="Arial, sans-serif">${prefectureName}</text>
            <text x="${rectWidth / 2}" y="${rectHeight / 2 + 12}" text-anchor="middle" font-size="11" font-weight="500" fill="#666666" font-family="Arial, sans-serif">${count} ã‚¤ãƒ™ãƒ³ãƒˆ</text>
          </svg>
        `;
        
        const markerIcon = {
          url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg),
          scaledSize: new google.maps.Size(rectWidth, rectHeight + 8),
          anchor: new google.maps.Point(rectWidth / 2, rectHeight + 8),
          origin: new google.maps.Point(0, 0)
        };
        
        const marker = new google.maps.Marker({
          position: { lat: pos.lat, lng: pos.lng },
          map: map,
          title: `${prefectureName} - ${count} ã‚¤ãƒ™ãƒ³ãƒˆ`,
          icon: markerIcon,
          animation: google.maps.Animation.DROP
        });
        
        // ãƒãƒ¼ã‚«ãƒ¼ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å‡¦ç†
        marker.addListener('click', async () => {
          const cities = prefectureCities[prefId];
          const googleMapContainer = document.getElementById('map-google-map');
          
          if (cities && cities.length > 0 && googleMapContainer) {
            // äºŒæ®µéšç›®ï¼šå¸‚åŒºç”ºæ‘ã®Google Mapsã‚’è¡¨ç¤º
            initCityMap(prefId, prefectureName, cities, googleMapContainer);
          } else {
            // å¸‚åŒºç”ºæ‘ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯éƒ½é“åºœçœŒã§æ¤œç´¢
            window.location.href = `list.html?area=${encodeURIComponent(prefectureName)}`;
          }
        });
        
        return marker;
      });
      
      // ã™ã¹ã¦ã®ãƒãƒ¼ã‚«ãƒ¼ãŒè¿½åŠ ã•ã‚ŒãŸã‚‰ä½ç½®ã‚’èª¿æ•´
      Promise.all(markerPromises).then(markers => {
        const validMarkers = markers.filter(m => m !== null);
        prefectureMarkers.push(...validMarkers);
        currentMarkers = validMarkers;
        // ãƒãƒ¼ã‚«ãƒ¼ã®ä½ç½®ã‚’èª¿æ•´ï¼ˆéƒ½é“åºœçœŒãƒ¬ãƒ™ãƒ«ã§ã¯è·é›¢ãŒååˆ†é›¢ã‚Œã¦ã„ã‚‹ã®ã§èª¿æ•´ä¸è¦ï¼‰
        updateMarkersByZoom();
      });
    }
    
    // å¸‚åŒºç”ºæ‘ã®Google Mapsã‚’åˆæœŸåŒ–ï¼ˆäºŒæ®µéšç›®ï¼‰
    function initCityMap(prefectureId, prefectureName, cities, container) {
      // ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¯ãƒªã‚¢
      container.innerHTML = '';
      
      // éƒ½é“åºœçœŒã®ä¸­å¿ƒåº§æ¨™ã‚’å–å¾—
      const prefecturePositions = {
        'tokyo': { lat: 35.6762, lng: 139.6503 },
        'kanagawa': { lat: 35.4475, lng: 139.6425 },
        'saitama': { lat: 35.8617, lng: 139.6455 },
        'chiba': { lat: 35.6074, lng: 140.1065 },
        'ibaraki': { lat: 36.3414, lng: 140.4467 },
        'tochigi': { lat: 36.5658, lng: 139.8836 },
        'gunma': { lat: 36.3911, lng: 139.0608 },
        'yamanashi': { lat: 35.6636, lng: 138.5684 }
      };
      
      const centerPos = prefecturePositions[prefectureId] || { lat: 35.6762, lng: 139.6503 };
      
      // åœ°å›³ã‚’ä½œæˆï¼ˆã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãƒãƒ¼ã‚«ãƒ¼ã‚’åˆ¶å¾¡ï¼‰
      const map = new google.maps.Map(container, {
        center: { lat: centerPos.lat, lng: centerPos.lng },
        zoom: 10,
        mapTypeControl: false,
        streetViewControl: false,
        fullscreenControl: false,
        zoomControl: true,
        minZoom: 8,
        maxZoom: 15
      });
      
      // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãƒãƒ¼ã‚«ãƒ¼ã‚’åˆ¶å¾¡ã™ã‚‹é–¢æ•°
      const updateMarkersByZoom = () => {
        const zoom = map.getZoom();
        // ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ8-9ï¼‰: éƒ½é“åºœçœŒã®ã¿è¡¨ç¤ºï¼ˆã“ã®é–¢æ•°ã¯å¸‚åŒºç”ºæ‘ãƒãƒƒãƒ—ãªã®ã§é©ç”¨ã—ãªã„ï¼‰
        // ã‚ºãƒ¼ãƒ ä¸­ï¼ˆ10-12ï¼‰: å¸‚åŒºç”ºæ‘è¡¨ç¤ºï¼ˆç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«ï¼‰
        // ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ï¼ˆ13+ï¼‰: ã‚ˆã‚Šè©³ç´°ãªè¡¨ç¤ºï¼ˆå°†æ¥ã®æ‹¡å¼µç”¨ï¼‰
      };
      
      // ã‚ºãƒ¼ãƒ å¤‰æ›´æ™‚ã«ãƒãƒ¼ã‚«ãƒ¼ã‚’æ›´æ–°
      map.addListener('zoom_changed', updateMarkersByZoom);
      
      // æˆ»ã‚‹ãƒœã‚¿ãƒ³ã‚’è¿½åŠ ï¼ˆå…·ä½“çš„ãªæ–‡è¨€ã§ï¼‰
      const backButton = document.createElement('button');
      backButton.className = 'map-back-button';
      backButton.textContent = 'â† ã‚¨ãƒªã‚¢é¸æŠã«æˆ»ã‚‹';
      backButton.style.position = 'absolute';
      backButton.style.top = '10px';
      backButton.style.left = '10px';
      backButton.style.zIndex = '1000';
      backButton.onclick = () => {
        initKantoMap(container);
      };
      container.appendChild(backButton);
      
      // ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¿½åŠ 
      const titleDiv = document.createElement('div');
      titleDiv.className = 'map-city-title';
      titleDiv.textContent = prefectureName;
      titleDiv.style.position = 'absolute';
      titleDiv.style.top = '10px';
      titleDiv.style.left = '50%';
      titleDiv.style.transform = 'translateX(-50%)';
      titleDiv.style.zIndex = '1000';
      titleDiv.style.background = '#fff';
      titleDiv.style.padding = '8px 16px';
      titleDiv.style.borderRadius = '8px';
      titleDiv.style.fontWeight = '700';
      titleDiv.style.fontSize = '1.2rem';
      titleDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
      container.appendChild(titleDiv);
      
      // å¸‚åŒºç”ºæ‘ãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½åŠ 
      // åœ°å›³ã ã‘ã«é›†ä¸­ã™ã‚‹ãŸã‚ã€ãƒãƒ¼ã‚«ãƒ¼ç”Ÿæˆã‚’ä¸€æ™‚åœæ­¢
      if (DISABLE_OTHER_SVG_GENERATION) {
        console.log('[initCityMap] Marker generation disabled for debugging');
        return;
      }
      
      const bounds = new google.maps.LatLngBounds();
      const cityMarkers = [];
      
      const cityMarkerPromises = cities.map(async (city) => {
        const count = await countEventsByArea(city.area);
        
        // 0ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã¯ãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤ºã—ãªã„ï¼ˆAæ¡ˆï¼šæ½”ã•ã¯ä¿¡é ¼ï¼‰
        if (count === 0) {
          return null;
        }
        
        let lat = city.lat || centerPos.lat;
        let lng = city.lng || centerPos.lng;
        
        bounds.extend({ lat, lng });
        
        // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ã‚«ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³
        const textLength = Math.max(city.name.length, 6);
        const baseWidth = 80;
        const charWidth = 9;
        const padding = 16;
        const rectWidth = Math.max(baseWidth, textLength * charWidth + padding);
        const rectHeight = 40;
        const borderRadius = 6;
        
        const svg = `
          <svg width="${rectWidth}" height="${rectHeight + 8}" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <filter id="shadow${city.area.replace(/\s/g, '')}" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="1.5"/>
                <feOffset dx="0" dy="2" result="offsetblur"/>
                <feComponentTransfer>
                  <feFuncA type="linear" slope="0.3"/>
                </feComponentTransfer>
                <feMerge>
                  <feMergeNode/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <rect x="0" y="0" rx="${borderRadius}" ry="${borderRadius}" width="${rectWidth}" height="${rectHeight}" fill="#ffffff" stroke="#0b7a5d" stroke-width="2" filter="url(#shadow${city.area.replace(/\s/g, '')})"/>
            <text x="${rectWidth / 2}" y="${rectHeight / 2 - 2}" text-anchor="middle" font-size="12" font-weight="700" fill="#0b7a5d" font-family="Arial, sans-serif">${city.name}</text>
            <text x="${rectWidth / 2}" y="${rectHeight / 2 + 10}" text-anchor="middle" font-size="10" font-weight="500" fill="#666666" font-family="Arial, sans-serif">${count} ã‚¤ãƒ™ãƒ³ãƒˆ</text>
          </svg>
        `;
        
        const markerIcon = {
          url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg),
          scaledSize: new google.maps.Size(rectWidth, rectHeight + 8),
          anchor: new google.maps.Point(rectWidth / 2, rectHeight + 8),
          origin: new google.maps.Point(0, 0)
        };
        
        const marker = new google.maps.Marker({
          position: { lat, lng },
          map: map,
          title: `${city.name} - ${count} ã‚¤ãƒ™ãƒ³ãƒˆ`,
          icon: markerIcon,
          animation: google.maps.Animation.DROP
        });
        
        // ãƒãƒ¼ã‚«ãƒ¼ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å‡¦ç†
        marker.addListener('click', async () => {
          // ã‚¤ãƒ™ãƒ³ãƒˆæ•°ãŒå¤šã„å ´åˆï¼ˆ10ä»¶ä»¥ä¸Šï¼‰ã¯ä¸‰æ®µéšç›®ã‚’è¡¨ç¤º
          if (count >= 10 && city.hasSubAreas) {
            // ä¸‰æ®µéšç›®ï¼šã•ã‚‰ã«ç´°ã‹ã„ã‚¨ãƒªã‚¢ã‚’è¡¨ç¤º
            initSubAreaMap(city, container, map);
          } else {
            // ã‚¤ãƒ™ãƒ³ãƒˆä¸€è¦§ãƒšãƒ¼ã‚¸ã«é·ç§»ï¼ˆåœ°åã¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ­£ç¢ºã«ç´ã¥ã‘ã‚‹ï¼‰
            window.location.href = `list.html?area=${encodeURIComponent(city.area)}`;
          }
        });
        
        return { marker, lat, lng };
      });
      
      // ã™ã¹ã¦ã®ãƒãƒ¼ã‚«ãƒ¼ãŒè¿½åŠ ã•ã‚ŒãŸã‚‰ä½ç½®ã‚’èª¿æ•´
      Promise.all(cityMarkerPromises).then(markerData => {
        const validMarkerData = markerData.filter(m => m !== null);
        validMarkerData.forEach(({ marker }) => {
          cityMarkers.push(marker);
        });
        
        // ãƒãƒ¼ã‚«ãƒ¼ã®ä½ç½®ã‚’èª¿æ•´ã—ã¦é‡è¤‡ã‚’é˜²ã
        if (cityMarkers.length > 0) {
          setTimeout(() => {
            adjustMarkerPositions(cityMarkers, 0.008); // å¸‚åŒºç”ºæ‘ãƒ¬ãƒ™ãƒ«ã§ã¯0.008åº¦ï¼ˆç´„800mï¼‰ä»¥ä¸Šé›¢ã™
          }, 100);
          
          // ã™ã¹ã¦ã®ãƒãƒ¼ã‚«ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«åœ°å›³ã‚’èª¿æ•´
          map.fitBounds(bounds);
        }
      });
    }
    
    // ä¸‰æ®µéšç›®ï¼šç´°ã‹ã„ã‚¨ãƒªã‚¢ã®Google Mapsï¼ˆã‚¤ãƒ™ãƒ³ãƒˆãŒå¤šã„å ´åˆï¼‰
    function initSubAreaMap(city, container, parentMap) {
      // ä¸–ç”°è°·åŒºã®ä¾‹ï¼šã•ã‚‰ã«ç´°ã‹ã„ã‚¨ãƒªã‚¢
      if (city.area === 'ä¸–ç”°è°·åŒº') {
        const subAreas = [
          { name: 'ä¸–ç”°è°·', area: 'ä¸–ç”°è°·åŒº ä¸–ç”°è°·', lat: 35.6466, lng: 139.6533 },
          { name: 'ä¸‹åŒ—æ²¢', area: 'ä¸–ç”°è°·åŒº ä¸‹åŒ—æ²¢', lat: 35.6616, lng: 139.6669 },
          { name: 'ä¸‰è»’èŒ¶å±‹', area: 'ä¸–ç”°è°·åŒº ä¸‰è»’èŒ¶å±‹', lat: 35.6431, lng: 139.6703 },
          { name: 'çµŒå ‚', area: 'ä¸–ç”°è°·åŒº çµŒå ‚', lat: 35.6506, lng: 139.6286 },
          { name: 'æˆåŸ', area: 'ä¸–ç”°è°·åŒº æˆåŸ', lat: 35.6386, lng: 139.6069 }
        ];
        
        // è¦ªãƒãƒƒãƒ—ã‚’éè¡¨ç¤ºã«ã—ã¦ã€æ–°ã—ã„åœ°å›³ã‚’ä½œæˆ
        const subMapContainer = document.createElement('div');
        subMapContainer.className = 'map-google-map';
        subMapContainer.style.width = '100%';
        subMapContainer.style.height = '100%';
        subMapContainer.style.position = 'absolute';
        subMapContainer.style.top = '0';
        subMapContainer.style.left = '0';
        container.appendChild(subMapContainer);
        
        const subMap = new google.maps.Map(subMapContainer, {
          center: { lat: 35.6466, lng: 139.6533 },
          zoom: 13,
          mapTypeControl: false,
          streetViewControl: false,
          fullscreenControl: false,
          zoomControl: true
        });
        
        // æˆ»ã‚‹ãƒœã‚¿ãƒ³
        const backButton = document.createElement('button');
        backButton.className = 'map-back-button';
        backButton.textContent = 'â† æˆ»ã‚‹';
        backButton.style.position = 'absolute';
        backButton.style.top = '10px';
        backButton.style.left = '10px';
        backButton.style.zIndex = '1000';
        backButton.onclick = () => {
          subMapContainer.remove();
          backButton.remove();
          titleDiv.remove();
        };
        container.appendChild(backButton);
        
        // ã‚¿ã‚¤ãƒˆãƒ«
        const titleDiv = document.createElement('div');
        titleDiv.className = 'map-city-title';
        titleDiv.textContent = city.name;
        titleDiv.style.position = 'absolute';
        titleDiv.style.top = '10px';
        titleDiv.style.left = '50%';
        titleDiv.style.transform = 'translateX(-50%)';
        titleDiv.style.zIndex = '1000';
        titleDiv.style.background = '#fff';
        titleDiv.style.padding = '8px 16px';
        titleDiv.style.borderRadius = '8px';
        titleDiv.style.fontWeight = '700';
        titleDiv.style.fontSize = '1.2rem';
        titleDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
        container.appendChild(titleDiv);
        
        // ç´°ã‹ã„ã‚¨ãƒªã‚¢ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½åŠ 
        subAreas.forEach(async (subArea) => {
          const count = await countEventsByArea(subArea.area);
          
          const textLength = Math.max(subArea.name.length, 4);
          const baseWidth = 60;
          const charWidth = 8;
          const padding = 12;
          const rectWidth = Math.max(baseWidth, textLength * charWidth + padding);
          const rectHeight = 32;
          const borderRadius = 6;
          
          const svg = `
            <svg width="${rectWidth}" height="${rectHeight + 6}" xmlns="http://www.w3.org/2000/svg">
              <rect x="0" y="0" rx="${borderRadius}" ry="${borderRadius}" width="${rectWidth}" height="${rectHeight}" fill="#ffffff" stroke="#0b7a5d" stroke-width="1.5"/>
              <text x="${rectWidth / 2}" y="${rectHeight / 2 + 4}" text-anchor="middle" font-size="11" font-weight="600" fill="#0b7a5d" font-family="Arial, sans-serif">${subArea.name}</text>
            </svg>
          `;
          
          const markerIcon = {
            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg),
            scaledSize: new google.maps.Size(rectWidth, rectHeight + 6),
            anchor: new google.maps.Point(rectWidth / 2, rectHeight + 6),
            origin: new google.maps.Point(0, 0)
          };
          
          const marker = new google.maps.Marker({
            position: { lat: subArea.lat, lng: subArea.lng },
            map: subMap,
            title: `${subArea.name} - ${count} ã‚¤ãƒ™ãƒ³ãƒˆ`,
            icon: markerIcon
          });
          
          marker.addListener('click', () => {
            window.location.href = `list.html?area=${encodeURIComponent(subArea.area)}`;
          });
        });
      } else {
        // ä¸‰æ®µéšç›®ãŒãªã„å ´åˆã¯ç›´æ¥ã‚¤ãƒ™ãƒ³ãƒˆä¸€è¦§ãƒšãƒ¼ã‚¸ã«é·ç§»
        window.location.href = `list.html?area=${encodeURIComponent(city.area)}`;
      }
    }

    // è¿‘ãã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¡¨ç¤ºã™ã‚‹Google Mapsã®åˆæœŸåŒ–
    function initNearbyMap(userLat, userLng, container) {
      // Google Maps APIãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
      if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
        // Google Maps APIã‚’èª­ã¿è¾¼ã‚€
        if (!document.querySelector('script[src*="maps.googleapis.com"]')) {
          const script = document.createElement('script');
          script.src = `https://maps.googleapis.com/maps/api/js?key=${window.GOOGLE_MAPS_API_KEY}&callback=initNearbyMapCallback&language=ja&region=JP&loading=async`;
          script.async = true;
          script.defer = true;
          window.initNearbyMapCallback = () => {
            createNearbyMap(userLat, userLng, container);
          };
          document.head.appendChild(script);
        } else {
          // æ—¢ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ç›´æ¥ä½œæˆ
          setTimeout(() => {
            createNearbyMap(userLat, userLng, container);
          }, 500);
        }
      } else {
        createNearbyMap(userLat, userLng, container);
      }
    }
    
    // Google Mapsã‚’ä½œæˆ
    function createNearbyMap(userLat, userLng, container) {
      // ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¯ãƒªã‚¢
      container.innerHTML = '';
      
      // åœ°å›³ã‚’ä½œæˆ
      const map = new google.maps.Map(container, {
        center: { lat: userLat, lng: userLng },
        zoom: 13,
        mapTypeControl: true,
        streetViewControl: false,
        fullscreenControl: true
      });
      
      // ç¾åœ¨åœ°ãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½åŠ 
      new google.maps.Marker({
        position: { lat: userLat, lng: userLng },
        map: map,
        title: 'ç¾åœ¨åœ°',
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 10,
          fillColor: '#4285F4',
          fillOpacity: 1,
          strokeColor: '#fff',
          strokeWeight: 3
        }
      });
      
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      let source = Array.isArray(window.eventIndex) && window.eventIndex.length > 0
        ? window.eventIndex
        : (Array.isArray(window.eventData?.events) ? window.eventData.events : []);
      
      if (source.length === 0) {
        console.log('[initNearbyMap] No event data available');
        return;
      }
      
      // ä½ç½®æƒ…å ±ãŒã‚ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
      const eventsWithLocation = source.filter(event => {
        const lat = event.location?.lat;
        const lng = event.location?.lng;
        return lat && lng && !isNaN(parseFloat(lat)) && !isNaN(parseFloat(lng));
      });
      
      // è·é›¢ã§ã‚½ãƒ¼ãƒˆï¼ˆè¿‘ã„é †ï¼‰
      const eventsWithDistance = eventsWithLocation.map(event => {
        const eventLat = parseFloat(event.location.lat);
        const eventLng = parseFloat(event.location.lng);
        const distance = calculateDistance(userLat, userLng, eventLat, eventLng);
        return { event, distance };
      }).sort((a, b) => a.distance - b.distance);
      
      // è¿‘ãã®ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆ20kmä»¥å†…ã€æœ€å¤§20ä»¶ï¼‰ã‚’ãƒãƒƒãƒ—ã«è¡¨ç¤º
      const nearbyEvents = eventsWithDistance
        .filter(item => item.distance <= 20)
        .slice(0, 20);
      
      console.log('[initNearbyMap] Found', nearbyEvents.length, 'nearby events');
      
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½åŠ 
      nearbyEvents.forEach(({ event, distance }) => {
        const lat = parseFloat(event.location.lat);
        const lng = parseFloat(event.location.lng);
        const price = event.price ? event.price : 0;
        const priceLabel = price > 0 ? `Â¥ ${price.toLocaleString()}` : '';
        
        // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ã‚«ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆä¾¡æ ¼è¡¨ç¤ºï¼‰
        let markerIcon = null;
        if (priceLabel) {
          const textLength = priceLabel.length;
          const baseWidth = 40;
          const charWidth = 8;
          const padding = 10;
          const rectWidth = Math.max(baseWidth, textLength * charWidth + padding);
          const rectHeight = 24;
          const borderRadius = 4;
          
          const svg = `
            <svg width="${rectWidth}" height="${rectHeight + 8}" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                  <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
                  <feOffset dx="0" dy="1" result="offsetblur"/>
                  <feComponentTransfer>
                    <feFuncA type="linear" slope="0.2"/>
                  </feComponentTransfer>
                  <feMerge>
                    <feMergeNode/>
                    <feMergeNode in="SourceGraphic"/>
                  </feMerge>
                </filter>
              </defs>
              <rect x="0" y="0" rx="${borderRadius}" ry="${borderRadius}" width="${rectWidth}" height="${rectHeight}" fill="#ffffff" stroke="#cccccc" stroke-width="1" filter="url(#shadow)"/>
              <text x="${rectWidth / 2}" y="${rectHeight / 2 + 4}" text-anchor="middle" font-size="12" font-weight="600" fill="#333333" font-family="Arial, sans-serif">${priceLabel}</text>
            </svg>
          `;
          
          markerIcon = {
            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg),
            scaledSize: new google.maps.Size(rectWidth, rectHeight + 8),
            anchor: new google.maps.Point(rectWidth / 2, rectHeight + 8),
            origin: new google.maps.Point(0, 0)
          };
        }
        
        const marker = new google.maps.Marker({
          position: { lat, lng },
          map: map,
          title: `${event.title || ''} - ${distance.toFixed(1)}km`,
          icon: markerIcon,
          animation: google.maps.Animation.DROP
        });
        
        // ãƒãƒ¼ã‚«ãƒ¼ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆè©³ç´°ãƒšãƒ¼ã‚¸ã«é·ç§»
        marker.addListener('click', () => {
          window.location.href = `experience.html?id=${event.id}`;
        });
      });
      
      // ã™ã¹ã¦ã®ãƒãƒ¼ã‚«ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«åœ°å›³ã‚’èª¿æ•´
      if (nearbyEvents.length > 0) {
        const bounds = new google.maps.LatLngBounds();
        bounds.extend({ lat: userLat, lng: userLng });
        nearbyEvents.forEach(({ event }) => {
          bounds.extend({
            lat: parseFloat(event.location.lat),
            lng: parseFloat(event.location.lng)
          });
        });
        map.fitBounds(bounds);
      }
    }

    // ä½ç½®æƒ…å ±ã‚’å–å¾—ã—ã¦è¿‘å ´ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¡¨ç¤ºï¼ˆéæ¨å¥¨ï¼šåœ°å›³ã‹ã‚‰æ¢ã™ã«ç½®ãæ›ãˆï¼‰
    async function renderLocationBasedEvents() {
      const section = document.getElementById('location-based-events');
      const container = document.getElementById('location-events-list');
      const titleEl = document.getElementById('location-events-title');
      
      if (!section || !container) {
        console.log('[renderLocationBasedEvents] Section or container not found');
        return;
      }

      // ä½ç½®æƒ…å ±ãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
      if (!navigator.geolocation) {
        console.log('[renderLocationBasedEvents] Geolocation is not supported');
        return;
      }

      // ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
      let source = Array.isArray(window.eventIndex) && window.eventIndex.length > 0
        ? window.eventIndex
        : (Array.isArray(window.eventData?.events) ? window.eventData.events : []);

      if (source.length === 0) {
        console.log('[renderLocationBasedEvents] No event data available yet, waiting...');
        // ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å°‘ã—å¾…ã¤
        setTimeout(() => renderLocationBasedEvents(), 1000);
        return;
      }

      console.log('[renderLocationBasedEvents] Event data available:', source.length, 'events');

      // ä½ç½®æƒ…å ±ãŒãªã„ã‚¤ãƒ™ãƒ³ãƒˆã®è©³ç´°ã‚’èª­ã¿è¾¼ã‚“ã§ä½ç½®æƒ…å ±ã‚’è£œå®Œï¼ˆã‚ˆã‚Šå¤šãã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è£œå®Œï¼‰
      const eventsWithoutLocation = source.filter(e => !e.location || !e.location.lat || !e.location.lng);
      if (eventsWithoutLocation.length > 0) {
        console.log('[renderLocationBasedEvents] Loading location data for', eventsWithoutLocation.length, 'events');
        try {
          // ã‚ˆã‚Šå¤šãã®ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆ50ä»¶ï¼‰ã‹ã‚‰ä½ç½®æƒ…å ±ã‚’è£œå®Œ
          const detailPromises = eventsWithoutLocation.slice(0, 50).map(e => 
            loadEventDetail(e.id).catch(() => null)
          );
          const details = await Promise.all(detailPromises);
          const detailMap = {};
          details.forEach(d => {
            if (d && d.id && d.location && d.location.lat && d.location.lng) {
              detailMap[d.id] = d.location;
            }
          });
          
          // sourceã«ä½ç½®æƒ…å ±ã‚’è£œå®Œ
          source = source.map(item => {
            const location = detailMap[item.id];
            if (location) {
              return { ...item, location: location };
            }
            return item;
          });
          
          console.log('[renderLocationBasedEvents] Enriched location data for', Object.keys(detailMap).length, 'events');
        } catch (e) {
          console.warn('[renderLocationBasedEvents] Failed to enrich location data:', e);
        }
      }

      // ä½ç½®æƒ…å ±ãŒã‚ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’äº‹å‰ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
      const eventsWithLocation = source.filter(event => {
        if (!event.location) return false;
        
        // lat/lngã‚’æ•°å€¤ã«å¤‰æ›
        const lat = parseFloat(event.location.lat);
        const lng = parseFloat(event.location.lng);
        
        return !isNaN(lat) && !isNaN(lng) && isFinite(lat) && isFinite(lng);
      });

      console.log('[renderLocationBasedEvents] Events with location:', eventsWithLocation.length);

      if (eventsWithLocation.length === 0) {
        console.log('[renderLocationBasedEvents] No events with location data');
        return;
      }

      // ä½ç½®æƒ…å ±ã‹ã‚‰éƒ½é“åºœçœŒã‚’å–å¾—ã™ã‚‹é–¢æ•°
      const getPrefecture = async (lat, lng) => {
        const apiKey = window.GOOGLE_MAPS_API_KEY || 'AIzaSyDNV6H5ImWmE2DhWdRYupUER85Rb8ZqmQM';
        if (!apiKey || apiKey === 'YOUR_API_KEY_HERE') {
          return null;
        }

        try {
          const response = await fetch(
            `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=${apiKey}&language=ja&region=jp`
          );
          const data = await response.json();
          
          if (data.status === 'OK' && data.results && data.results.length > 0) {
            // çµæœã‹ã‚‰éƒ½é“åºœçœŒã‚’å–å¾—
            for (const result of data.results) {
              const addressComponents = result.address_components || [];
              for (const component of addressComponents) {
                if (component.types.includes('administrative_area_level_1')) {
                  return component.long_name;
                }
              }
            }
          }
        } catch (error) {
          console.warn('[renderLocationBasedEvents] Failed to get prefecture:', error);
        }
        return null;
      };

      // ä½ç½®æƒ…å ±ã‹ã‚‰åœ°åã‚’å–å¾—ã™ã‚‹é–¢æ•°
      const getLocationName = async (lat, lng) => {
        const apiKey = window.GOOGLE_MAPS_API_KEY || 'AIzaSyDNV6H5ImWmE2DhWdRYupUER85Rb8ZqmQM';
        if (!apiKey || apiKey === 'YOUR_API_KEY_HERE') {
          return null;
        }

        try {
          const response = await fetch(
            `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=${apiKey}&language=ja&region=jp`
          );
          const data = await response.json();
          
          if (data.status === 'OK' && data.results && data.results.length > 0) {
            // çµæœã‹ã‚‰å¸‚åŒºç”ºæ‘åã‚’å–å¾—
            for (const result of data.results) {
              const addressComponents = result.address_components || [];
              // å¸‚åŒºç”ºæ‘ã‚’æ¢ã™
              for (const component of addressComponents) {
                if (component.types.includes('locality') || component.types.includes('administrative_area_level_2')) {
                  return component.long_name;
                }
              }
              // éƒ½é“åºœçœŒã‚’æ¢ã™
              for (const component of addressComponents) {
                if (component.types.includes('administrative_area_level_1')) {
                  return component.long_name;
                }
              }
            }
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€åˆã®çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿ä½æ‰€ã‹ã‚‰å¸‚åŒºç”ºæ‘ã‚’æŠ½å‡º
            const formattedAddress = data.results[0].formatted_address;
            if (formattedAddress) {
              // ã€Œæ±äº¬éƒ½æ¸‹è°·åŒºã€ã®ã‚ˆã†ãªå½¢å¼ã‹ã‚‰ã€Œæ¸‹è°·åŒºã€ã‚’æŠ½å‡º
              const match = formattedAddress.match(/([éƒ½é“åºœçœŒ])([å¸‚åŒºç”ºæ‘]+)/);
              if (match && match[2]) {
                return match[2];
              }
              // ã€Œæ¸‹è°·åŒºã€ã®ã‚ˆã†ãªå½¢å¼ã‚’ç›´æ¥æŠ½å‡º
              const match2 = formattedAddress.match(/([^éƒ½é“åºœçœŒå¸‚åŒºç”ºæ‘]+[å¸‚åŒºç”ºæ‘])/);
              if (match2 && match2[1]) {
                return match2[1];
              }
            }
          }
        } catch (error) {
          console.warn('[renderLocationBasedEvents] Failed to get location name:', error);
        }
        return null;
      };

      // ã‚¤ãƒ™ãƒ³ãƒˆã®ä½ç½®æƒ…å ±ã‹ã‚‰å¸‚åŒºç”ºæ‘ã‚’å–å¾—ã™ã‚‹é–¢æ•°ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä»˜ãï¼‰
      const eventLocationCache = {};
      const getEventLocationName = async (lat, lng) => {
        const cacheKey = `${lat.toFixed(4)},${lng.toFixed(4)}`;
        if (eventLocationCache[cacheKey]) {
          return eventLocationCache[cacheKey];
        }

        const apiKey = window.GOOGLE_MAPS_API_KEY || 'AIzaSyDNV6H5ImWmE2DhWdRYupUER85Rb8ZqmQM';
        if (!apiKey || apiKey === 'YOUR_API_KEY_HERE') {
          return null;
        }

        try {
          const response = await fetch(
            `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&key=${apiKey}&language=ja&region=jp`
          );
          const data = await response.json();
          
          if (data.status === 'OK' && data.results && data.results.length > 0) {
            // çµæœã‹ã‚‰å¸‚åŒºç”ºæ‘åã‚’å–å¾—
            for (const result of data.results) {
              const addressComponents = result.address_components || [];
              // å¸‚åŒºç”ºæ‘ã‚’æ¢ã™
              for (const component of addressComponents) {
                if (component.types.includes('locality') || component.types.includes('administrative_area_level_2')) {
                  eventLocationCache[cacheKey] = component.long_name;
                  return component.long_name;
                }
              }
            }
          }
        } catch (error) {
          console.warn('[renderLocationBasedEvents] Failed to get event location name:', error);
        }
        eventLocationCache[cacheKey] = null;
        return null;
      };

      // ä½ç½®æƒ…å ±ã®å–å¾—è¨±å¯ã‚’æ±‚ã‚ã‚‹ï¼ˆå¤±æ•—æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ã‚’ä½¿ç”¨ï¼‰
      const processNearbyEvents = async (userLat, userLng, isDefaultLocation = false) => {
        console.log('[renderLocationBasedEvents] Processing events for location:', userLat, userLng);

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¸‚åŒºç”ºæ‘ã‚’å–å¾—
        const userLocationName = await getLocationName(userLat, userLng);
        console.log('[renderLocationBasedEvents] User location name:', userLocationName);

        // å„ã‚¤ãƒ™ãƒ³ãƒˆã®è·é›¢ã¨å¸‚åŒºç”ºæ‘ã‚’è¨ˆç®—
        const eventsWithInfo = await Promise.all(
          eventsWithLocation.map(async (event) => {
            const lat = parseFloat(event.location.lat);
            const lng = parseFloat(event.location.lng);
            const distance = calculateDistance(userLat, userLng, lat, lng);
            const eventLocationName = await getEventLocationName(lat, lng);
            const isSameLocation = userLocationName && eventLocationName && 
                                   userLocationName === eventLocationName;
            return { event, distance, isSameLocation };
          })
        );

        // ã‚½ãƒ¼ãƒˆï¼šåŒã˜å¸‚åŒºç”ºæ‘ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’å„ªå…ˆã€ãã®å¾Œè·é›¢é †
        const nearbyEvents = eventsWithInfo
          .sort((a, b) => {
            // åŒã˜å¸‚åŒºç”ºæ‘ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’å„ªå…ˆ
            if (a.isSameLocation && !b.isSameLocation) return -1;
            if (!a.isSameLocation && b.isSameLocation) return 1;
            // åŒã˜æ¡ä»¶ãªã‚‰è·é›¢é †
            return a.distance - b.distance;
          })
          .slice(0, 8)
          .map(item => item.event);

        console.log('[renderLocationBasedEvents] Nearby events:', nearbyEvents.length);
        if (nearbyEvents.length > 0) {
          const firstEventInfo = eventsWithInfo.find(e => e.event.id === nearbyEvents[0].id);
          console.log('[renderLocationBasedEvents] First nearby event:', nearbyEvents[0].title, 
            'distance:', firstEventInfo ? firstEventInfo.distance.toFixed(2) + 'km' : 'unknown',
            'same location:', firstEventInfo ? firstEventInfo.isSameLocation : false);
        }

        if (nearbyEvents.length > 0) {
          // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
          section.style.display = 'block';
          
          // åœ°åã‚’å–å¾—ã—ã¦ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ›´æ–°
          let locationName = null;
          if (isDefaultLocation) {
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ï¼ˆä¸–ç”°è°·åŒºï¼‰ã®å ´åˆã‚‚åœ°åã‚’å–å¾—
            locationName = await getLocationName(userLat, userLng);
            if (!locationName) {
              locationName = 'ä¸–ç”°è°·åŒº'; // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            }
          } else {
            locationName = await getLocationName(userLat, userLng);
          }
          
          if (titleEl) {
            if (locationName) {
              titleEl.textContent = `${locationName}ã®ãŠã™ã™ã‚ã‚¤ãƒ™ãƒ³ãƒˆ`;
            } else {
              titleEl.textContent = 'è¿‘ãã®ãŠã™ã™ã‚ã‚¤ãƒ™ãƒ³ãƒˆ';
            }
          }

            // ã‚«ãƒ«ãƒ¼ã‚»ãƒ«è¡¨ç¤ºã§è¡¨ç¤ºï¼ˆCardRendererãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿï¼‰
            if (typeof CardRenderer !== 'undefined' && CardRenderer.renderCarousel) {
              CardRenderer.renderCarousel(nearbyEvents, 'location-events-list');
              console.log('[renderLocationBasedEvents] Events rendered successfully');
            } else {
              console.warn('[renderLocationBasedEvents] CardRenderer not loaded yet, waiting...');
              // CardRendererãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã—ã¦ãƒªãƒˆãƒ©ã‚¤
              let retryCount = 0;
              const maxRetries = 10;
              const retryInterval = setInterval(() => {
                retryCount++;
                if (typeof CardRenderer !== 'undefined' && CardRenderer.renderCarousel) {
                  CardRenderer.renderCarousel(nearbyEvents, 'location-events-list');
                  console.log('[renderLocationBasedEvents] Events rendered successfully (retry ' + retryCount + ')');
                  clearInterval(retryInterval);
                } else if (retryCount >= maxRetries) {
                  console.error('[renderLocationBasedEvents] CardRenderer is still not available after retries');
                  clearInterval(retryInterval);
                }
              }, 200);
            }
        }
      };

      // ä½ç½®æƒ…å ±ã®å–å¾—ã‚’è©¦ã¿ã‚‹
      navigator.geolocation.getCurrentPosition(
        async (position) => {
          const userLat = position.coords.latitude;
          const userLng = position.coords.longitude;
          
          // éƒ½é“åºœçœŒã‚’å–å¾—ã—ã¦é–¢æ±ã‹ã©ã†ã‹åˆ¤å®š
          const prefecture = await getPrefecture(userLat, userLng);
          const kantoPrefectures = ['æ±äº¬éƒ½', 'ç¥å¥ˆå·çœŒ', 'åƒè‘‰çœŒ', 'åŸ¼ç‰çœŒ', 'ç¾¤é¦¬çœŒ', 'æ ƒæœ¨çœŒ', 'èŒ¨åŸçœŒ'];
          const isKanto = prefecture && kantoPrefectures.includes(prefecture);
          
          if (isKanto) {
            // é–¢æ±ã®å ´åˆã¯å–å¾—ã—ãŸä½ç½®æƒ…å ±ã‚’ä½¿ç”¨
            await processNearbyEvents(userLat, userLng, false);
          } else {
            // é–¢æ±ä»¥å¤–ã®å ´åˆã¯ä¸–ç”°è°·åŒºã‚’ä½¿ç”¨
            console.log('[renderLocationBasedEvents] Not in Kanto region, using Setagaya as default');
            const defaultLat = 35.6466; // ä¸–ç”°è°·åŒºã®ç·¯åº¦
            const defaultLng = 139.6533; // ä¸–ç”°è°·åŒºã®çµŒåº¦
            await processNearbyEvents(defaultLat, defaultLng, true);
          }
        },
        async (error) => {
          console.log('[renderLocationBasedEvents] Geolocation error:', error.code, error.message);
          // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ï¼ˆä¸–ç”°è°·åŒºï¼‰ã‚’ä½¿ç”¨ã—ã¦è¿‘ãã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¡¨ç¤º
          console.log('[renderLocationBasedEvents] Using default location (Setagaya)');
          const defaultLat = 35.6466; // ä¸–ç”°è°·åŒºã®ç·¯åº¦
          const defaultLng = 139.6533; // ä¸–ç”°è°·åŒºã®çµŒåº¦
          await processNearbyEvents(defaultLat, defaultLng, true);
        },
        {
          enableHighAccuracy: true, // GPSã‚’ä½¿ç”¨ã—ã¦ã‚ˆã‚Šæ­£ç¢ºãªä½ç½®æƒ…å ±ã‚’å–å¾—
          timeout: 20000, // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’20ç§’ã«å»¶é•·ï¼ˆGPSå–å¾—ã«æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ï¼‰
          maximumAge: 0 // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ã‚ãšã€å¸¸ã«æœ€æ–°ã®ä½ç½®æƒ…å ±ã‚’å–å¾—
        }
      );
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒ–ãƒ­ãƒƒã‚¯ã®è¡¨ç¤ºï¼ˆevents_index ãƒ™ãƒ¼ã‚¹ï¼‰
    async function renderEventBlocks() {
      const MAX_HOME_EVENTS = 8;
      
      // eventIndex ã‚’å„ªå…ˆã€ãªã‘ã‚Œã° eventData.events ã‹ã‚‰æ§‹ç¯‰
      let source = Array.isArray(window.eventIndex) && window.eventIndex.length > 0
        ? window.eventIndex
        : (Array.isArray(window.eventData?.events) ? window.eventData.events : []);
      
      // next_date ãŒç„¡ã„å ´åˆã€æœ€åˆã®æ•°ä»¶ã®è©³ç´°JSONã‹ã‚‰æ—¥ä»˜ã‚’è£œå®Œ
      if (source.length > 0 && !source[0].next_date && !source[0].date_min && (!source[0].dates || source[0].dates.length === 0)) {
        console.log('[renderEventBlocks] next_date not found, enriching from detail JSONs...');
        try {
          const sampleIds = source.slice(0, 20).map(e => e.id).filter(Boolean);
          const detailPromises = sampleIds.map(id => 
            loadEventDetail(id).catch(() => null)
          );
          const details = await Promise.all(detailPromises);
          const detailMap = {};
          details.forEach(d => {
            if (d && d.id) detailMap[d.id] = d;
          });
          
          // source ã« dates ã‚’è£œå®Œ
          source = source.map(item => {
            const detail = detailMap[item.id];
            if (detail && detail.dates && Array.isArray(detail.dates) && detail.dates.length > 0) {
              return { ...item, dates: detail.dates, next_date: detail.dates[0].date };
            }
            return item;
          });
        } catch (e) {
          console.warn('[renderEventBlocks] Failed to enrich dates:', e);
        }
      }

      console.log('[renderEventBlocks] source length:', source.length);
      if (source.length > 0) {
        console.log('[renderEventBlocks] sample event:', source[0]);
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // ãŠã™ã™ã‚ï¼šisRecommended ã§ãƒ•ã‚£ãƒ«ã‚¿
      const recommended = source
        .filter(e => e.isRecommended)
        .slice(0, MAX_HOME_EVENTS);

      // æ–°ç€ï¼šisNew ã§ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆpublishedAt ãŒã‚ã‚Œã°ãã‚Œã§ã‚½ãƒ¼ãƒˆã€ãªã‘ã‚Œã°ãã®ã¾ã¾ï¼‰
      const newEvents = source
        .filter(e => e.isNew)
        .sort((a, b) => {
          const aDate = a.publishedAt ? new Date(a.publishedAt) : new Date(0);
          const bDate = b.publishedAt ? new Date(b.publishedAt) : new Date(0);
          return bDate - aDate; // æ–°ã—ã„é †
        })
        .slice(0, MAX_HOME_EVENTS);

      // ç›´è¿‘é–‹å‚¬ï¼šsourceï¼ˆeventIndexã€æ—¥ä»˜è£œå®Œæ¸ˆã¿ï¼‰ã‹ã‚‰ã€ä»Šæ—¥ä»¥é™ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ—¥ä»˜ã®è¿‘ã„é †ã«ã‚½ãƒ¼ãƒˆ
      console.log('[renderEventBlocks] source for upcoming:', source.length);
      if (source.length > 0) {
        console.log('[renderEventBlocks] first event:', source[0]);
        console.log('[renderEventBlocks] first event dates:', source[0].dates);
        console.log('[renderEventBlocks] first event next_date:', source[0].next_date);
      }
      console.log('[renderEventBlocks] today:', today.toISOString().split('T')[0]);
      
      // dates ã¾ãŸã¯ next_date ã‹ã‚‰æ—¥ä»˜ã‚’å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
      const getEventDate = (event) => {
        // dates é…åˆ—ã‹ã‚‰å–å¾—ï¼ˆå„ªå…ˆï¼‰
        if (event.dates && event.dates.length > 0 && event.dates[0] && event.dates[0].date) {
          const d = new Date(event.dates[0].date);
          if (!isNaN(d.getTime())) {
            return d;
          }
        }
        // next_date ã‹ã‚‰å–å¾—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        if (event.next_date) {
          const d = new Date(event.next_date);
          if (!isNaN(d.getTime())) {
            return d;
          }
        }
        // date_min ã‹ã‚‰å–å¾—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        if (event.date_min) {
          const d = new Date(event.date_min);
          if (!isNaN(d.getTime())) {
            return d;
          }
        }
        return null;
      };
      
      const upcomingCandidatesWithDates = source.map(event => {
        const eventDate = getEventDate(event);
        return { event, eventDate };
      });
      
      console.log('[renderEventBlocks] events with valid dates:', 
        upcomingCandidatesWithDates.filter(({ eventDate }) => eventDate !== null).length
      );
      
      const upcomingCandidates = upcomingCandidatesWithDates
        .filter(({ event, eventDate }) => {
          if (!eventDate || isNaN(eventDate.getTime())) {
            console.log('[renderEventBlocks] rejected (no date):', event.id);
            return false;
          }
          const eventDateOnly = new Date(eventDate);
          eventDateOnly.setHours(0, 0, 0, 0);
          const isUpcoming = eventDateOnly >= today;
          if (!isUpcoming) {
            console.log('[renderEventBlocks] rejected (past date):', event.id, eventDateOnly.toISOString().split('T')[0], 'today:', today.toISOString().split('T')[0]);
          }
          return isUpcoming;
        });
      
      console.log('[renderEventBlocks] upcomingCandidates:', upcomingCandidates.length);
      upcomingCandidates.forEach(({ event, eventDate }) => {
        console.log('[renderEventBlocks] upcoming:', event.id, event.title, eventDate.toISOString().split('T')[0]);
      });
      
      const upcoming = upcomingCandidates
        .sort((a, b) => a.eventDate - b.eventDate) // æ—¥ä»˜ã®è¿‘ã„é †ï¼ˆæ—©ã„é †ï¼‰
        .slice(0, MAX_HOME_EVENTS)
        .map(({ event }) => event); // event ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ã‚’è¿”ã™
      
      console.log('[renderEventBlocks] final upcoming count:', upcoming.length);

      // CardRendererãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿï¼‰
      if (typeof CardRenderer === 'undefined' || !CardRenderer.renderCarousel) {
        console.warn('[renderEventBlocks] CardRenderer not loaded yet, waiting...');
        // CardRendererãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã—ã¦ãƒªãƒˆãƒ©ã‚¤
        setTimeout(() => renderEventBlocks(), 100);
        return;
      }

      CardRenderer.renderCarousel(recommended, 'recommended-events');
      CardRenderer.renderCarousel(newEvents, 'new-events');
      CardRenderer.renderCarousel(upcoming, 'upcoming-events');
    }

    // ã‚«ãƒ«ãƒ¼ã‚»ãƒ«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
    function scrollCarousel(carouselId, direction) {
      const carousel = document.getElementById(carouselId);
      if (!carousel) return;
      
      const scrollAmount = 400;
      const currentScroll = carousel.scrollLeft;
      const newScroll = direction === 'right' 
        ? currentScroll + scrollAmount 
        : currentScroll - scrollAmount;
      
      carousel.scrollTo({
        left: newScroll,
        behavior: 'smooth'
      });
    }

    // ãƒ’ãƒ¼ãƒ­ãƒ¼èƒŒæ™¯ç”»åƒã®è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆï¼ˆæ»‘ã‚‰ã‹ãªãƒ•ã‚§ãƒ¼ãƒ‰ï¼‰
    function setupHeroBackground() {
      // Cloudinaryã‹ã‚‰ãƒ’ãƒ¼ãƒ­ãƒ¼ç”»åƒURLã‚’å–å¾—
      const heroImages = [];
      if (typeof window.getHeroImageUrl === 'function') {
        heroImages.push(window.getHeroImageUrl('winter_ctfkee'));
        heroImages.push(window.getHeroImageUrl('fuji_ebl1nh'));
      } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆCloudinaryé–¢æ•°ãŒåˆ©ç”¨ã§ããªã„å ´åˆï¼‰ - ç©ºã®é…åˆ—ã«ã™ã‚‹
        console.warn('[setupHeroBackground] getHeroImageUrl is not available');
      }

      // ç”»åƒã‚’äº‹å‰ã«èª­ã¿è¾¼ã‚€
      heroImages.forEach(src => {
        const img = new Image();
        img.src = src;
      });

      const bg1 = document.getElementById('hero-bg-1');
      const bg2 = document.getElementById('hero-bg-2');
      if (!bg1 || !bg2) return;

      // èƒŒæ™¯ç”»åƒã‚’è¨­å®š
      if (heroImages[0]) {
        bg1.style.backgroundImage = `url('${heroImages[0]}')`;
      }
      if (heroImages[1]) {
        bg2.style.backgroundImage = `url('${heroImages[1]}')`;
      }

      let currentBg = bg1;
      let nextBg = bg2;

      function changeBackground() {
        // æ¬¡ã®ç”»åƒã‚’è¡¨ç¤º
        nextBg.classList.add('active');
        currentBg.classList.remove('active');
        
        // æ¬¡ã®åˆ‡ã‚Šæ›¿ãˆã®ãŸã‚ã«å…¥ã‚Œæ›¿ãˆ
        const temp = currentBg;
        currentBg = nextBg;
        nextBg = temp;
      }

      // 5ç§’ã”ã¨ã«åˆ‡ã‚Šæ›¿ãˆ
      setInterval(changeBackground, 5000);
    }

    // åˆæœŸåŒ–ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ â†’ æç”»ï¼‰
    document.addEventListener('DOMContentLoaded', async () => {
      // ãƒ’ãƒ¼ãƒ­ãƒ¼èƒŒæ™¯ç”»åƒã®è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆã‚’é–‹å§‹
      setupHeroBackground();
      try {
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ï¼ˆdata.js ã§å®šç¾©ï¼‰
        await loadEventData();
        
        // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚«ãƒ†ã‚´ãƒªãƒ»æä¾›å…ƒï¼‰ã‚’èª­ã¿è¾¼ã¿
        if (typeof loadEventMeta === 'function') {
          try {
            await loadEventMeta();
          } catch (e) {
            console.warn('Failed to load eventMeta:', e);
          }
        }
        
        // eventIndex ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆãªã‘ã‚Œã°å†èª­ã¿è¾¼ã¿ï¼‰
        if (!Array.isArray(window.eventIndex) || window.eventIndex.length === 0) {
          try {
            await loadEventIndex();
          } catch (e) {
            console.warn('Failed to load eventIndex:', e);
          }
        }

        const yearElement = document.getElementById('current-year');
        if (yearElement) {
          yearElement.textContent = new Date().getFullYear();
        }

        renderPopSection(); // ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æç”»
        // ä½ç½®æƒ…å ±ãƒ™ãƒ¼ã‚¹ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’æœ€å„ªå…ˆã§è¡¨ç¤ºï¼ˆãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å¾Œã™ãã«å®Ÿè¡Œï¼‰
        // åœ°å›³ã‹ã‚‰æ¢ã™æ©Ÿèƒ½ã‚’åˆæœŸåŒ–
        initMapSearch();
        renderCategories();
        initCategoryMenu(); // ã‚«ãƒ†ã‚´ãƒªãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’åˆæœŸåŒ–ï¼ˆãƒ›ãƒãƒ¼è¡¨ç¤ºç”¨ï¼‰
        renderWeekCalendar();
        await renderEventBlocks();
        // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å¾Œã«ã‚«ãƒ†ã‚´ãƒªã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
        console.log('[index.html] After loadEventData - eventData:', window.eventData);
        console.log('[index.html] After loadEventData - eventData.events:', Array.isArray(window.eventData?.events) ? window.eventData.events.length : 'not array');
        if (window.eventData?.events && window.eventData.events.length > 0) {
          console.log('[index.html] Sample event:', window.eventData.events[0]);
          console.log('[index.html] Sample event categoryId:', window.eventData.events[0].categoryId);
        }
        renderPopularSearch(); // äººæ°—ã‚¿ã‚°ãƒ»åœ°åŸŸæ¤œç´¢ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æç”»

      } catch (e) {
        console.error(e);
        const el = document.getElementById('error');
        if (el) el.textContent = 'ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
      }
    });
  </script>
</body>
</html>
