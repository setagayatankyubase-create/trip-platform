<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="description" content="自然体験・イベント一覧。検索条件で絞り込んで、あなたにぴったりのアクティビティを見つけよう。">
  <title>イベント一覧 | そとなび</title>
  <link rel="icon" type="image/png" href="https://res.cloudinary.com/ddrxsy9jw/image/upload/f_auto,q_auto,w_32/logo_tfqqd0">
  <link rel="apple-touch-icon" href="https://res.cloudinary.com/ddrxsy9jw/image/upload/f_auto,q_auto,w_180/logo_tfqqd0">
  <link rel="stylesheet" href="styles.css">
  <script>
    // GitHub raw URL（全ページ共通設定）
    window.GITHUB_RAW_BASE = "https://raw.githubusercontent.com/setagayatankyubase-create/trip-platform/main";
  </script>
  <script src="data.js"></script>
  <script>
    // ロゴ画像をCloudinaryから取得（data.js読み込み後に実行）
    (function() {
      function setLogoUrl() {
        const logoImage = document.querySelector('.logo-image');
        if (logoImage && typeof window.getLogoUrl === 'function') {
          logoImage.src = window.getLogoUrl();
        }
      }
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setLogoUrl);
      } else {
        setLogoUrl();
      }
    })();
  </script>
</head>
<body>
  <header class="main-header" id="main-header">
    <div class="nav">
      <div class="nav-left">
        <a href="index.html" class="logo">
          <img src="" alt="そとなび" class="logo-image">
        </a>
      </div>
      <div class="nav-links">
        <a href="list.html">イベント一覧</a>
        <a href="organizer-list.html">提供元</a>
        <a href="column.html">コラム</a>
      </div>
    </div>
    <div class="search-bar">
      <div class="search-bar-wrapper" style="position: relative;">
        <form class="search-form" id="main-search-form" onsubmit="handleSearch(event)">
          <input type="text" id="search-query" placeholder="行きたい自然体験・場所を探す" name="q">
          <select id="search-category" name="category">
            <option value="">すべてのカテゴリ</option>
          </select>
          <input type="date" id="search-date" name="date">
          <select id="search-area" name="area">
            <option value="">すべてのエリア</option>
          </select>
          <button type="submit">検索</button>
        </form>
      </div>
    </div>
  </header>

  <main class="container">
    <div style="margin: 20px 0; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
      <h1 style="margin: 0; font-size: 1.5rem;">イベント一覧</h1>
      <div style="display: flex; gap: 10px; align-items: center;">
        <button id="filter-trigger" class="filter-reset" style="display: none;" onclick="BottomSheet.open()">フィルタ</button>
      </div>
    </div>

    <!-- フィルタ（デスクトップ） -->
    <div class="filters" id="desktop-filters">
    </div>

    <!-- マップ -->
    <div id="map-container" class="map-container hidden">
      <button class="map-toggle" onclick="toggleMap()">マップを閉じる</button>
      <div id="map"></div>
    </div>

    <!-- 結果表示 -->
    <div style="display: grid; grid-template-columns: 1fr; gap: 20px;">
      <div>
        <div style="margin-bottom: 16px; color: #6c7a72; font-size: 0.9rem;">
          <span id="result-count">0</span>件のイベントが見つかりました
          <span id="result-message"></span>
        </div>
        <div class="grid" id="event-list"></div>
        <div id="event-zero-suggestions"></div>
      </div>
    </div>
  </main>

  <!-- ボトムシート（モバイル用） -->
  <div id="bottom-sheet-overlay" class="bottom-sheet-overlay"></div>
  <div id="bottom-sheet" class="bottom-sheet">
    <div class="bottom-sheet-header">
      <h3 style="margin: 0;">フィルタ</h3>
      <button id="bottom-sheet-close" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text);">×</button>
    </div>
    <div class="bottom-sheet-content">
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 600;">カテゴリ</label>
        <select id="mobile-filter-category" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 10px;">
          <option value="">すべてのカテゴリ</option>
        </select>
      </div>
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 600;">エリア</label>
        <select id="mobile-filter-area" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 10px;">
          <option value="">すべてのエリア</option>
        </select>
      </div>
      <div style="display: flex; gap: 10px;">
        <button onclick="applyMobileFilters()" style="flex: 1; padding: 12px; background: var(--accent); color: white; border: none; border-radius: 10px; font-weight: 700; cursor: pointer;">適用</button>
      </div>
    </div>
  </div>

  <footer class="main-footer">
    <div class="footer-content">
      <div class="footer-column">
        <h3>サポート</h3>
        <a href="contact.html">お問い合わせ</a>
        <a href="terms.html">利用規約</a>
        <a href="privacy.html">プライバシーポリシー</a>
      </div>
      <div class="footer-column">
        <h3>運営情報</h3>
        <a href="about.html">運営について</a>
      </div>
      <div class="footer-column">
        <h3>掲載について</h3>
        <a href="publish.html">掲載について</a>
      </div>
    </div>
    <div class="footer-bottom">
      <div class="footer-copyright">
        © <span id="current-year"></span> そとなび. 製作
      </div>
    </div>
  </footer>

  <script src="data.js?v=4_2025-12-25"></script>
  <script src="app.js"></script>
  <script>
    let currentEvents = [];
    let mapVisible = false;

    // マップ表示切替
    function toggleMap() {
      const container = document.getElementById('map-container');
      const button = document.getElementById('map-toggle');
      mapVisible = !mapVisible;

      if (mapVisible) {
        container.classList.remove('hidden');
        button.textContent = 'マップを閉じる';
        if (!MapManager.mapInstance) {
          MapManager.init('map');
          renderMapMarkers();
        }
      } else {
        container.classList.add('hidden');
        button.textContent = 'マップ表示';
      }
    }

    // マップマーカーの表示
    function renderMapMarkers() {
      MapManager.clearMarkers();
      currentEvents.forEach(event => {
        if (event.location && event.location.lat) {
          MapManager.addMarker(event, () => {});
        }
      });
    }

    // フィルタ適用
    async function applyFilters() {
      const params = {
        q: document.getElementById('search-query')?.value || '',
        category: document.getElementById('search-category')?.value || '',
        area: document.getElementById('search-area')?.value || '',
        date: document.getElementById('search-date')?.value || '',
      };
      URLManager.updateParams(params);
      await loadEvents();
    }

    // モバイルフィルタ適用
    async function applyMobileFilters() {
      const params = {
        q: document.getElementById('search-query')?.value || '',
        category: document.getElementById('mobile-filter-category')?.value || '',
        area: document.getElementById('mobile-filter-area')?.value || '',
        date: document.getElementById('mobile-filter-date')?.value || '',
      };
      URLManager.updateParams(params);
      BottomSheet.close();
      await loadEvents();
    }

    // フィルタリセット
    function resetFilters() {
      URLManager.setParams({});
      window.location.reload();
    }

    // 検索処理
    async function handleSearch(event) {
      event.preventDefault();
      const formData = new FormData(event.target);
      const params = {
        q: formData.get('q') || '',
        category: formData.get('category') || '',
        date: formData.get('date') || '',
        area: formData.get('area') || ''
      };
      // URLパラメータを更新
      URLManager.setParams(params);
      // loadEvents は async なので await する
      await loadEvents();
    }

    // 一覧用フィルタ処理（events_index を前提に軽量実装）
    function filterIndexEvents(events, params, urlParams) {
      let filtered = [...events];

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // URLパラメータによる事前フィルタ（recommended / new / upcoming）
      if (urlParams.get('recommended') === '1') {
        filtered = filtered.filter(e => e.isRecommended);
      } else if (urlParams.get('new') === '1') {
        filtered = filtered.filter(e => e.isNew);
      } else if (urlParams.get('upcoming') === '1') {
        filtered = filtered.filter(e => {
          if (!e.next_date) return false;
          const d = new Date(e.next_date);
          d.setHours(0, 0, 0, 0);
          return d >= today;
        });
      }

      // フリーワード検索
      if (params.q) {
        const q = params.q.toLowerCase();
        filtered = filtered.filter(e => {
          const texts = [
            e.title,
            e.city,
            e.prefecture
          ];
          return texts.some(t => typeof t === 'string' && t.toLowerCase().includes(q));
        });
      }

      // カテゴリ（categoryId が無い場合はスキップ）
      if (params.category) {
        filtered = filtered.filter(e => {
          const catId = e.categoryId || e.category_id || '';
          return String(catId) === String(params.category);
        });
      }

      // エリア（city / prefecture ベースの簡易実装）
      if (params.area) {
        filtered = filtered.filter(e => {
          const v = String(params.area);
          return e.city === v || e.prefecture === v || e.area === v;
        });
      }

      // 日付（単日）
      if (params.date) {
        const target = new Date(params.date);
        target.setHours(0, 0, 0, 0);
        filtered = filtered.filter(e => {
          // dates配列を優先的にチェック（複数日程に対応）
          if (e.dates && Array.isArray(e.dates) && e.dates.length > 0) {
            const matched = e.dates.some(d => {
              if (!d.date) return false;
              const eventDate = new Date(d.date);
              eventDate.setHours(0, 0, 0, 0);
              return eventDate.getTime() === target.getTime();
            });
            if (matched) return true;
          }
          
          // フォールバック: next_date / date_min / date_max をチェック
          const next = e.next_date ? new Date(e.next_date) : null;
          if (next) {
            next.setHours(0, 0, 0, 0);
            if (next.getTime() === target.getTime()) return true;
          }
          const min = e.date_min ? new Date(e.date_min) : null;
          const max = e.date_max ? new Date(e.date_max) : null;
          if (min && max) {
            min.setHours(0, 0, 0, 0);
            max.setHours(0, 0, 0, 0);
            return target >= min && target <= max;
          }
          return false;
        });
      }

      // 開催週（今週 / 来週）
      if (params.weekday === 'this-week' || params.weekday === 'next-week') {
        const dayOfWeek = today.getDay(); // 0=日
        const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - daysFromMonday + (params.weekday === 'next-week' ? 7 : 0));
        startOfWeek.setHours(0, 0, 0, 0);
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6);

        filtered = filtered.filter(e => {
          // dates配列を優先的にチェック（複数日程に対応）
          if (e.dates && Array.isArray(e.dates) && e.dates.length > 0) {
            const matched = e.dates.some(d => {
              if (!d.date) return false;
              const eventDate = new Date(d.date);
              eventDate.setHours(0, 0, 0, 0);
              return eventDate >= startOfWeek && eventDate <= endOfWeek;
            });
            if (matched) return true;
          }
          
          // フォールバック: next_date をチェック
          const next = e.next_date ? new Date(e.next_date) : null;
          if (!next) return false;
          next.setHours(0, 0, 0, 0);
          return next >= startOfWeek && next <= endOfWeek;
        });
      }

      return filtered;
    }

    // 検索条件に近いおすすめイベントを取得（events_index ベース）
    function getSimilarIndexEvents(events, params, limit = 8) {
      if (!Array.isArray(events) || events.length === 0) return [];

      const q = (params.q || '').toLowerCase();
      const categoryId = params.category || '';
      const areaParam = params.area || '';
      const dateParam = params.date || '';
      const weekdayParam = params.weekday || '';

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      let targetStart = null;
      let targetEnd = null;

      // 日付指定 or 今週/来週 をターゲット期間として使う
      if (dateParam) {
        const d = new Date(dateParam);
        d.setHours(0, 0, 0, 0);
        targetStart = new Date(d);
        targetEnd = new Date(d);
      } else if (weekdayParam === 'this-week' || weekdayParam === 'next-week') {
        const dayOfWeek = today.getDay(); // 0=日
        const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
        targetStart = new Date(today);
        targetStart.setDate(today.getDate() - daysFromMonday + (weekdayParam === 'next-week' ? 7 : 0));
        targetStart.setHours(0, 0, 0, 0);
        targetEnd = new Date(targetStart);
        targetEnd.setDate(targetStart.getDate() + 6);
      }

      const scored = events
        .map(event => {
          let score = 0;

          // カテゴリ一致
          if (categoryId) {
            if (String(event.categoryId || '') === String(categoryId)) {
              score += 5;
            }
          }

          // エリア一致（city / prefecture / area）
          if (areaParam) {
            if (event.city === areaParam) score += 4;
            if (event.prefecture === areaParam) score += 3;
            if (event.area === areaParam) score += 2;
          }

          // キーワード一致（タイトル・エリア）
          if (q) {
            const text = `${event.title || ''} ${event.city || ''} ${event.prefecture || ''}`.toLowerCase();
            if (text.includes(q)) score += 4;
          }

          // 日程の近さ（dates配列 / next_date / date_min / date_max）
          if (targetStart && targetEnd) {
            let bestScore = 0;
            
            // dates配列を優先的にチェック（複数日程に対応）
            if (event.dates && Array.isArray(event.dates) && event.dates.length > 0) {
              event.dates.forEach(d => {
                if (!d.date) return;
                const eventDate = new Date(d.date);
                eventDate.setHours(0, 0, 0, 0);
                
                if (eventDate >= targetStart && eventDate <= targetEnd) {
                  bestScore = Math.max(bestScore, 5); // 期間内なら最高スコア
                } else {
                  const center = new Date((targetStart.getTime() + targetEnd.getTime()) / 2);
                  const diffDays = Math.abs(eventDate - center) / (1000 * 60 * 60 * 24);
                  if (diffDays <= 7) {
                    bestScore = Math.max(bestScore, Math.max(1, 4 - Math.floor(diffDays)));
                  }
                }
              });
            }
            
            // フォールバック: next_date / date_min
            if (bestScore === 0) {
              let base = null;
              if (event.next_date) {
                base = new Date(event.next_date);
              } else if (event.date_min) {
                base = new Date(event.date_min);
              }

              if (base) {
                base.setHours(0, 0, 0, 0);
                if (base >= targetStart && base <= targetEnd) {
                  bestScore = 5;
                } else {
                  const center = new Date((targetStart.getTime() + targetEnd.getTime()) / 2);
                  const diffDays = Math.abs(base - center) / (1000 * 60 * 60 * 24);
                  if (diffDays <= 7) {
                    bestScore = Math.max(1, 4 - Math.floor(diffDays));
                  }
                }
              }
            }
            
            score += bestScore;
          }

          return { event, score };
        })
        .filter(item => item.score > 0)
        .sort((a, b) => b.score - a.score);

      let result = scored.slice(0, limit).map(item => item.event);

      // それでも空なら、単純におすすめフラグ付き or 直近開催から埋める
      if (result.length === 0) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const recommended = events.filter(e => e.isRecommended);
        if (recommended.length) {
          result = recommended.slice(0, limit);
        } else {
          result = events
            .map(e => {
              const d = e.next_date ? new Date(e.next_date) : today;
              d.setHours(0, 0, 0, 0);
              const diff = Math.abs(d - today) / (1000 * 60 * 60 * 24);
              return { event: e, diff };
            })
            .sort((a, b) => a.diff - b.diff)
            .slice(0, limit)
            .map(item => item.event);
        }
      }

      return result;
    }

    // イベント読み込み（events_index ベース）
    async function loadEvents() {
      const params = URLManager.getParams();
      const urlParams = new URLSearchParams(window.location.search);

      // events_index が読み込まれていない場合は待つ
      if (!Array.isArray(window.eventIndex)) {
        try {
          await loadEventIndex();
        } catch (e) {
          console.error('Failed to load event index:', e);
        }
      }

      // events_index が前提
      let index = Array.isArray(window.eventIndex) ? window.eventIndex : [];

      // カテゴリ検索で categoryId が無い場合、詳細JSONから補完
      if (params.category && index.length > 0 && !index[0].categoryId && !index[0].category_id) {
        try {
          // 最初の数件だけ詳細を読み込んで categoryId を補完
          const sampleIds = index.slice(0, 10).map(e => e.id).filter(Boolean);
          const detailPromises = sampleIds.map(id => 
            loadEventDetail(id).catch(() => null)
          );
          const details = await Promise.all(detailPromises);
          const detailMap = {};
          details.forEach(d => {
            if (d && d.id) detailMap[d.id] = d;
          });
          
          // index に categoryId を補完
          index = index.map(item => {
            const detail = detailMap[item.id];
            if (detail && detail.categoryId) {
              return { ...item, categoryId: detail.categoryId };
            }
            return item;
          });
        } catch (e) {
          console.warn('Failed to enrich categoryId:', e);
        }
      }

      // 日付検索の場合、詳細JSONから dates 配列を補完
      if (params.date && index.length > 0) {
        try {
          const target = new Date(params.date);
          target.setHours(0, 0, 0, 0);
          
          console.log('[list.html] Date search - target date:', params.date, 'target object:', target);
          console.log('[list.html] Date search - index length:', index.length);
          console.log('[list.html] Date search - sample event:', index[0]);
          
          // date_min と date_max で候補を絞り込み（範囲内にある可能性のあるイベントのみ）
          const candidateIds = index
            .filter(e => {
              // date_min/date_maxがある場合は範囲内かチェック
              if (e.date_min && e.date_max) {
                const min = new Date(e.date_min);
                const max = new Date(e.date_max);
                min.setHours(0, 0, 0, 0);
                max.setHours(0, 0, 0, 0);
                const inRange = target >= min && target <= max;
                if (inRange) {
                  console.log('[list.html] Candidate found:', e.id, 'date_min:', e.date_min, 'date_max:', e.date_max);
                }
                // 範囲内なら候補
                return inRange;
              }
              // date_min/date_maxがない場合は、next_dateが一致する可能性を考慮
              if (e.next_date) {
                const next = new Date(e.next_date);
                next.setHours(0, 0, 0, 0);
                const matches = next.getTime() === target.getTime();
                if (matches) {
                  console.log('[list.html] Candidate found by next_date:', e.id, 'next_date:', e.next_date);
                }
                return matches;
              }
              // どちらもない場合は候補から除外
              return false;
            })
            .map(e => e.id)
            .filter(Boolean);
          
          console.log('[list.html] Date search candidates:', candidateIds.length, candidateIds);
          
          // 候補が0件の場合は、すべてのイベントを候補として扱う（フォールバック）
          const finalCandidateIds = candidateIds.length > 0 ? candidateIds : index.map(e => e.id).filter(Boolean);
          
          if (candidateIds.length === 0) {
            console.warn('[list.html] No candidates found by date_min/date_max, checking all events');
          }
          
          // 候補の詳細JSONを読み込んで dates 配列を補完
          const detailPromises = finalCandidateIds.map(id => 
            loadEventDetail(id).catch(() => null)
          );
          const details = await Promise.all(detailPromises);
          const detailMap = {};
          details.forEach(d => {
            if (d && d.id && d.dates && Array.isArray(d.dates)) {
              detailMap[d.id] = d;
            }
          });
          
          console.log('[list.html] Enriched dates for:', Object.keys(detailMap).length, 'events');
          
          // index に dates 配列を補完
          index = index.map(item => {
            const detail = detailMap[item.id];
            if (detail && detail.dates) {
              return { ...item, dates: detail.dates };
            }
            return item;
          });
        } catch (e) {
          console.error('Failed to enrich dates:', e);
        }
      }

      // 検索・フィルタ適用
      currentEvents = filterIndexEvents(index, params, urlParams);

      // 結果表示
      CardRenderer.renderList(currentEvents, 'event-list');

      // 件数とメッセージ
      const resultCountEl = document.getElementById('result-count');
      const resultMessageEl = document.getElementById('result-message');
      if (resultCountEl) {
        resultCountEl.textContent = currentEvents.length;
      }
      if (resultMessageEl) {
        if (currentEvents.length === 0) {
          resultMessageEl.textContent = '。条件を少しゆるめるか、別の切り口から探してみましょう。';
        } else {
          resultMessageEl.textContent = '';
        }
      }

      // 0件時のおすすめ導線（検索条件に近いイベントを表示）
      const zeroSuggestContainer = document.getElementById('event-zero-suggestions');
      if (zeroSuggestContainer) {
        zeroSuggestContainer.innerHTML = '';

        if (currentEvents.length === 0) {
          let similar = getSimilarIndexEvents(index, params, 8);

          // index ベースで出せなかった場合は、従来どおり full データ＋SearchFilter でフォールバック
          if ((!similar || similar.length === 0) && typeof SearchFilter !== 'undefined' && typeof loadEventData === 'function') {
            try {
              await loadEventData(); // 重いが、0件時のみのフォールバック
              if (typeof SearchFilter.getSimilarEvents === 'function' && window.eventData && Array.isArray(window.eventData.events)) {
                similar = SearchFilter.getSimilarEvents(params, 8);
              }
            } catch (e) {
              console.warn('fallback getSimilarEvents failed:', e);
            }
          }

          if (similar.length) {
            const html = `
              <section class="empty-suggestions-section">
                <h4>検索条件に近いおすすめイベント</h4>
                <div class="card-carousel-wrapper">
                  <div class="card-carousel">
                    ${similar.map(ev => CardRenderer.render(ev)).join('')}
                  </div>
                </div>
              </section>
            `;
            zeroSuggestContainer.innerHTML = html;
          }
        }
      }

      // マップ更新
      if (mapVisible) {
        renderMapMarkers();
      }

      // 検索フォームに値を設定
      const searchQueryEl = document.getElementById('search-query');
      const searchCategoryEl = document.getElementById('search-category');
      const searchDateEl = document.getElementById('search-date');
      const searchAreaEl = document.getElementById('search-area');
      const mobileFilterCategoryEl = document.getElementById('mobile-filter-category');
      const mobileFilterAreaEl = document.getElementById('mobile-filter-area');
      const mobileFilterDateEl = document.getElementById('mobile-filter-date');
      
      if (searchQueryEl) searchQueryEl.value = params.q || '';
      if (searchCategoryEl) searchCategoryEl.value = params.category || '';
      if (searchDateEl) searchDateEl.value = params.date || '';
      if (searchAreaEl) searchAreaEl.value = params.area || '';
      if (mobileFilterCategoryEl) mobileFilterCategoryEl.value = params.category || '';
      if (mobileFilterAreaEl) mobileFilterAreaEl.value = params.area || '';
      if (mobileFilterDateEl) mobileFilterDateEl.value = params.date || '';
    }

    // カテゴリ・エリアの選択肢を設定（eventMeta / eventIndex ベース）
    function populateOptions() {
      const selects = [
        'search-category', 'mobile-filter-category'
      ];
      const areaSelects = [
        'search-area', 'mobile-filter-area'
      ];

      const categories = (window.eventMeta && window.eventMeta.categories)
        ? window.eventMeta.categories
        : (window.eventData && window.eventData.categories) ? window.eventData.categories : [];
      let areas = [];

      // カテゴリ: 単純に id / name で表示
      selects.forEach(selectId => {
        const select = document.getElementById(selectId);
        if (select && categories.length) {
          categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.id;
            option.textContent = cat.name;
            select.appendChild(option);
          });
        }
      });

      // イベントインデックスからエリア候補を生成
      const areaMap = {};
      if (Array.isArray(window.eventIndex)) {
        window.eventIndex.forEach(ev => {
          const id = ev.area || ev.city || ev.prefecture;
          const name = ev.area || ev.city || ev.prefecture;
          if (id && !areaMap[id]) {
            areaMap[id] = { id, name };
          }
        });
      }
      areas = Object.values(areaMap);

      // エリア: 文字列配列 or オブジェクト配列の両方に対応
      if (areas && areas.length) {
        // オブジェクト配列の場合は親子関係を考慮してラベルを作る
        const first = areas[0];
        let areaById = {};
        let isObjectArea = typeof first === 'object';

        if (isObjectArea) {
          areas.forEach(a => {
            if (a && a.id) {
              areaById[a.id] = a;
            }
          });
        }

        areaSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            areas.forEach(area => {
              const option = document.createElement('option');

              if (typeof area === 'string') {
                // 旧: 文字列のエリア名だけを持つ場合
                option.value = area;
                option.textContent = area;
              } else if (area && typeof area === 'object') {
                // 新: id / name / parent_id を持つオブジェクト
                const value = area.id || area.slug || area.name;
                let label = area.name || area.slug || area.id;

                if (area.parent_id && areaById[area.parent_id]) {
                  const parent = areaById[area.parent_id];
                  const parentName = parent.name || parent.slug || parent.id;
                  label = `${parentName} - ${label}`;
                }

                option.value = value;
                option.textContent = label;
              }

              select.appendChild(option);
            });
          }
        });
      }
    }

    // モバイル判定
    function checkMobile() {
      const isMobile = window.innerWidth <= 768;
      document.getElementById('desktop-filters').style.display = isMobile ? 'none' : 'flex';
      document.getElementById('filter-trigger').style.display = isMobile ? 'block' : 'none';
    }

    // 初期化
    // カテゴリメニューを初期化（ホバーで表示されるので、事前にレンダリングしておく）
    function initCategoryMenu() {
      const menuList = document.getElementById('category-menu-list');
      if (!menuList) return;

      if (!window.eventData || !window.eventData.categories) return;
      menuList.innerHTML = window.eventData.categories.map(cat => `
        <a href="list.html?category=${cat.id}" class="category-menu-item">
          <span class="icon">${cat.icon}</span>
          <span>${cat.name}</span>
        </a>
      `).join('');
    }

    document.addEventListener('DOMContentLoaded', async () => {
      try {
        // 一覧用インデックス＋メタデータのみを読み込み
        await Promise.all([loadEventIndex(), loadEventMeta()]);

        const yearElement = document.getElementById('current-year');
        if (yearElement) {
          yearElement.textContent = new Date().getFullYear();
        }
        populateOptions();
        initCategoryMenu(); // カテゴリメニューを初期化
        checkMobile();
        loadEvents();
        window.addEventListener('resize', checkMobile);

      } catch (e) {
        console.error(e);
        const el = document.getElementById('error');
        if (el) el.textContent = 'データの読み込みに失敗しました';
      }
    });
  </script>
</body>
</html>

